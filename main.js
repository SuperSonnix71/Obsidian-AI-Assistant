/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AiAssistantPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian8 = require("obsidian");

// src/settings/defaults.ts
var DEFAULT_SETTINGS = {
  activeProvider: "ollama",
  providers: {
    ollama: {
      baseUrl: "http://localhost:11434",
      model: "llama2",
      temperature: 0.7
    },
    openai: {
      baseUrl: "https://api.openai.com/v1",
      apiKey: "",
      model: "gpt-3.5-turbo",
      temperature: 0.7
    }
  },
  webSearch: {
    enabled: false,
    urlTemplate: "https://searx.be/search?q=%s&format=json",
    // Example output
    timeoutMs: 8e3,
    maxResults: 5,
    safeSearch: 1
  },
  history: {
    perNoteMaxMessages: 80,
    vaultMaxMessages: 400,
    maxMessageChars: 2e4,
    summarizationThreshold: 0.8
  },
  ui: {
    themeBaseColor: "neutral",
    rememberLastCommand: true,
    modalWidthPx: 980,
    modalHeightPx: 720
  }
};

// node_modules/uuid/dist/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/uuid/dist/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = { randomUUID };

// node_modules/uuid/dist/v4.js
function _v4(options, buf, offset) {
  var _a, _b, _c;
  options = options || {};
  const rnds = (_c = (_b = options.random) != null ? _b : (_a = options.rng) == null ? void 0 : _a.call(options)) != null ? _c : rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
    }
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  return _v4(options, buf, offset);
}
var v4_default = v4;

// src/history/store.ts
var HistoryService = class {
  constructor(plugin, initialData) {
    this.plugin = plugin;
    this.store = {
      version: 1,
      threads: (initialData == null ? void 0 : initialData.threads) || {},
      noteIndex: (initialData == null ? void 0 : initialData.noteIndex) || {},
      vaultThreadId: (initialData == null ? void 0 : initialData.vaultThreadId) || v4_default()
    };
    if (!this.store.threads[this.store.vaultThreadId]) {
      this.store.threads[this.store.vaultThreadId] = this.createThread("vault", "Global Vault Chat");
    }
  }
  getStore() {
    return this.store;
  }
  getNoteThread(notePath) {
    let threadId = this.store.noteIndex[notePath];
    if (!threadId || !this.store.threads[threadId]) {
      threadId = v4_default();
      this.store.noteIndex[notePath] = threadId;
      this.store.threads[threadId] = this.createThread("note", "Note Chat", notePath);
      this.store.threads[threadId].id = threadId;
    }
    return this.store.threads[threadId];
  }
  getVaultThread() {
    return this.store.threads[this.store.vaultThreadId];
  }
  updateThread(thread) {
    this.store.threads[thread.id] = thread;
    this.save();
  }
  async save() {
    await this.plugin.saveData(this.plugin.settings);
  }
  createThread(scope, title, notePath) {
    return {
      id: v4_default(),
      scope,
      notePath,
      title,
      createdAt: Date.now(),
      updatedAt: Date.now(),
      messages: []
    };
  }
  addMessage(threadId, message) {
    const thread = this.store.threads[threadId];
    if (!thread) return;
    const settings = this.plugin.settings;
    const provider = settings.activeProvider;
    const providerSettings = settings.providers[provider];
    const chatMessage = {
      id: v4_default(),
      role: message.role,
      content: message.content,
      createdAt: Date.now(),
      providerSnapshot: {
        kind: provider,
        baseUrl: providerSettings.baseUrl || "",
        model: providerSettings.model || "",
        temperature: providerSettings.temperature || 0.7
      }
    };
    thread.messages.push(chatMessage);
    thread.updatedAt = Date.now();
    this.save();
  }
  clearThread(threadId) {
    const thread = this.store.threads[threadId];
    if (!thread) return;
    thread.messages = [];
    thread.updatedAt = Date.now();
    this.save();
  }
  clearVaultThread() {
    this.clearThread(this.store.vaultThreadId);
  }
  clearNoteThread(notePath) {
    const threadId = this.store.noteIndex[notePath];
    if (threadId) {
      this.clearThread(threadId);
    }
  }
};

// src/ui/view.ts
var import_obsidian7 = require("obsidian");

// node_modules/svelte/src/runtime/internal/utils.js
function noop() {
}
var identity = (x) => x;
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}

// node_modules/svelte/src/runtime/internal/environment.js
var is_client = typeof window !== "undefined";
var now = is_client ? () => window.performance.now() : () => Date.now();
var raf = is_client ? (cb) => requestAnimationFrame(cb) : noop;

// node_modules/svelte/src/runtime/internal/loop.js
var tasks = /* @__PURE__ */ new Set();
function run_tasks(now2) {
  tasks.forEach((task) => {
    if (!task.c(now2)) {
      tasks.delete(task);
      task.f();
    }
  });
  if (tasks.size !== 0) raf(run_tasks);
}
function loop(callback) {
  let task;
  if (tasks.size === 0) raf(run_tasks);
  return {
    promise: new Promise((fulfill) => {
      tasks.add(task = { c: callback, f: fulfill });
    }),
    abort() {
      tasks.delete(task);
    }
  };
}

// node_modules/svelte/src/runtime/internal/globals.js
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);

// node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
var ResizeObserverSingleton = class _ResizeObserverSingleton {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    __publicField(this, "_listeners", "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0);
    /**
     * @private
     * @type {ResizeObserver}
     */
    __publicField(this, "_observer");
    /** @type {ResizeObserverOptions} */
    __publicField(this, "options");
    this.options = options;
  }
  /**
   * @param {Element} element
   * @param {import('./private.js').Listener} listener
   * @returns {() => void}
   */
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  /**
   * @private
   */
  _getObserver() {
    var _a;
    return (_a = this._observer) != null ? _a : this._observer = new ResizeObserver((entries) => {
      var _a2;
      for (const entry of entries) {
        _ResizeObserverSingleton.entries.set(entry.target, entry);
        (_a2 = this._listeners.get(entry.target)) == null ? void 0 : _a2(entry);
      }
    });
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

// node_modules/svelte/src/runtime/internal/dom.js
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node) return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && /** @type {ShadowRoot} */
  root.host) {
    return (
      /** @type {ShadowRoot} */
      root
    );
  }
  return node.ownerDocument;
}
function append_empty_stylesheet(node) {
  const style_element = element("style");
  style_element.textContent = "/* empty */";
  append_stylesheet(get_root_for_style(node), style_element);
  return style_element.sheet;
}
function append_stylesheet(node, style) {
  append(
    /** @type {Document} */
    node.head || node,
    style
  );
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i]) iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null) node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data) return;
  text2.data = /** @type {string} */
  data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  return new CustomEvent(type, { detail, bubbles, cancelable });
}
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach(
    /** @param {Element} node */
    (node) => {
      result[node.slot || "default"] = true;
    }
  );
  return result;
}

// node_modules/svelte/src/runtime/internal/style_manager.js
var managed_styles = /* @__PURE__ */ new Map();
var active = 0;
function hash(str) {
  let hash2 = 5381;
  let i = str.length;
  while (i--) hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i);
  return hash2 >>> 0;
}
function create_style_information(doc, node) {
  const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
  managed_styles.set(doc, info);
  return info;
}
function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
  const step = 16.666 / duration;
  let keyframes = "{\n";
  for (let p = 0; p <= 1; p += step) {
    const t = a + (b - a) * ease(p);
    keyframes += p * 100 + `%{${fn(t, 1 - t)}}
`;
  }
  const rule = keyframes + `100% {${fn(b, 1 - b)}}
}`;
  const name = `__svelte_${hash(rule)}_${uid}`;
  const doc = get_root_for_style(node);
  const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
  if (!rules[name]) {
    rules[name] = true;
    stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
  }
  const animation = node.style.animation || "";
  node.style.animation = `${animation ? `${animation}, ` : ""}${name} ${duration}ms linear ${delay}ms 1 both`;
  active += 1;
  return name;
}
function delete_rule(node, name) {
  const previous = (node.style.animation || "").split(", ");
  const next = previous.filter(
    name ? (anim) => anim.indexOf(name) < 0 : (anim) => anim.indexOf("__svelte") === -1
    // remove all Svelte animations
  );
  const deleted = previous.length - next.length;
  if (deleted) {
    node.style.animation = next.join(", ");
    active -= deleted;
    if (!active) clear_rules();
  }
}
function clear_rules() {
  raf(() => {
    if (active) return;
    managed_styles.forEach((info) => {
      const { ownerNode } = info.stylesheet;
      if (ownerNode) detach(ownerNode);
    });
    managed_styles.clear();
  });
}

// node_modules/svelte/src/runtime/internal/lifecycle.js
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component) throw new Error("Function called outside component initialization");
  return current_component;
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(
        /** @type {string} */
        type,
        detail,
        { cancelable }
      );
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}

// node_modules/svelte/src/runtime/internal/scheduler.js
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length) binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}

// node_modules/svelte/src/runtime/internal/transitions.js
var promise;
function wait() {
  if (!promise) {
    promise = Promise.resolve();
    promise.then(() => {
      promise = null;
    });
  }
  return promise;
}
function dispatch(node, direction, kind) {
  node.dispatchEvent(custom_event(`${direction ? "intro" : "outro"}${kind}`));
}
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block)) return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2) block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
var null_transition = { duration: 0 };
function create_bidirectional_transition(node, fn, params, intro) {
  const options = { direction: "both" };
  let config = fn(node, params, options);
  let t = intro ? 0 : 1;
  let running_program = null;
  let pending_program = null;
  let animation_name = null;
  let original_inert_value;
  function clear_animation() {
    if (animation_name) delete_rule(node, animation_name);
  }
  function init2(program, duration) {
    const d = (
      /** @type {Program['d']} */
      program.b - t
    );
    duration *= Math.abs(d);
    return {
      a: t,
      b: program.b,
      d,
      duration,
      start: program.start,
      end: program.start + duration,
      group: program.group
    };
  }
  function go(b) {
    const {
      delay = 0,
      duration = 300,
      easing = identity,
      tick: tick2 = noop,
      css
    } = config || null_transition;
    const program = {
      start: now() + delay,
      b
    };
    if (!b) {
      program.group = outros;
      outros.r += 1;
    }
    if ("inert" in node) {
      if (b) {
        if (original_inert_value !== void 0) {
          node.inert = original_inert_value;
        }
      } else {
        original_inert_value = /** @type {HTMLElement} */
        node.inert;
        node.inert = true;
      }
    }
    if (running_program || pending_program) {
      pending_program = program;
    } else {
      if (css) {
        clear_animation();
        animation_name = create_rule(node, t, b, duration, delay, easing, css);
      }
      if (b) tick2(0, 1);
      running_program = init2(program, duration);
      add_render_callback(() => dispatch(node, b, "start"));
      loop((now2) => {
        if (pending_program && now2 > pending_program.start) {
          running_program = init2(pending_program, duration);
          pending_program = null;
          dispatch(node, running_program.b, "start");
          if (css) {
            clear_animation();
            animation_name = create_rule(
              node,
              t,
              running_program.b,
              running_program.duration,
              0,
              easing,
              config.css
            );
          }
        }
        if (running_program) {
          if (now2 >= running_program.end) {
            tick2(t = running_program.b, 1 - t);
            dispatch(node, running_program.b, "end");
            if (!pending_program) {
              if (running_program.b) {
                clear_animation();
              } else {
                if (!--running_program.group.r) run_all(running_program.group.c);
              }
            }
            running_program = null;
          } else if (now2 >= running_program.start) {
            const p = now2 - running_program.start;
            t = running_program.a + running_program.d * easing(p / running_program.duration);
            tick2(t, 1 - t);
          }
        }
        return !!(running_program || pending_program);
      });
    }
  }
  return {
    run(b) {
      if (is_function(config)) {
        wait().then(() => {
          const opts = { direction: b ? "in" : "out" };
          config = config(opts);
          go(b);
        });
      } else {
        go(b);
      }
    },
    end() {
      clear_animation();
      running_program = pending_program = null;
    }
  };
}

// node_modules/svelte/src/runtime/internal/each.js
function ensure_array_like(array_like_or_iterator) {
  return (array_like_or_iterator == null ? void 0 : array_like_or_iterator.length) !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}

// node_modules/svelte/src/shared/boolean_attributes.js
var _boolean_attributes = (
  /** @type {const} */
  [
    "allowfullscreen",
    "allowpaymentrequest",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "hidden",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected"
  ]
);
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

// node_modules/svelte/src/runtime/internal/Component.js
function bind(component, name, callback) {
  const index = component.$$.props[name];
  if (index !== void 0) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance4, create_fragment4, not_equal, props, append_styles2 = null, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance4 ? instance4(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
      if (ready) make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment4 ? create_fragment4($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro) transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, Function[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
      if (this.$$l[type]) {
        const idx = this.$$l[type].indexOf(listener);
        if (idx >= 0) {
          this.$$l[type].splice(idx, 1);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot = function(name) {
          return () => {
            let node;
            const obj = {
              c: function create() {
                node = element("slot");
                if (name !== "default") {
                  attr(node, "name", name);
                }
              },
              /**
               * @param {HTMLElement} target
               * @param {HTMLElement} [anchor]
               */
              m: function mount(target, anchor) {
                insert(target, node, anchor);
              },
              d: function destroy(detaching) {
                if (detaching) {
                  detach(node);
                }
              }
            };
            return obj;
          };
        };
        await Promise.resolve();
        if (!this.$$cn || this.$$c) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            $$slots[name] = [create_slot(name)];
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key in this.$$p_d) {
          if (!(key in this.$$d) && this[key] !== void 0) {
            this.$$d[key] = this[key];
            delete this[key];
          }
        }
        this.$$c = new this.$$ctor({
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$scope: {
              ctx: []
            }
          }
        });
        const reflect_attributes = () => {
          this.$$r = true;
          for (const key in this.$$p_d) {
            this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];
            if (this.$$p_d[key].reflect) {
              const attribute_value = get_custom_element_value(
                key,
                this.$$d[key],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(this.$$p_d[key].attribute || key);
              } else {
                this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
              }
            }
          }
          this.$$r = false;
        };
        this.$$c.$$.after_update.push(reflect_attributes);
        reflect_attributes();
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    attributeChangedCallback(attr2, _oldValue, newValue) {
      var _a;
      if (this.$$r) return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      (_a = this.$$c) == null ? void 0 : _a.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn && this.$$c) {
          this.$$c.$destroy();
          this.$$c = void 0;
        }
      });
    }
    $$g_p(attribute_name) {
      return Object.keys(this.$$p_d).find(
        (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop, value, props_definition, transform) {
  var _a;
  const type = (_a = props_definition[prop]) == null ? void 0 : _a.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      // conversion already handled above
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
var SvelteComponent = class {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1) callbacks.splice(index, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/src/shared/version.js
var PUBLIC_VERSION = "4";

// node_modules/svelte/src/runtime/internal/disclose-version/index.js
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

// node_modules/svelte/src/runtime/easing/index.js
function cubicOut(t) {
  const f = t - 1;
  return f * f * f + 1;
}

// node_modules/svelte/src/runtime/transition/index.js
function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
  const o = +getComputedStyle(node).opacity;
  return {
    delay,
    duration,
    easing,
    css: (t) => `opacity: ${t * o}`
  };
}
function slide(node, { delay = 0, duration = 400, easing = cubicOut, axis = "y" } = {}) {
  const style = getComputedStyle(node);
  const opacity = +style.opacity;
  const primary_property = axis === "y" ? "height" : "width";
  const primary_property_value = parseFloat(style[primary_property]);
  const secondary_properties = axis === "y" ? ["top", "bottom"] : ["left", "right"];
  const capitalized_secondary_properties = secondary_properties.map(
    (e) => `${e[0].toUpperCase()}${e.slice(1)}`
  );
  const padding_start_value = parseFloat(style[`padding${capitalized_secondary_properties[0]}`]);
  const padding_end_value = parseFloat(style[`padding${capitalized_secondary_properties[1]}`]);
  const margin_start_value = parseFloat(style[`margin${capitalized_secondary_properties[0]}`]);
  const margin_end_value = parseFloat(style[`margin${capitalized_secondary_properties[1]}`]);
  const border_width_start_value = parseFloat(
    style[`border${capitalized_secondary_properties[0]}Width`]
  );
  const border_width_end_value = parseFloat(
    style[`border${capitalized_secondary_properties[1]}Width`]
  );
  return {
    delay,
    duration,
    easing,
    css: (t) => `overflow: hidden;opacity: ${Math.min(t * 20, 1) * opacity};${primary_property}: ${t * primary_property_value}px;padding-${secondary_properties[0]}: ${t * padding_start_value}px;padding-${secondary_properties[1]}: ${t * padding_end_value}px;margin-${secondary_properties[0]}: ${t * margin_start_value}px;margin-${secondary_properties[1]}: ${t * margin_end_value}px;border-${secondary_properties[0]}-width: ${t * border_width_start_value}px;border-${secondary_properties[1]}-width: ${t * border_width_end_value}px;`
  };
}

// src/commands/registry.ts
var COMMANDS = [
  { id: "explain_selection", title: "Explain selection", scope: "selection", delivery: "chat_only", allowStreaming: true, allowWebSearch: true },
  { id: "expand_selection", title: "Expand selection", scope: "selection", delivery: "insert_below_selection", allowStreaming: true, allowWebSearch: true },
  { id: "rewrite_selection_formal", title: "Rewrite selection (Formal)", scope: "selection", delivery: "replace_selection", allowStreaming: true, allowWebSearch: false },
  { id: "rewrite_selection_casual", title: "Rewrite selection (Casual)", scope: "selection", delivery: "replace_selection", allowStreaming: true, allowWebSearch: false },
  { id: "rewrite_selection_active_voice", title: "Rewrite selection (Active voice)", scope: "selection", delivery: "replace_selection", allowStreaming: true, allowWebSearch: false },
  { id: "rewrite_selection_bullets", title: "Rewrite selection (Bullet points)", scope: "selection", delivery: "replace_selection", allowStreaming: true, allowWebSearch: false },
  { id: "caption_selection", title: "Caption selection", scope: "selection", delivery: "insert_below_selection", allowStreaming: true, allowWebSearch: true },
  { id: "summarize_selection", title: "Summarize selection", scope: "selection", delivery: "chat_only", allowStreaming: true, allowWebSearch: true },
  { id: "full_note_discussion", title: "Discuss full note", scope: "note", delivery: "chat_only", allowStreaming: true, allowWebSearch: true },
  { id: "note_chat", title: "Chat (this note)", scope: "note", delivery: "chat_only", allowStreaming: true, allowWebSearch: true },
  { id: "vault_chat", title: "Chat (vault)", scope: "vault", delivery: "chat_only", allowStreaming: true, allowWebSearch: true },
  { id: "research_create_note", title: "Research & Create Note", scope: "vault", delivery: "chat_only", allowStreaming: true, allowWebSearch: true }
];

// src/editor/context.ts
var import_obsidian = require("obsidian");
function getEditorContext(app) {
  let activeView = app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
  if (!activeView) {
    const leaves = app.workspace.getLeavesOfType("markdown");
    if (leaves.length > 0) {
      const validLeaf = leaves.find((l) => {
        const v = l.view;
        const isMarkdown = v instanceof import_obsidian.MarkdownView || v.getViewType && v.getViewType() === "markdown";
        return isMarkdown && !!v.file;
      });
      if (validLeaf) {
        activeView = validLeaf.view;
      }
    }
  }
  if (!activeView) {
    console.warn("AI Assistant: Failed to find active MarkdownView.");
    return null;
  }
  const editor = activeView.editor;
  const file = activeView.file;
  if (!file) {
    console.warn("AI Assistant: MarkdownView found but no file associated.");
    return null;
  }
  const selection = editor.getSelection();
  const cursorFrom = editor.getCursor("from");
  const cursorTo = editor.getCursor("to");
  return {
    note: {
      path: file.path,
      title: file.basename
    },
    selection: selection ? {
      text: selection,
      from: { line: cursorFrom.line, ch: cursorFrom.ch },
      to: { line: cursorTo.line, ch: cursorTo.ch }
    } : void 0,
    fullText: editor.getValue()
  };
}

// src/commands/prompting.ts
function generateSearchQueryMessages(context, userPrompt, scope) {
  var _a, _b, _c;
  const includeNoteContext = scope !== "vault";
  return [
    {
      role: "system",
      content: "You are a Search Query Generator. Your task is to extract a single, concise web search query from the user's request and the provided context. \n\nOutput ONLY the raw query string. No quotes, no markdown, no explanations. \n\nIf the text asks for a summary, query for the main entity or topic. \nIf the text is a question, refine it for a search engine (e.g., 'who won battle of hastings' instead of 'who won it?')."
    },
    {
      role: "user",
      content: `User Prompt: ${userPrompt || "None"}

Selected Text (Context):
${includeNoteContext && ((_a = context == null ? void 0 : context.selection) == null ? void 0 : _a.text) ? context.selection.text.slice(0, 500) : "None"}

Full Note Title:
${includeNoteContext && ((_b = context == null ? void 0 : context.note) == null ? void 0 : _b.title) ? (_c = context.note) == null ? void 0 : _c.title : "None"}`
    }
  ];
}
async function buildPromptEnvelope(command, context, userPrompt, webSearchResults) {
  const includeNoteContext = command.scope !== "vault";
  return {
    command_id: command.id,
    note: includeNoteContext && (context == null ? void 0 : context.note) ? context.note : null,
    selection: includeNoteContext && (context == null ? void 0 : context.selection) ? context.selection : null,
    note_context: {
      full_text: command.scope === "note" && context ? context.fullText : null
      // Only send full text if scope requires it
    },
    user_prompt: userPrompt || null,
    constraints: {
      output_markdown: true
    },
    web_search_results: webSearchResults ? { enabled: true, ...webSearchResults } : { enabled: false }
  };
}
function createSystemMessage() {
  return `You are an assistant inside Obsidian.
Follow the user's command precisely.
If web_search_results are provided, use them as reference material. When citing sources, use standard Markdown links like [Source Title](URL) - do NOT use reference markers like [REF] tags.
Never claim you accessed anything not included in the note content, selection, chat history, or web_search_results.
Output must be valid Markdown unless the command requires another format.`;
}
function createUserMessage(envelope) {
  return `<obsidian_command>
${JSON.stringify(envelope, null, 2)}
</obsidian_command>`;
}

// src/providers/transport/httpClient.ts
var import_obsidian2 = require("obsidian");
var http = __toESM(require("http"));
var https = __toESM(require("https"));
var import_url = require("url");
var httpClient = {
  async get(url, headers = {}) {
    const res = await (0, import_obsidian2.requestUrl)({
      url,
      method: "GET",
      headers: {
        "Accept": "application/json",
        ...headers
      }
    });
    if (res.status >= 300) {
      throw new Error(`Request failed: ${res.status} ${res.text}`);
    }
    return res.json;
  },
  async post(url, body, headers = {}) {
    const res = await (0, import_obsidian2.requestUrl)({
      url,
      method: "POST",
      body: JSON.stringify(body),
      headers: {
        "Content-Type": "application/json",
        ...headers
      }
    });
    if (res.status >= 300) {
      throw new Error(`Request failed: ${res.status} ${res.text}`);
    }
    return res.json;
  },
  async stream(url, body, headers, onChunk, signal) {
    return new Promise((resolve, reject) => {
      const parsedUrl = new import_url.URL(url);
      const lib = parsedUrl.protocol === "https:" ? https : http;
      const opts = {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          ...headers
        }
      };
      const req = lib.request(parsedUrl, opts, (res) => {
        if (res.statusCode && res.statusCode >= 300) {
          let errBody = "";
          res.on("data", (c) => errBody += c);
          res.on("end", () => reject(new Error(`Stream failed: ${res.statusCode} ${errBody}`)));
          return;
        }
        res.setEncoding("utf8");
        res.on("data", (chunk) => {
          if (signal == null ? void 0 : signal.aborted) {
            res.destroy();
            return;
          }
          onChunk(chunk);
        });
        res.on("end", () => resolve());
        res.on("error", (err) => reject(err));
      });
      req.setTimeout(2e4, () => {
        req.destroy(new Error("Connection timed out"));
      });
      req.on("error", (err) => reject(err));
      req.write(JSON.stringify(body));
      req.end();
      if (signal) {
        signal.addEventListener("abort", () => {
          req.destroy();
          reject(new Error("Aborted"));
        });
      }
    });
  }
};

// src/providers/transport/ndjsonParser.ts
function createNdjsonParser(onEvent) {
  let buffer = "";
  return (chunk) => {
    buffer += chunk;
    const lines = buffer.split("\n");
    buffer = lines.pop() || "";
    for (const line of lines) {
      if (!line.trim()) continue;
      try {
        const data = JSON.parse(line);
        if (data.done) {
          onEvent({ type: "done" });
          return;
        }
        if (data.message && data.message.content) {
          onEvent({ type: "token", value: data.message.content });
        } else if (data.response) {
          onEvent({ type: "token", value: data.response });
        }
      } catch (err) {
        console.error("NDJSON parse error", err, line);
      }
    }
  };
}

// src/providers/ollama.ts
var OllamaClient = class {
  constructor(baseUrl) {
    this.kind = "ollama";
    this.baseUrl = baseUrl.replace(/\/+$/, "");
  }
  async listModels() {
    const url = `${this.baseUrl}/api/tags`;
    const res = await httpClient.get(url);
    const models = res.models || [];
    return models.map((m) => ({
      id: m.name,
      label: m.name,
      details: m
    }));
  }
  async chat(req, onEvent, abortSignal) {
    var _a;
    const url = `${this.baseUrl}/api/chat`;
    const body = {
      model: req.model,
      messages: req.messages,
      stream: req.stream,
      options: {
        temperature: req.temperature
      }
    };
    if (req.stream) {
      const parser = createNdjsonParser(onEvent);
      await httpClient.stream(url, body, {}, parser, abortSignal);
      return { content: "" };
    } else {
      const res = await httpClient.post(url, body);
      const content = ((_a = res.message) == null ? void 0 : _a.content) || "";
      return { content, raw: res };
    }
  }
};

// src/providers/transport/sseParser.ts
function createSseParser(onEvent) {
  let buffer = "";
  return (chunk) => {
    var _a, _b, _c;
    buffer += chunk;
    const lines = buffer.split("\n");
    buffer = lines.pop() || "";
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed.startsWith("data:")) continue;
      const dataStr = trimmed.slice(5).trim();
      if (dataStr === "[DONE]") {
        onEvent({ type: "done" });
        continue;
      }
      try {
        const data = JSON.parse(dataStr);
        const delta = (_c = (_b = (_a = data.choices) == null ? void 0 : _a[0]) == null ? void 0 : _b.delta) == null ? void 0 : _c.content;
        if (delta) {
          onEvent({ type: "token", value: delta });
        }
      } catch (err) {
      }
    }
  };
}

// src/providers/openai_compatible.ts
var OpenAICompatibleClient = class {
  constructor(baseUrl, apiKey) {
    this.kind = "openai_compatible";
    let url = baseUrl.replace(/\/+$/, "");
    if (url.endsWith("/v1")) {
      url = url.substring(0, url.length - 3);
    }
    this.baseUrl = url;
    this.apiKey = apiKey || "";
  }
  getHeaders() {
    const headers = {
      "Authorization": `Bearer ${this.apiKey}`
    };
    return headers;
  }
  async listModels() {
    const url = `${this.baseUrl}/v1/models`;
    try {
      const res = await httpClient.get(url, this.getHeaders());
      const data = res.data || [];
      return data.map((m) => ({
        id: m.id,
        label: m.id,
        details: m
      }));
    } catch (err) {
      console.warn("Failed to fetch models from openai compatible endpoint", err);
      return [];
    }
  }
  async chat(req, onEvent, abortSignal) {
    var _a, _b, _c;
    const url = `${this.baseUrl}/v1/chat/completions`;
    const body = {
      model: req.model,
      temperature: req.temperature,
      stream: req.stream,
      messages: req.messages
      // Note: Spec 7.3 says web snippets are injected into messages.
      // The req.messages passed here are already prepared by the caller (Prompting layer).
    };
    const headers = this.getHeaders();
    if (req.stream) {
      const parser = createSseParser(onEvent);
      await httpClient.stream(url, body, headers, parser, abortSignal);
      return { content: "" };
    } else {
      const res = await httpClient.post(url, body, headers);
      const content = ((_c = (_b = (_a = res.choices) == null ? void 0 : _a[0]) == null ? void 0 : _b.message) == null ? void 0 : _c.content) || "";
      return { content, raw: res };
    }
  }
};

// src/providers/index.ts
function createProviderClient(provider, settings) {
  if (provider === "ollama") {
    const ollamaSettings = settings;
    return new OllamaClient(ollamaSettings.baseUrl);
  } else {
    const openaiSettings = settings;
    return new OpenAICompatibleClient(openaiSettings.baseUrl, openaiSettings.apiKey);
  }
}

// src/websearch/searxng.ts
var import_obsidian3 = require("obsidian");
async function runSearxngSearch(query, settings) {
  const url = settings.urlTemplate.replace("%s", encodeURIComponent(query));
  try {
    const res = await (0, import_obsidian3.requestUrl)({
      url,
      method: "GET",
      // Spec 7.1: format=json implied in urlTemplate or params
      // user responsible for urlTemplate including format=json if they deviate from default
      headers: {
        "Accept": "application/json"
      }
    });
    if (res.status >= 300) {
      throw new Error(`Search failed: ${res.status}`);
    }
    const data = res.json;
    if (!data.results || !Array.isArray(data.results)) {
      throw new Error("Invalid search response: missing results array");
    }
    const rawResults = data.results.slice(0, settings.maxResults);
    const results = rawResults.map((item) => ({
      title: item.title || "No title",
      url: item.url || item.link || "",
      // 'link' is common in some APIs, 'url' in others. SearXNG uses 'url'.
      content: stripHtml(item.content || item.snippet || ""),
      // Spec 7.2: strip tags
      engine: item.engine,
      score: item.score
    }));
    return {
      query,
      results
    };
  } catch (err) {
    console.error("Web search error", err);
    throw err;
  }
}
function stripHtml(html) {
  return html.replace(/<[^>]*>?/gm, "");
}

// src/ui/commandPicker.ts
var import_obsidian4 = require("obsidian");
var CommandPickerModal = class extends import_obsidian4.FuzzySuggestModal {
  constructor(plugin, onChoose) {
    super(plugin.app);
    this.plugin = plugin;
    this.onChoose = onChoose;
    this.setPlaceholder("Search for a command...");
  }
  getItems() {
    return [...COMMANDS];
  }
  getItemText(command) {
    return `${command.title} ${command.scope}`;
  }
  onChooseItem(command, evt) {
    this.onChoose(command.id);
  }
};

// src/ui/svelte/ChatView.svelte
var import_obsidian5 = require("obsidian");
function add_css(target) {
  append_styles(target, "svelte-1gx429z", "textarea.svelte-1gx429z{field-sizing:content}");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[28] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[31] = list[i];
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[34] = list[i];
  child_ctx[36] = i;
  return child_ctx;
}
function create_if_block_9(ctx) {
  let div3;
  let div2;
  let div1;
  let div0;
  let markdown_action;
  let t;
  let div2_class_value;
  let div3_class_value;
  let div3_transition;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*message*/
    ctx[34].role === "assistant" && create_if_block_10(ctx)
  );
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      t = space();
      if (if_block) if_block.c();
      attr(div0, "class", "markdown-preview select-text helper-render");
      attr(div1, "class", "prose prose-sm prose-invert max-w-none break-words");
      attr(div2, "class", div2_class_value = "group relative max-w-[85%] rounded-2xl px-4 py-3 text-sm " + /*message*/
      (ctx[34].role === "user" ? "bg-primary text-primary-foreground rounded-br-sm" : "bg-muted/50 rounded-bl-sm"));
      attr(div3, "class", div3_class_value = "flex w-full " + /*message*/
      (ctx[34].role === "user" ? "justify-end" : "justify-start"));
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div1);
      append(div1, div0);
      append(div2, t);
      if (if_block) if_block.m(div2, null);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(markdown_action = /*markdown*/
        ctx[19].call(
          null,
          div0,
          /*message*/
          ctx[34].role === "assistant" ? (
            /*cleanAssistantMessage*/
            ctx[18](
              /*message*/
              ctx[34].content
            )
          ) : (
            /*message*/
            ctx[34].content
          )
        ));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (markdown_action && is_function(markdown_action.update) && dirty[0] & /*messages*/
      2) markdown_action.update.call(
        null,
        /*message*/
        ctx[34].role === "assistant" ? (
          /*cleanAssistantMessage*/
          ctx[18](
            /*message*/
            ctx[34].content
          )
        ) : (
          /*message*/
          ctx[34].content
        )
      );
      if (
        /*message*/
        ctx[34].role === "assistant"
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_10(ctx);
          if_block.c();
          if_block.m(div2, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty[0] & /*messages*/
      2 && div2_class_value !== (div2_class_value = "group relative max-w-[85%] rounded-2xl px-4 py-3 text-sm " + /*message*/
      (ctx[34].role === "user" ? "bg-primary text-primary-foreground rounded-br-sm" : "bg-muted/50 rounded-bl-sm"))) {
        attr(div2, "class", div2_class_value);
      }
      if (!current || dirty[0] & /*messages*/
      2 && div3_class_value !== (div3_class_value = "flex w-full " + /*message*/
      (ctx[34].role === "user" ? "justify-end" : "justify-start"))) {
        attr(div3, "class", div3_class_value);
      }
    },
    i(local) {
      if (current) return;
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (!div3_transition) div3_transition = create_bidirectional_transition(div3, fade, { duration: 150 }, true);
          div3_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      if (local) {
        if (!div3_transition) div3_transition = create_bidirectional_transition(div3, fade, { duration: 150 }, false);
        div3_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      if (if_block) if_block.d();
      if (detaching && div3_transition) div3_transition.end();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_10(ctx) {
  var _a;
  let div;
  let button;
  let button_class_value;
  let button_title_value;
  let t0;
  let t1;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*copiedMessageIndex*/
      ctx2[8] === /*index*/
      ctx2[36]
    ) return create_if_block_15;
    return create_else_block_5;
  }
  let current_block_type = select_block_type(ctx, [-1, -1]);
  let if_block0 = current_block_type(ctx);
  function click_handler() {
    return (
      /*click_handler*/
      ctx[22](
        /*message*/
        ctx[34],
        /*index*/
        ctx[36]
      )
    );
  }
  let if_block1 = (
    /*message*/
    ((_a = ctx[34].context) == null ? void 0 : _a.selection) && create_if_block_13(ctx)
  );
  let if_block2 = (
    /*activeCommandId*/
    ctx[3] === "research_create_note" && create_if_block_11(ctx)
  );
  return {
    c() {
      div = element("div");
      button = element("button");
      if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      if (if_block2) if_block2.c();
      attr(button, "class", button_class_value = "p-1.5 rounded-md hover:bg-background/20 transition-colors " + /*copiedMessageIndex*/
      (ctx[8] === /*index*/
      ctx[36] ? "text-primary" : "text-muted-foreground hover:text-foreground"));
      attr(button, "title", button_title_value = /*copiedMessageIndex*/
      ctx[8] === /*index*/
      ctx[36] ? "Copied!" : "Copy to clipboard");
      attr(div, "class", "mt-2 pt-2 border-t border-border/50 flex items-center justify-end gap-1 opacity-0 group-hover:opacity-100 transition-opacity");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      if_block0.m(button, null);
      append(div, t0);
      if (if_block1) if_block1.m(div, null);
      append(div, t1);
      if (if_block2) if_block2.m(div, null);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      var _a2;
      ctx = new_ctx;
      if (current_block_type !== (current_block_type = select_block_type(ctx, dirty))) {
        if_block0.d(1);
        if_block0 = current_block_type(ctx);
        if (if_block0) {
          if_block0.c();
          if_block0.m(button, null);
        }
      }
      if (dirty[0] & /*copiedMessageIndex*/
      256 && button_class_value !== (button_class_value = "p-1.5 rounded-md hover:bg-background/20 transition-colors " + /*copiedMessageIndex*/
      (ctx[8] === /*index*/
      ctx[36] ? "text-primary" : "text-muted-foreground hover:text-foreground"))) {
        attr(button, "class", button_class_value);
      }
      if (dirty[0] & /*copiedMessageIndex*/
      256 && button_title_value !== (button_title_value = /*copiedMessageIndex*/
      ctx[8] === /*index*/
      ctx[36] ? "Copied!" : "Copy to clipboard")) {
        attr(button, "title", button_title_value);
      }
      if (
        /*message*/
        (_a2 = ctx[34].context) == null ? void 0 : _a2.selection
      ) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block_13(ctx);
          if_block1.c();
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*activeCommandId*/
        ctx[3] === "research_create_note"
      ) {
        if (if_block2) {
          if_block2.p(ctx, dirty);
        } else {
          if_block2 = create_if_block_11(ctx);
          if_block2.c();
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_block0.d();
      if (if_block1) if_block1.d();
      if (if_block2) if_block2.d();
      mounted = false;
      dispose();
    }
  };
}
function create_else_block_5(ctx) {
  let svg;
  let rect;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      path = svg_element("path");
      attr(rect, "width", "14");
      attr(rect, "height", "14");
      attr(rect, "x", "8");
      attr(rect, "y", "8");
      attr(rect, "rx", "2");
      attr(rect, "ry", "2");
      attr(path, "d", "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "14");
      attr(svg, "height", "14");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, rect);
      append(svg, path);
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_if_block_15(ctx) {
  let svg;
  let polyline;
  return {
    c() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      attr(polyline, "points", "20 6 9 17 4 12");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "14");
      attr(svg, "height", "14");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, polyline);
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_if_block_13(ctx) {
  let button;
  let button_class_value;
  let button_title_value;
  let mounted;
  let dispose;
  function select_block_type_1(ctx2, dirty) {
    if (
      /*replacedMessageIndex*/
      ctx2[9] === /*index*/
      ctx2[36]
    ) return create_if_block_14;
    return create_else_block_4;
  }
  let current_block_type = select_block_type_1(ctx, [-1, -1]);
  let if_block = current_block_type(ctx);
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[23](
        /*message*/
        ctx[34],
        /*index*/
        ctx[36]
      )
    );
  }
  return {
    c() {
      button = element("button");
      if_block.c();
      attr(button, "class", button_class_value = "p-1.5 rounded-md hover:bg-background/20 transition-colors " + /*replacedMessageIndex*/
      (ctx[9] === /*index*/
      ctx[36] ? "text-primary" : "text-muted-foreground hover:text-foreground"));
      attr(button, "title", button_title_value = /*replacedMessageIndex*/
      ctx[9] === /*index*/
      ctx[36] ? "Replaced!" : "Replace selection with this text");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if_block.m(button, null);
      if (!mounted) {
        dispose = listen(button, "click", click_handler_1);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (current_block_type !== (current_block_type = select_block_type_1(ctx, dirty))) {
        if_block.d(1);
        if_block = current_block_type(ctx);
        if (if_block) {
          if_block.c();
          if_block.m(button, null);
        }
      }
      if (dirty[0] & /*replacedMessageIndex*/
      512 && button_class_value !== (button_class_value = "p-1.5 rounded-md hover:bg-background/20 transition-colors " + /*replacedMessageIndex*/
      (ctx[9] === /*index*/
      ctx[36] ? "text-primary" : "text-muted-foreground hover:text-foreground"))) {
        attr(button, "class", button_class_value);
      }
      if (dirty[0] & /*replacedMessageIndex*/
      512 && button_title_value !== (button_title_value = /*replacedMessageIndex*/
      ctx[9] === /*index*/
      ctx[36] ? "Replaced!" : "Replace selection with this text")) {
        attr(button, "title", button_title_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_else_block_4(ctx) {
  let svg;
  let path;
  let polygon;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      polygon = svg_element("polygon");
      attr(path, "d", "M20 14.66V20a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h5.34");
      attr(polygon, "points", "18 2 22 6 12 16 8 16 8 12 18 2");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "14");
      attr(svg, "height", "14");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
      append(svg, polygon);
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_if_block_14(ctx) {
  let svg;
  let polyline;
  return {
    c() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      attr(polyline, "points", "20 6 9 17 4 12");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "14");
      attr(svg, "height", "14");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, polyline);
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_if_block_11(ctx) {
  let button;
  let button_class_value;
  let button_title_value;
  let mounted;
  let dispose;
  function select_block_type_2(ctx2, dirty) {
    if (
      /*createdNoteIndex*/
      ctx2[10] === /*index*/
      ctx2[36]
    ) return create_if_block_12;
    return create_else_block_3;
  }
  let current_block_type = select_block_type_2(ctx, [-1, -1]);
  let if_block = current_block_type(ctx);
  function click_handler_2() {
    return (
      /*click_handler_2*/
      ctx[24](
        /*message*/
        ctx[34],
        /*index*/
        ctx[36]
      )
    );
  }
  return {
    c() {
      button = element("button");
      if_block.c();
      attr(button, "class", button_class_value = "p-1.5 rounded-md hover:bg-background/20 transition-colors " + /*createdNoteIndex*/
      (ctx[10] === /*index*/
      ctx[36] ? "text-primary" : "text-muted-foreground hover:text-foreground"));
      attr(button, "title", button_title_value = /*createdNoteIndex*/
      ctx[10] === /*index*/
      ctx[36] ? "Note created!" : "Create note from this response");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if_block.m(button, null);
      if (!mounted) {
        dispose = listen(button, "click", click_handler_2);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (current_block_type !== (current_block_type = select_block_type_2(ctx, dirty))) {
        if_block.d(1);
        if_block = current_block_type(ctx);
        if (if_block) {
          if_block.c();
          if_block.m(button, null);
        }
      }
      if (dirty[0] & /*createdNoteIndex*/
      1024 && button_class_value !== (button_class_value = "p-1.5 rounded-md hover:bg-background/20 transition-colors " + /*createdNoteIndex*/
      (ctx[10] === /*index*/
      ctx[36] ? "text-primary" : "text-muted-foreground hover:text-foreground"))) {
        attr(button, "class", button_class_value);
      }
      if (dirty[0] & /*createdNoteIndex*/
      1024 && button_title_value !== (button_title_value = /*createdNoteIndex*/
      ctx[10] === /*index*/
      ctx[36] ? "Note created!" : "Create note from this response")) {
        attr(button, "title", button_title_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_else_block_3(ctx) {
  let svg;
  let path;
  let polyline;
  let line0;
  let line1;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      polyline = svg_element("polyline");
      line0 = svg_element("line");
      line1 = svg_element("line");
      attr(path, "d", "M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z");
      attr(polyline, "points", "14 2 14 8 20 8");
      attr(line0, "x1", "12");
      attr(line0, "y1", "18");
      attr(line0, "x2", "12");
      attr(line0, "y2", "12");
      attr(line1, "x1", "9");
      attr(line1, "y1", "15");
      attr(line1, "x2", "15");
      attr(line1, "y2", "15");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "14");
      attr(svg, "height", "14");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
      append(svg, polyline);
      append(svg, line0);
      append(svg, line1);
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_if_block_12(ctx) {
  let svg;
  let polyline;
  return {
    c() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      attr(polyline, "points", "20 6 9 17 4 12");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "14");
      attr(svg, "height", "14");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, polyline);
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_each_block_2(ctx) {
  let show_if = !/*message*/
  ctx[34].content.trim().startsWith("<obsidian_command>");
  let if_block_anchor;
  let if_block = show_if && create_if_block_9(ctx);
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*messages*/
      2) show_if = !/*message*/
      ctx2[34].content.trim().startsWith("<obsidian_command>");
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*messages*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_9(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function create_if_block_3(ctx) {
  let div2;
  let div1;
  let div0;
  let t0;
  let t1;
  let div2_transition;
  let current;
  function select_block_type_3(ctx2, dirty) {
    if (
      /*status*/
      ctx2[2] === "searching"
    ) return create_if_block_8;
    return create_else_block_2;
  }
  let current_block_type = select_block_type_3(ctx, [-1, -1]);
  let if_block0 = current_block_type(ctx);
  let if_block1 = (
    /*searchQueries*/
    ctx[6] && /*searchQueries*/
    ctx[6].length > 0 && create_if_block_7(ctx)
  );
  let if_block2 = (
    /*webSearchResults*/
    ctx[7] && /*webSearchResults*/
    ctx[7].results.length > 0 && create_if_block_4(ctx)
  );
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      if (if_block2) if_block2.c();
      attr(div0, "class", "flex items-center gap-2 mb-2");
      attr(div1, "class", "max-w-[90%] rounded-2xl rounded-tl-sm px-4 py-3 bg-muted/30 text-xs border border-border/40");
      attr(div2, "class", "flex w-full justify-start");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      if_block0.m(div0, null);
      append(div1, t0);
      if (if_block1) if_block1.m(div1, null);
      append(div1, t1);
      if (if_block2) if_block2.m(div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_3(ctx2, dirty)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div0, null);
        }
      }
      if (
        /*searchQueries*/
        ctx2[6] && /*searchQueries*/
        ctx2[6].length > 0
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_7(ctx2);
          if_block1.c();
          if_block1.m(div1, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*webSearchResults*/
        ctx2[7] && /*webSearchResults*/
        ctx2[7].results.length > 0
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_4(ctx2);
          if_block2.c();
          if_block2.m(div1, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    i(local) {
      if (current) return;
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (!div2_transition) div2_transition = create_bidirectional_transition(div2, fade, {}, true);
          div2_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      if (local) {
        if (!div2_transition) div2_transition = create_bidirectional_transition(div2, fade, {}, false);
        div2_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if_block0.d();
      if (if_block1) if_block1.d();
      if (if_block2) if_block2.d();
      if (detaching && div2_transition) div2_transition.end();
    }
  };
}
function create_else_block_2(ctx) {
  let svg;
  let path;
  let polyline;
  let t0;
  let span;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      polyline = svg_element("polyline");
      t0 = space();
      span = element("span");
      span.textContent = "Sources";
      attr(path, "d", "M22 11.08V12a10 10 0 1 1-5.93-9.14");
      attr(polyline, "points", "22 4 12 14.01 9 11.01");
      attr(svg, "class", "h-3.5 w-3.5 text-primary");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
      attr(span, "class", "text-muted-foreground font-medium");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
      append(svg, polyline);
      insert(target, t0, anchor);
      insert(target, span, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(svg);
        detach(t0);
        detach(span);
      }
    }
  };
}
function create_if_block_8(ctx) {
  let svg;
  let circle;
  let path;
  let t0;
  let span;
  let t1_value = (
    /*searchStatus*/
    (ctx[5] || "Searching...") + ""
  );
  let t1;
  return {
    c() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      path = svg_element("path");
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      attr(circle, "class", "opacity-25");
      attr(circle, "cx", "12");
      attr(circle, "cy", "12");
      attr(circle, "r", "10");
      attr(circle, "stroke", "currentColor");
      attr(circle, "stroke-width", "4");
      attr(path, "class", "opacity-75");
      attr(path, "fill", "currentColor");
      attr(path, "d", "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z");
      attr(svg, "class", "animate-spin h-3.5 w-3.5 text-primary");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(span, "class", "text-muted-foreground font-medium");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, circle);
      append(svg, path);
      insert(target, t0, anchor);
      insert(target, span, anchor);
      append(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*searchStatus*/
      32 && t1_value !== (t1_value = /*searchStatus*/
      (ctx2[5] || "Searching...") + "")) set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
        detach(t0);
        detach(span);
      }
    }
  };
}
function create_if_block_7(ctx) {
  let div;
  let each_value_1 = ensure_array_like(
    /*searchQueries*/
    ctx[6]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "flex flex-wrap gap-1.5 mb-3");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*searchQueries*/
      64) {
        each_value_1 = ensure_array_like(
          /*searchQueries*/
          ctx2[6]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_1(ctx) {
  let div;
  let svg;
  let circle;
  let path;
  let t0;
  let span;
  let t1_value = (
    /*query*/
    ctx[31] + ""
  );
  let t1;
  let t2;
  return {
    c() {
      div = element("div");
      svg = svg_element("svg");
      circle = svg_element("circle");
      path = svg_element("path");
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      t2 = space();
      attr(circle, "cx", "11");
      attr(circle, "cy", "11");
      attr(circle, "r", "8");
      attr(path, "d", "m21 21-4.3-4.3");
      attr(svg, "class", "w-3 h-3 opacity-50");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "2");
      attr(span, "class", "truncate max-w-[150px]");
      attr(div, "class", "inline-flex items-center gap-1 px-2 py-0.5 rounded-full bg-background border border-border/50 text-[10px] text-muted-foreground");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, svg);
      append(svg, circle);
      append(svg, path);
      append(div, t0);
      append(div, span);
      append(span, t1);
      append(div, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*searchQueries*/
      64 && t1_value !== (t1_value = /*query*/
      ctx2[31] + "")) set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block_4(ctx) {
  let div1;
  let div0;
  let t;
  let each_value = ensure_array_like(
    /*webSearchResults*/
    ctx[7].results.slice(0, 5)
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  let if_block = (
    /*webSearchResults*/
    ctx[7].results.length > 5 && create_if_block_5(ctx)
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      if (if_block) if_block.c();
      attr(div0, "class", "flex flex-wrap gap-2");
      attr(div1, "class", "space-y-2 pt-1");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      append(div0, t);
      if (if_block) if_block.m(div0, null);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*webSearchResults*/
      128) {
        each_value = ensure_array_like(
          /*webSearchResults*/
          ctx2[7].results.slice(0, 5)
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div0, t);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (
        /*webSearchResults*/
        ctx2[7].results.length > 5
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_5(ctx2);
          if_block.c();
          if_block.m(div0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_each(each_blocks, detaching);
      if (if_block) if_block.d();
    }
  };
}
function create_else_block_1(ctx) {
  let svg;
  let circle;
  let line;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      line = svg_element("line");
      path = svg_element("path");
      attr(circle, "cx", "12");
      attr(circle, "cy", "12");
      attr(circle, "r", "10");
      attr(line, "x1", "2");
      attr(line, "y1", "12");
      attr(line, "x2", "22");
      attr(line, "y2", "12");
      attr(path, "d", "M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z");
      attr(svg, "class", "w-3.5 h-3.5");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "2");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, circle);
      append(svg, line);
      append(svg, path);
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_if_block_6(ctx) {
  let svg;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "d", "M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z");
      attr(svg, "class", "w-3.5 h-3.5");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "currentColor");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_each_block(ctx) {
  let a;
  let div;
  let show_if;
  let t0;
  let span;
  let t1_value = (
    /*result*/
    ctx[28].title + ""
  );
  let t1;
  let a_href_value;
  function select_block_type_4(ctx2, dirty) {
    if (dirty[0] & /*webSearchResults*/
    128) show_if = null;
    if (show_if == null) show_if = !!/*result*/
    ctx2[28].url.includes("github.com");
    if (show_if) return create_if_block_6;
    return create_else_block_1;
  }
  let current_block_type = select_block_type_4(ctx, [-1, -1]);
  let if_block = current_block_type(ctx);
  return {
    c() {
      a = element("a");
      div = element("div");
      if_block.c();
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      attr(div, "class", "shrink-0 text-muted-foreground/70 group-hover:text-primary transition-colors");
      attr(span, "class", "text-xs font-medium text-foreground truncate group-hover:text-primary transition-colors max-w-[150px]");
      attr(a, "href", a_href_value = /*result*/
      ctx[28].url);
      attr(a, "target", "_blank");
      attr(a, "rel", "noopener noreferrer");
      attr(a, "class", "inline-flex items-center gap-1.5 px-3 py-1.5 rounded-full bg-background hover:bg-muted/50 border border-border/50 hover:border-primary/30 transition-all no-underline group max-w-full shadow-sm");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, div);
      if_block.m(div, null);
      append(a, t0);
      append(a, span);
      append(span, t1);
    },
    p(ctx2, dirty) {
      if (current_block_type !== (current_block_type = select_block_type_4(ctx2, dirty))) {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
      if (dirty[0] & /*webSearchResults*/
      128 && t1_value !== (t1_value = /*result*/
      ctx2[28].title + "")) set_data(t1, t1_value);
      if (dirty[0] & /*webSearchResults*/
      128 && a_href_value !== (a_href_value = /*result*/
      ctx2[28].url)) {
        attr(a, "href", a_href_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(a);
      }
      if_block.d();
    }
  };
}
function create_if_block_5(ctx) {
  let span;
  let t0;
  let t1_value = (
    /*webSearchResults*/
    ctx[7].results.length - 5 + ""
  );
  let t1;
  let t2;
  return {
    c() {
      span = element("span");
      t0 = text("+");
      t1 = text(t1_value);
      t2 = text(" more");
      attr(span, "class", "text-[10px] text-muted-foreground self-center px-1");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*webSearchResults*/
      128 && t1_value !== (t1_value = /*webSearchResults*/
      ctx2[7].results.length - 5 + "")) set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_1(ctx) {
  let div1;
  let div0;
  let div1_transition;
  let current;
  function select_block_type_5(ctx2, dirty) {
    if (
      /*displayResponse*/
      ctx2[11]
    ) return create_if_block_2;
    return create_else_block;
  }
  let current_block_type = select_block_type_5(ctx, [-1, -1]);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if_block.c();
      attr(div0, "class", "max-w-[85%] rounded-2xl rounded-bl-sm px-4 py-3 bg-muted/50 text-sm");
      attr(div1, "class", "flex w-full justify-start");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if_block.m(div0, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_5(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div0, null);
        }
      }
    },
    i(local) {
      if (current) return;
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (!div1_transition) div1_transition = create_bidirectional_transition(div1, fade, {}, true);
          div1_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      if (local) {
        if (!div1_transition) div1_transition = create_bidirectional_transition(div1, fade, {}, false);
        div1_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if_block.d();
      if (detaching && div1_transition) div1_transition.end();
    }
  };
}
function create_else_block(ctx) {
  let div;
  let svg;
  let circle;
  let path;
  let t0;
  let span;
  let t1_value = (
    /*status*/
    ctx[2] === "sending" ? "Preparing..." : "Generating..."
  );
  let t1;
  return {
    c() {
      div = element("div");
      svg = svg_element("svg");
      circle = svg_element("circle");
      path = svg_element("path");
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      attr(circle, "class", "opacity-25");
      attr(circle, "cx", "12");
      attr(circle, "cy", "12");
      attr(circle, "r", "10");
      attr(circle, "stroke", "currentColor");
      attr(circle, "stroke-width", "4");
      attr(path, "class", "opacity-75");
      attr(path, "fill", "currentColor");
      attr(path, "d", "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z");
      attr(svg, "class", "animate-spin h-4 w-4 text-primary");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(span, "class", "text-muted-foreground text-xs");
      attr(div, "class", "flex items-center gap-2 h-6");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, svg);
      append(svg, circle);
      append(svg, path);
      append(div, t0);
      append(div, span);
      append(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*status*/
      4 && t1_value !== (t1_value = /*status*/
      ctx2[2] === "sending" ? "Preparing..." : "Generating...")) set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block_2(ctx) {
  let div1;
  let div0;
  let markdown_action;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      attr(div0, "class", "markdown-preview select-text helper-render");
      attr(div1, "class", "prose prose-sm prose-invert max-w-none break-words");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (!mounted) {
        dispose = action_destroyer(markdown_action = /*markdown*/
        ctx[19].call(
          null,
          div0,
          /*displayResponse*/
          ctx[11]
        ));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (markdown_action && is_function(markdown_action.update) && dirty[0] & /*displayResponse*/
      2048) markdown_action.update.call(
        null,
        /*displayResponse*/
        ctx2[11]
      );
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<svg class="w-4 h-4 text-primary" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>`;
      attr(div, "class", "absolute inset-0 flex items-center justify-center");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment(ctx) {
  let div5;
  let div0;
  let t0;
  let t1;
  let t2;
  let div4;
  let div2;
  let textarea;
  let textarea_disabled_value;
  let t3;
  let button0;
  let div1;
  let svg0;
  let circle;
  let path0;
  let path1;
  let svg0_class_value;
  let t4;
  let button0_class_value;
  let button0_title_value;
  let t5;
  let button1;
  let svg1;
  let path2;
  let path3;
  let button1_disabled_value;
  let t6;
  let div3;
  let mounted;
  let dispose;
  let each_value_2 = ensure_array_like(
    /*messages*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  let if_block0 = (
    /*status*/
    (ctx[2] === "searching" || /*webSearchResults*/
    ctx[7] && /*webSearchResults*/
    ctx[7].results.length > 0) && create_if_block_3(ctx)
  );
  let if_block1 = (
    /*status*/
    (ctx[2] === "streaming" || /*status*/
    ctx[2] === "sending") && create_if_block_1(ctx)
  );
  let if_block2 = (
    /*webSearchEnabled*/
    ctx[4] && create_if_block(ctx)
  );
  return {
    c() {
      div5 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      div4 = element("div");
      div2 = element("div");
      textarea = element("textarea");
      t3 = space();
      button0 = element("button");
      div1 = element("div");
      svg0 = svg_element("svg");
      circle = svg_element("circle");
      path0 = svg_element("path");
      path1 = svg_element("path");
      t4 = space();
      if (if_block2) if_block2.c();
      t5 = space();
      button1 = element("button");
      svg1 = svg_element("svg");
      path2 = svg_element("path");
      path3 = svg_element("path");
      t6 = space();
      div3 = element("div");
      div3.textContent = "Press Enter to send, Shift+Enter for new line";
      attr(div0, "class", "flex-1 overflow-y-auto p-4 space-y-4");
      attr(textarea, "placeholder", "Message AI...");
      attr(textarea, "rows", "1");
      attr(textarea, "class", "flex-1 min-h-[44px] max-h-32 resize-none bg-transparent px-3 py-2.5 text-sm placeholder:text-muted-foreground/70 focus:outline-none scrollbar-hide svelte-1gx429z");
      textarea.disabled = textarea_disabled_value = /*status*/
      ctx[2] === "streaming";
      attr(circle, "cx", "12");
      attr(circle, "cy", "12");
      attr(circle, "r", "10");
      attr(path0, "d", "M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20");
      attr(path1, "d", "M2 12h20");
      attr(svg0, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg0, "width", "18");
      attr(svg0, "height", "18");
      attr(svg0, "viewBox", "0 0 24 24");
      attr(svg0, "fill", "none");
      attr(svg0, "stroke", "currentColor");
      attr(svg0, "stroke-width", "2");
      attr(svg0, "stroke-linecap", "round");
      attr(svg0, "stroke-linejoin", "round");
      attr(svg0, "class", svg0_class_value = /*webSearchEnabled*/
      ctx[4] ? "opacity-20" : "");
      attr(div1, "class", "relative");
      attr(button0, "class", button0_class_value = "relative mb-0.5 inline-flex h-9 w-9 items-center justify-center rounded-lg transition-all hover:bg-muted " + /*webSearchEnabled*/
      (ctx[4] ? "text-primary bg-primary/10" : "text-muted-foreground/50"));
      attr(button0, "title", button0_title_value = /*webSearchEnabled*/
      ctx[4] ? "Disable Web Search" : "Enable Web Search");
      attr(path2, "d", "m22 2-7 20-4-9-9-4Z");
      attr(path3, "d", "M22 2 11 13");
      attr(svg1, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg1, "width", "16");
      attr(svg1, "height", "16");
      attr(svg1, "viewBox", "0 0 24 24");
      attr(svg1, "fill", "none");
      attr(svg1, "stroke", "currentColor");
      attr(svg1, "stroke-width", "2");
      attr(svg1, "stroke-linecap", "round");
      attr(svg1, "stroke-linejoin", "round");
      button1.disabled = button1_disabled_value = !/*userPrompt*/
      ctx[0].trim() || /*status*/
      ctx[2] === "streaming";
      attr(button1, "class", "mb-0.5 inline-flex h-9 w-9 items-center justify-center rounded-lg bg-primary text-primary-foreground transition-all hover:bg-primary/90 disabled:opacity-0 disabled:scale-95");
      attr(div2, "class", "relative flex items-end gap-2 p-1.5 rounded-xl border border-input focus-within:ring-2 focus-within:ring-ring/20 bg-muted/30 transition-all duration-200");
      attr(div3, "class", "px-1 py-1 text-xs text-muted-foreground/50 text-center");
      attr(div4, "class", "p-4 bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60");
      attr(div5, "class", "h-full flex flex-col");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      append(div0, t0);
      if (if_block0) if_block0.m(div0, null);
      append(div0, t1);
      if (if_block1) if_block1.m(div0, null);
      append(div5, t2);
      append(div5, div4);
      append(div4, div2);
      append(div2, textarea);
      set_input_value(
        textarea,
        /*userPrompt*/
        ctx[0]
      );
      append(div2, t3);
      append(div2, button0);
      append(button0, div1);
      append(div1, svg0);
      append(svg0, circle);
      append(svg0, path0);
      append(svg0, path1);
      append(div1, t4);
      if (if_block2) if_block2.m(div1, null);
      append(div2, t5);
      append(div2, button1);
      append(button1, svg1);
      append(svg1, path2);
      append(svg1, path3);
      append(div4, t6);
      append(div4, div3);
      if (!mounted) {
        dispose = [
          listen(
            textarea,
            "input",
            /*textarea_input_handler*/
            ctx[25]
          ),
          listen(
            textarea,
            "keydown",
            /*handleKeyDown*/
            ctx[12]
          ),
          listen(
            button0,
            "click",
            /*toggleWebSearch*/
            ctx[14]
          ),
          listen(
            button1,
            "click",
            /*handleSend*/
            ctx[13]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*messages, createdNoteIndex, handleCreateNote, activeCommandId, replacedMessageIndex, handleReplace, copiedMessageIndex, handleCopy, cleanAssistantMessage*/
      493322) {
        each_value_2 = ensure_array_like(
          /*messages*/
          ctx2[1]
        );
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div0, t0);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_2.length;
      }
      if (
        /*status*/
        ctx2[2] === "searching" || /*webSearchResults*/
        ctx2[7] && /*webSearchResults*/
        ctx2[7].results.length > 0
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*status, webSearchResults*/
          132) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*status*/
        ctx2[2] === "streaming" || /*status*/
        ctx2[2] === "sending"
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*status*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (dirty[0] & /*status*/
      4 && textarea_disabled_value !== (textarea_disabled_value = /*status*/
      ctx2[2] === "streaming")) {
        textarea.disabled = textarea_disabled_value;
      }
      if (dirty[0] & /*userPrompt*/
      1) {
        set_input_value(
          textarea,
          /*userPrompt*/
          ctx2[0]
        );
      }
      if (dirty[0] & /*webSearchEnabled*/
      16 && svg0_class_value !== (svg0_class_value = /*webSearchEnabled*/
      ctx2[4] ? "opacity-20" : "")) {
        attr(svg0, "class", svg0_class_value);
      }
      if (
        /*webSearchEnabled*/
        ctx2[4]
      ) {
        if (if_block2) {
        } else {
          if_block2 = create_if_block(ctx2);
          if_block2.c();
          if_block2.m(div1, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (dirty[0] & /*webSearchEnabled*/
      16 && button0_class_value !== (button0_class_value = "relative mb-0.5 inline-flex h-9 w-9 items-center justify-center rounded-lg transition-all hover:bg-muted " + /*webSearchEnabled*/
      (ctx2[4] ? "text-primary bg-primary/10" : "text-muted-foreground/50"))) {
        attr(button0, "class", button0_class_value);
      }
      if (dirty[0] & /*webSearchEnabled*/
      16 && button0_title_value !== (button0_title_value = /*webSearchEnabled*/
      ctx2[4] ? "Disable Web Search" : "Enable Web Search")) {
        attr(button0, "title", button0_title_value);
      }
      if (dirty[0] & /*userPrompt, status*/
      5 && button1_disabled_value !== (button1_disabled_value = !/*userPrompt*/
      ctx2[0].trim() || /*status*/
      ctx2[2] === "streaming")) {
        button1.disabled = button1_disabled_value;
      }
    },
    i(local) {
      transition_in(if_block0);
      transition_in(if_block1);
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
    },
    d(detaching) {
      if (detaching) {
        detach(div5);
      }
      destroy_each(each_blocks, detaching);
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (if_block2) if_block2.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function stripThinkingTags(text2) {
  let cleaned = text2;
  cleaned = cleaned.replace(/<think>[\s\S]*?<\/think>/gi, "");
  cleaned = cleaned.replace(/<think>[\s\S]*?<think>/gi, "");
  cleaned = cleaned.replace(/<\/?think>/gi, "");
  cleaned = cleaned.replace(/<think[\s\S]*$/gi, "");
  return cleaned.trim();
}
function instance($$self, $$props, $$invalidate) {
  let displayResponse;
  let { plugin } = $$props;
  let { messages = [] } = $$props;
  let { currentResponse = "" } = $$props;
  let { status = "idle" } = $$props;
  let { userPrompt = "" } = $$props;
  let { activeCommandId = null } = $$props;
  const dispatch2 = createEventDispatcher();
  let { webSearchEnabled = false } = $$props;
  let { searchStatus = "" } = $$props;
  let { searchQueries = [] } = $$props;
  let { webSearchResults = void 0 } = $$props;
  function handleKeyDown(event) {
    if (event.key === "Enter" && !event.shiftKey) {
      event.preventDefault();
      if (userPrompt.trim() && (status === "idle" || status === "error")) {
        dispatch2("send");
      }
    }
  }
  function handleSend() {
    if (userPrompt.trim() && (status === "idle" || status === "error")) {
      dispatch2("send");
    }
  }
  function toggleWebSearch() {
    dispatch2("toggleWebSearch");
  }
  let copiedMessageIndex = null;
  let replacedMessageIndex = null;
  let createdNoteIndex = null;
  function handleCopy(text2, index) {
    navigator.clipboard.writeText(text2);
    $$invalidate(8, copiedMessageIndex = index);
    setTimeout(
      () => {
        $$invalidate(8, copiedMessageIndex = null);
      },
      1500
    );
  }
  function handleReplace(context, text2, index) {
    dispatch2("replace", { context, text: text2 });
    $$invalidate(9, replacedMessageIndex = index);
    setTimeout(
      () => {
        $$invalidate(9, replacedMessageIndex = null);
      },
      1500
    );
  }
  function handleCreateNote(text2, index) {
    dispatch2("createNote", { content: text2 });
    $$invalidate(10, createdNoteIndex = index);
    setTimeout(
      () => {
        $$invalidate(10, createdNoteIndex = null);
      },
      1500
    );
  }
  function cleanSourceTitleLinks(text2) {
    if (!(webSearchResults === null || webSearchResults === void 0 ? void 0 : webSearchResults.results)) return text2;
    return text2.replace(/\[Source Title\]\(([^)]+)\)/gi, (match, url) => {
      const result = webSearchResults.results.find((r) => r.url === url || url.includes(r.url) || r.url.includes(url));
      if (result) {
        return `[${result.title}](${result.url})`;
      }
      try {
        const domain = new URL(url).hostname.replace("www.", "");
        return `[${domain}](${url})`;
      } catch (_a) {
        return match;
      }
    });
  }
  function cleanAssistantMessage(text2) {
    let cleaned = stripThinkingTags(text2);
    cleaned = cleanSourceTitleLinks(cleaned);
    return cleaned;
  }
  function markdown(node, text2) {
    if (!text2) return;
    node.empty();
    const component = new import_obsidian5.Component();
    import_obsidian5.MarkdownRenderer.render(plugin.app, text2, node, "", component);
    return {
      update(newText) {
        node.empty();
        import_obsidian5.MarkdownRenderer.render(plugin.app, newText, node, "", component);
      },
      destroy() {
        component.unload();
      }
    };
  }
  const click_handler = (message, index) => handleCopy(message.content, index);
  const click_handler_1 = (message, index) => handleReplace(message.context, message.content, index);
  const click_handler_2 = (message, index) => handleCreateNote(message.content, index);
  function textarea_input_handler() {
    userPrompt = this.value;
    $$invalidate(0, userPrompt);
  }
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2) $$invalidate(20, plugin = $$props2.plugin);
    if ("messages" in $$props2) $$invalidate(1, messages = $$props2.messages);
    if ("currentResponse" in $$props2) $$invalidate(21, currentResponse = $$props2.currentResponse);
    if ("status" in $$props2) $$invalidate(2, status = $$props2.status);
    if ("userPrompt" in $$props2) $$invalidate(0, userPrompt = $$props2.userPrompt);
    if ("activeCommandId" in $$props2) $$invalidate(3, activeCommandId = $$props2.activeCommandId);
    if ("webSearchEnabled" in $$props2) $$invalidate(4, webSearchEnabled = $$props2.webSearchEnabled);
    if ("searchStatus" in $$props2) $$invalidate(5, searchStatus = $$props2.searchStatus);
    if ("searchQueries" in $$props2) $$invalidate(6, searchQueries = $$props2.searchQueries);
    if ("webSearchResults" in $$props2) $$invalidate(7, webSearchResults = $$props2.webSearchResults);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*currentResponse*/
    2097152) {
      $: $$invalidate(11, displayResponse = cleanAssistantMessage(currentResponse));
    }
  };
  return [
    userPrompt,
    messages,
    status,
    activeCommandId,
    webSearchEnabled,
    searchStatus,
    searchQueries,
    webSearchResults,
    copiedMessageIndex,
    replacedMessageIndex,
    createdNoteIndex,
    displayResponse,
    handleKeyDown,
    handleSend,
    toggleWebSearch,
    handleCopy,
    handleReplace,
    handleCreateNote,
    cleanAssistantMessage,
    markdown,
    plugin,
    currentResponse,
    click_handler,
    click_handler_1,
    click_handler_2,
    textarea_input_handler
  ];
}
var ChatView = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        plugin: 20,
        messages: 1,
        currentResponse: 21,
        status: 2,
        userPrompt: 0,
        activeCommandId: 3,
        webSearchEnabled: 4,
        searchStatus: 5,
        searchQueries: 6,
        webSearchResults: 7
      },
      add_css,
      [-1, -1]
    );
  }
};
var ChatView_default = ChatView;

// src/ui/modelPicker.ts
var import_obsidian6 = require("obsidian");
var ModelPickerModal = class extends import_obsidian6.FuzzySuggestModal {
  constructor(app, models, onChoose) {
    super(app);
    this.models = models;
    this.onChoose = onChoose;
    this.setPlaceholder("Select a model...");
  }
  getItems() {
    return this.models;
  }
  getItemText(model) {
    return model.id;
  }
  onChooseItem(model, evt) {
    this.onChoose(model.id);
  }
};

// src/ui/svelte/SettingsDrawer.svelte
function create_if_block2(ctx) {
  let div12;
  let div0;
  let h2;
  let t1;
  let button0;
  let t2;
  let div11;
  let div3;
  let div2;
  let label0;
  let t4;
  let div1;
  let button1;
  let t5;
  let button1_class_value;
  let t6;
  let button2;
  let t7;
  let button2_class_value;
  let t8;
  let t9;
  let t10;
  let div9;
  let div8;
  let div4;
  let t14;
  let div7;
  let div5;
  let t15;
  let div6;
  let div6_class_value;
  let t16;
  let t17;
  let div10;
  let mounted;
  let dispose;
  let if_block0 = (
    /*settings*/
    ctx[1].activeProvider === "ollama" && create_if_block_52(ctx)
  );
  let if_block1 = (
    /*settings*/
    ctx[1].activeProvider === "openai" && create_if_block_22(ctx)
  );
  let if_block2 = (
    /*settings*/
    ctx[1].webSearch.enabled && create_if_block_16(ctx)
  );
  return {
    c() {
      div12 = element("div");
      div0 = element("div");
      h2 = element("h2");
      h2.textContent = "Settings";
      t1 = space();
      button0 = element("button");
      button0.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"></path><path d="m6 6 12 12"></path></svg>`;
      t2 = space();
      div11 = element("div");
      div3 = element("div");
      div2 = element("div");
      label0 = element("label");
      label0.textContent = "Provider";
      t4 = space();
      div1 = element("div");
      button1 = element("button");
      t5 = text("Ollama");
      t6 = space();
      button2 = element("button");
      t7 = text("OpenAI");
      t8 = space();
      if (if_block0) if_block0.c();
      t9 = space();
      if (if_block1) if_block1.c();
      t10 = space();
      div9 = element("div");
      div8 = element("div");
      div4 = element("div");
      div4.innerHTML = `<label class="text-sm font-medium">Web Search</label> <p class="text-xs text-muted-foreground">Enhance responses with web data</p>`;
      t14 = space();
      div7 = element("div");
      div5 = element("div");
      t15 = space();
      div6 = element("div");
      t16 = space();
      if (if_block2) if_block2.c();
      t17 = space();
      div10 = element("div");
      div10.innerHTML = `<p class="text-[10px] text-muted-foreground/40 uppercase tracking-widest">AI Assistant v1.0</p>`;
      attr(h2, "class", "text-sm font-bold uppercase tracking-wider text-muted-foreground");
      attr(button0, "class", "inline-flex items-center justify-center rounded-md p-2 text-muted-foreground hover:bg-muted hover:text-foreground transition-colors");
      attr(button0, "aria-label", "Close");
      attr(div0, "class", "flex items-center justify-between p-4 border-b border-border bg-background/95 backdrop-blur z-10 shrink-0");
      attr(label0, "class", "text-sm font-medium");
      attr(button1, "class", button1_class_value = "flex-1 rounded-md px-2 py-1 text-xs font-medium transition-all " + /*settings*/
      (ctx[1].activeProvider === "ollama" ? "bg-background shadow-sm text-foreground" : "text-muted-foreground hover:text-foreground"));
      attr(button2, "class", button2_class_value = "flex-1 rounded-md px-2 py-1 text-xs font-medium transition-all " + /*settings*/
      (ctx[1].activeProvider === "openai" ? "bg-background shadow-sm text-foreground" : "text-muted-foreground hover:text-foreground"));
      attr(div1, "class", "relative inline-flex h-8 w-[140px] items-center rounded-lg bg-muted p-1");
      attr(div2, "class", "flex items-center justify-between");
      attr(div3, "class", "space-y-4");
      attr(div4, "class", "space-y-0.5");
      attr(div5, "class", "w-11 h-6 rounded-full transition-colors duration-200 ease-in-out");
      set_style(
        div5,
        "background-color",
        /*settings*/
        ctx[1].webSearch.enabled ? "var(--text-muted)" : "var(--background-modifier-border)"
      );
      attr(div6, "class", div6_class_value = "absolute top-[2px] left-[2px] bg-white rounded-full h-5 w-5 shadow-sm transition-transform duration-200 ease-in-out " + /*settings*/
      (ctx[1].webSearch.enabled ? "translate-x-[20px]" : "translate-x-0"));
      attr(div7, "class", "relative inline-flex items-center cursor-pointer");
      attr(div8, "class", "flex items-center justify-between");
      attr(div9, "class", "space-y-4 pt-4 border-t border-border");
      attr(div10, "class", "pt-8 pb-4 text-center");
      attr(div11, "class", "flex-1 overflow-y-auto p-4 space-y-8");
      attr(div12, "class", "absolute inset-0 z-50 flex flex-col animate-in slide-in-from-right duration-200");
      set_style(div12, "background-color", "var(--background-primary)");
      attr(div12, "role", "dialog");
      attr(div12, "aria-modal", "true");
    },
    m(target, anchor) {
      insert(target, div12, anchor);
      append(div12, div0);
      append(div0, h2);
      append(div0, t1);
      append(div0, button0);
      append(div12, t2);
      append(div12, div11);
      append(div11, div3);
      append(div3, div2);
      append(div2, label0);
      append(div2, t4);
      append(div2, div1);
      append(div1, button1);
      append(button1, t5);
      append(div1, t6);
      append(div1, button2);
      append(button2, t7);
      append(div3, t8);
      if (if_block0) if_block0.m(div3, null);
      append(div3, t9);
      if (if_block1) if_block1.m(div3, null);
      append(div11, t10);
      append(div11, div9);
      append(div9, div8);
      append(div8, div4);
      append(div8, t14);
      append(div8, div7);
      append(div7, div5);
      append(div7, t15);
      append(div7, div6);
      append(div9, t16);
      if (if_block2) if_block2.m(div9, null);
      append(div11, t17);
      append(div11, div10);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*handleClose*/
            ctx[4]
          ),
          listen(
            button1,
            "click",
            /*click_handler*/
            ctx[9]
          ),
          listen(
            button2,
            "click",
            /*click_handler_1*/
            ctx[10]
          ),
          listen(
            div7,
            "click",
            /*click_handler_4*/
            ctx[20]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*settings*/
      2 && button1_class_value !== (button1_class_value = "flex-1 rounded-md px-2 py-1 text-xs font-medium transition-all " + /*settings*/
      (ctx2[1].activeProvider === "ollama" ? "bg-background shadow-sm text-foreground" : "text-muted-foreground hover:text-foreground"))) {
        attr(button1, "class", button1_class_value);
      }
      if (dirty & /*settings*/
      2 && button2_class_value !== (button2_class_value = "flex-1 rounded-md px-2 py-1 text-xs font-medium transition-all " + /*settings*/
      (ctx2[1].activeProvider === "openai" ? "bg-background shadow-sm text-foreground" : "text-muted-foreground hover:text-foreground"))) {
        attr(button2, "class", button2_class_value);
      }
      if (
        /*settings*/
        ctx2[1].activeProvider === "ollama"
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_52(ctx2);
          if_block0.c();
          if_block0.m(div3, t9);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*settings*/
        ctx2[1].activeProvider === "openai"
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_22(ctx2);
          if_block1.c();
          if_block1.m(div3, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty & /*settings*/
      2) {
        set_style(
          div5,
          "background-color",
          /*settings*/
          ctx2[1].webSearch.enabled ? "var(--text-muted)" : "var(--background-modifier-border)"
        );
      }
      if (dirty & /*settings*/
      2 && div6_class_value !== (div6_class_value = "absolute top-[2px] left-[2px] bg-white rounded-full h-5 w-5 shadow-sm transition-transform duration-200 ease-in-out " + /*settings*/
      (ctx2[1].webSearch.enabled ? "translate-x-[20px]" : "translate-x-0"))) {
        attr(div6, "class", div6_class_value);
      }
      if (
        /*settings*/
        ctx2[1].webSearch.enabled
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_16(ctx2);
          if_block2.c();
          if_block2.m(div9, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div12);
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (if_block2) if_block2.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_52(ctx) {
  var _a, _b;
  let div6;
  let div0;
  let label0;
  let t1;
  let input0;
  let input0_value_value;
  let t2;
  let div3;
  let div1;
  let t4;
  let t5;
  let div2;
  let input1;
  let input1_value_value;
  let t6;
  let button;
  let t7;
  let div5;
  let div4;
  let label2;
  let t9;
  let span;
  let t10_value = (
    /*settings*/
    (((_b = (_a = ctx[1].providers.ollama) == null ? void 0 : _a.temperature) == null ? void 0 : _b.toFixed(1)) || "0.7") + ""
  );
  let t10;
  let t11;
  let input2;
  let input2_value_value;
  let mounted;
  let dispose;
  let if_block0 = (
    /*fetchError*/
    ctx[3] && /*settings*/
    ctx[1].activeProvider === "ollama" && create_if_block_72(ctx)
  );
  function select_block_type(ctx2, dirty) {
    if (
      /*isFetching*/
      ctx2[2] && /*settings*/
      ctx2[1].activeProvider === "ollama"
    ) return create_if_block_62;
    return create_else_block_12;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block1 = current_block_type(ctx);
  return {
    c() {
      var _a2, _b2, _c;
      div6 = element("div");
      div0 = element("div");
      label0 = element("label");
      label0.textContent = "Base URL";
      t1 = space();
      input0 = element("input");
      t2 = space();
      div3 = element("div");
      div1 = element("div");
      div1.innerHTML = `<label class="text-xs font-medium text-muted-foreground">Model Name</label>`;
      t4 = space();
      if (if_block0) if_block0.c();
      t5 = space();
      div2 = element("div");
      input1 = element("input");
      t6 = space();
      button = element("button");
      if_block1.c();
      t7 = space();
      div5 = element("div");
      div4 = element("div");
      label2 = element("label");
      label2.textContent = "Temperature";
      t9 = space();
      span = element("span");
      t10 = text(t10_value);
      t11 = space();
      input2 = element("input");
      attr(label0, "class", "text-xs font-medium text-muted-foreground");
      attr(input0, "type", "text");
      input0.value = input0_value_value = /*settings*/
      ((_a2 = ctx[1].providers.ollama) == null ? void 0 : _a2.baseUrl) || "";
      attr(input0, "class", "flex w-full rounded-md border border-input bg-background/50 px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:border-transparent transition-all");
      attr(input0, "placeholder", "http://localhost:11434");
      attr(div0, "class", "space-y-1.5");
      attr(div1, "class", "flex items-center justify-between");
      attr(input1, "type", "text");
      input1.value = input1_value_value = /*settings*/
      ((_b2 = ctx[1].providers.ollama) == null ? void 0 : _b2.model) || "";
      attr(input1, "class", "flex-1 rounded-md border border-input bg-background/50 px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:border-transparent transition-all");
      attr(input1, "placeholder", "llama2");
      attr(button, "class", "p-2 h-9 w-9 inline-flex items-center justify-center rounded-md border border-input hover:bg-muted text-muted-foreground hover:text-foreground transition-colors disabled:opacity-50");
      attr(button, "title", "Fetch and select model...");
      button.disabled = /*isFetching*/
      ctx[2];
      attr(div2, "class", "flex gap-2");
      attr(div3, "class", "space-y-1.5");
      attr(label2, "class", "text-xs font-medium text-muted-foreground");
      attr(span, "class", "text-xs text-muted-foreground font-mono bg-muted/50 px-1.5 py-0.5 rounded");
      attr(div4, "class", "flex items-center justify-between");
      attr(input2, "type", "range");
      attr(input2, "min", "0");
      attr(input2, "max", "2");
      attr(input2, "step", "0.1");
      input2.value = input2_value_value = /*settings*/
      ((_c = ctx[1].providers.ollama) == null ? void 0 : _c.temperature) || 0.7;
      attr(input2, "class", "styled-slider");
      attr(div5, "class", "space-y-3 pt-2");
      attr(div6, "class", "space-y-4 pt-2 animate-in fade-in slide-in-from-top-2 duration-200");
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      append(div6, div0);
      append(div0, label0);
      append(div0, t1);
      append(div0, input0);
      append(div6, t2);
      append(div6, div3);
      append(div3, div1);
      append(div3, t4);
      if (if_block0) if_block0.m(div3, null);
      append(div3, t5);
      append(div3, div2);
      append(div2, input1);
      append(div2, t6);
      append(div2, button);
      if_block1.m(button, null);
      append(div6, t7);
      append(div6, div5);
      append(div5, div4);
      append(div4, label2);
      append(div4, t9);
      append(div4, span);
      append(span, t10);
      append(div5, t11);
      append(div5, input2);
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input_handler*/
            ctx[11]
          ),
          listen(
            input1,
            "input",
            /*input_handler_1*/
            ctx[12]
          ),
          listen(
            button,
            "click",
            /*click_handler_2*/
            ctx[13]
          ),
          listen(
            input2,
            "input",
            /*input_handler_2*/
            ctx[14]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      var _a2, _b2, _c, _d, _e;
      if (dirty & /*settings*/
      2 && input0_value_value !== (input0_value_value = /*settings*/
      ((_a2 = ctx2[1].providers.ollama) == null ? void 0 : _a2.baseUrl) || "") && input0.value !== input0_value_value) {
        input0.value = input0_value_value;
      }
      if (
        /*fetchError*/
        ctx2[3] && /*settings*/
        ctx2[1].activeProvider === "ollama"
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_72(ctx2);
          if_block0.c();
          if_block0.m(div3, t5);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty & /*settings*/
      2 && input1_value_value !== (input1_value_value = /*settings*/
      ((_b2 = ctx2[1].providers.ollama) == null ? void 0 : _b2.model) || "") && input1.value !== input1_value_value) {
        input1.value = input1_value_value;
      }
      if (current_block_type !== (current_block_type = select_block_type(ctx2, dirty))) {
        if_block1.d(1);
        if_block1 = current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(button, null);
        }
      }
      if (dirty & /*isFetching*/
      4) {
        button.disabled = /*isFetching*/
        ctx2[2];
      }
      if (dirty & /*settings*/
      2 && t10_value !== (t10_value = /*settings*/
      (((_d = (_c = ctx2[1].providers.ollama) == null ? void 0 : _c.temperature) == null ? void 0 : _d.toFixed(1)) || "0.7") + "")) set_data(t10, t10_value);
      if (dirty & /*settings*/
      2 && input2_value_value !== (input2_value_value = /*settings*/
      ((_e = ctx2[1].providers.ollama) == null ? void 0 : _e.temperature) || 0.7)) {
        input2.value = input2_value_value;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div6);
      }
      if (if_block0) if_block0.d();
      if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_72(ctx) {
  let div;
  let t0;
  let t1;
  return {
    c() {
      div = element("div");
      t0 = text("Connection failed: ");
      t1 = text(
        /*fetchError*/
        ctx[3]
      );
      attr(div, "class", "p-2 rounded bg-destructive/10 text-destructive text-[10px] mb-2 animate-in fade-in slide-in-from-top-1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*fetchError*/
      8) set_data(
        t1,
        /*fetchError*/
        ctx2[3]
      );
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_else_block_12(ctx) {
  let svg;
  let line0;
  let line1;
  let line2;
  let line3;
  let line4;
  let line5;
  return {
    c() {
      svg = svg_element("svg");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      line3 = svg_element("line");
      line4 = svg_element("line");
      line5 = svg_element("line");
      attr(line0, "x1", "8");
      attr(line0, "y1", "6");
      attr(line0, "x2", "21");
      attr(line0, "y2", "6");
      attr(line1, "x1", "8");
      attr(line1, "y1", "12");
      attr(line1, "x2", "21");
      attr(line1, "y2", "12");
      attr(line2, "x1", "8");
      attr(line2, "y1", "18");
      attr(line2, "x2", "21");
      attr(line2, "y2", "18");
      attr(line3, "x1", "3");
      attr(line3, "y1", "6");
      attr(line3, "x2", "3.01");
      attr(line3, "y2", "6");
      attr(line4, "x1", "3");
      attr(line4, "y1", "12");
      attr(line4, "x2", "3.01");
      attr(line4, "y2", "12");
      attr(line5, "x1", "3");
      attr(line5, "y1", "18");
      attr(line5, "x2", "3.01");
      attr(line5, "y2", "18");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "16");
      attr(svg, "height", "16");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, line0);
      append(svg, line1);
      append(svg, line2);
      append(svg, line3);
      append(svg, line4);
      append(svg, line5);
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_if_block_62(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "h-4 w-4 animate-spin rounded-full border-2 border-current border-t-transparent");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block_22(ctx) {
  var _a, _b;
  let div7;
  let div0;
  let label0;
  let t1;
  let input0;
  let input0_value_value;
  let t2;
  let div1;
  let label1;
  let t4;
  let input1;
  let input1_value_value;
  let t5;
  let div4;
  let div2;
  let t7;
  let t8;
  let div3;
  let input2;
  let input2_value_value;
  let t9;
  let button;
  let t10;
  let div6;
  let div5;
  let label3;
  let t12;
  let span;
  let t13_value = (
    /*settings*/
    (((_b = (_a = ctx[1].providers.openai) == null ? void 0 : _a.temperature) == null ? void 0 : _b.toFixed(1)) || "0.7") + ""
  );
  let t13;
  let t14;
  let input3;
  let input3_value_value;
  let mounted;
  let dispose;
  let if_block0 = (
    /*fetchError*/
    ctx[3] && /*settings*/
    ctx[1].activeProvider === "openai" && create_if_block_42(ctx)
  );
  function select_block_type_1(ctx2, dirty) {
    if (
      /*isFetching*/
      ctx2[2] && /*settings*/
      ctx2[1].activeProvider === "openai"
    ) return create_if_block_32;
    return create_else_block2;
  }
  let current_block_type = select_block_type_1(ctx, -1);
  let if_block1 = current_block_type(ctx);
  return {
    c() {
      var _a2, _b2, _c, _d;
      div7 = element("div");
      div0 = element("div");
      label0 = element("label");
      label0.textContent = "API Key";
      t1 = space();
      input0 = element("input");
      t2 = space();
      div1 = element("div");
      label1 = element("label");
      label1.textContent = "Base URL";
      t4 = space();
      input1 = element("input");
      t5 = space();
      div4 = element("div");
      div2 = element("div");
      div2.innerHTML = `<label class="text-xs font-medium text-muted-foreground">Model Name</label>`;
      t7 = space();
      if (if_block0) if_block0.c();
      t8 = space();
      div3 = element("div");
      input2 = element("input");
      t9 = space();
      button = element("button");
      if_block1.c();
      t10 = space();
      div6 = element("div");
      div5 = element("div");
      label3 = element("label");
      label3.textContent = "Temperature";
      t12 = space();
      span = element("span");
      t13 = text(t13_value);
      t14 = space();
      input3 = element("input");
      attr(label0, "class", "text-xs font-medium text-muted-foreground");
      attr(input0, "type", "password");
      input0.value = input0_value_value = /*settings*/
      ((_a2 = ctx[1].providers.openai) == null ? void 0 : _a2.apiKey) || "";
      attr(input0, "class", "flex w-full rounded-md border border-input bg-background/50 px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:border-transparent transition-all");
      attr(input0, "placeholder", "sk-...");
      attr(div0, "class", "space-y-1.5");
      attr(label1, "class", "text-xs font-medium text-muted-foreground");
      attr(input1, "type", "text");
      input1.value = input1_value_value = /*settings*/
      ((_b2 = ctx[1].providers.openai) == null ? void 0 : _b2.baseUrl) || "";
      attr(input1, "class", "flex w-full rounded-md border border-input bg-background/50 px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:border-transparent transition-all");
      attr(input1, "placeholder", "https://api.openai.com/v1");
      attr(div1, "class", "space-y-1.5");
      attr(div2, "class", "flex items-center justify-between");
      attr(input2, "type", "text");
      input2.value = input2_value_value = /*settings*/
      ((_c = ctx[1].providers.openai) == null ? void 0 : _c.model) || "";
      attr(input2, "class", "flex-1 rounded-md border border-input bg-background/50 px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:border-transparent transition-all");
      attr(input2, "placeholder", "gpt-4");
      attr(button, "class", "p-2 h-9 w-9 inline-flex items-center justify-center rounded-md border border-input hover:bg-muted text-muted-foreground hover:text-foreground transition-colors disabled:opacity-50");
      attr(button, "title", "Fetch and select model...");
      button.disabled = /*isFetching*/
      ctx[2];
      attr(div3, "class", "flex gap-2");
      attr(div4, "class", "space-y-1.5");
      attr(label3, "class", "text-xs font-medium text-muted-foreground");
      attr(span, "class", "text-xs text-muted-foreground font-mono bg-muted/50 px-1.5 py-0.5 rounded");
      attr(div5, "class", "flex items-center justify-between");
      attr(input3, "type", "range");
      attr(input3, "min", "0");
      attr(input3, "max", "2");
      attr(input3, "step", "0.1");
      input3.value = input3_value_value = /*settings*/
      ((_d = ctx[1].providers.openai) == null ? void 0 : _d.temperature) || 0.7;
      attr(input3, "class", "styled-slider");
      attr(div6, "class", "space-y-3 pt-2");
      attr(div7, "class", "space-y-4 pt-2 animate-in fade-in slide-in-from-top-2 duration-200");
    },
    m(target, anchor) {
      insert(target, div7, anchor);
      append(div7, div0);
      append(div0, label0);
      append(div0, t1);
      append(div0, input0);
      append(div7, t2);
      append(div7, div1);
      append(div1, label1);
      append(div1, t4);
      append(div1, input1);
      append(div7, t5);
      append(div7, div4);
      append(div4, div2);
      append(div4, t7);
      if (if_block0) if_block0.m(div4, null);
      append(div4, t8);
      append(div4, div3);
      append(div3, input2);
      append(div3, t9);
      append(div3, button);
      if_block1.m(button, null);
      append(div7, t10);
      append(div7, div6);
      append(div6, div5);
      append(div5, label3);
      append(div5, t12);
      append(div5, span);
      append(span, t13);
      append(div6, t14);
      append(div6, input3);
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input_handler_3*/
            ctx[15]
          ),
          listen(
            input1,
            "input",
            /*input_handler_4*/
            ctx[16]
          ),
          listen(
            input2,
            "input",
            /*input_handler_5*/
            ctx[17]
          ),
          listen(
            button,
            "click",
            /*click_handler_3*/
            ctx[18]
          ),
          listen(
            input3,
            "input",
            /*input_handler_6*/
            ctx[19]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      var _a2, _b2, _c, _d, _e, _f;
      if (dirty & /*settings*/
      2 && input0_value_value !== (input0_value_value = /*settings*/
      ((_a2 = ctx2[1].providers.openai) == null ? void 0 : _a2.apiKey) || "") && input0.value !== input0_value_value) {
        input0.value = input0_value_value;
      }
      if (dirty & /*settings*/
      2 && input1_value_value !== (input1_value_value = /*settings*/
      ((_b2 = ctx2[1].providers.openai) == null ? void 0 : _b2.baseUrl) || "") && input1.value !== input1_value_value) {
        input1.value = input1_value_value;
      }
      if (
        /*fetchError*/
        ctx2[3] && /*settings*/
        ctx2[1].activeProvider === "openai"
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_42(ctx2);
          if_block0.c();
          if_block0.m(div4, t8);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty & /*settings*/
      2 && input2_value_value !== (input2_value_value = /*settings*/
      ((_c = ctx2[1].providers.openai) == null ? void 0 : _c.model) || "") && input2.value !== input2_value_value) {
        input2.value = input2_value_value;
      }
      if (current_block_type !== (current_block_type = select_block_type_1(ctx2, dirty))) {
        if_block1.d(1);
        if_block1 = current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(button, null);
        }
      }
      if (dirty & /*isFetching*/
      4) {
        button.disabled = /*isFetching*/
        ctx2[2];
      }
      if (dirty & /*settings*/
      2 && t13_value !== (t13_value = /*settings*/
      (((_e = (_d = ctx2[1].providers.openai) == null ? void 0 : _d.temperature) == null ? void 0 : _e.toFixed(1)) || "0.7") + "")) set_data(t13, t13_value);
      if (dirty & /*settings*/
      2 && input3_value_value !== (input3_value_value = /*settings*/
      ((_f = ctx2[1].providers.openai) == null ? void 0 : _f.temperature) || 0.7)) {
        input3.value = input3_value_value;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div7);
      }
      if (if_block0) if_block0.d();
      if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_42(ctx) {
  let div;
  let t0;
  let t1;
  return {
    c() {
      div = element("div");
      t0 = text("Connection failed: ");
      t1 = text(
        /*fetchError*/
        ctx[3]
      );
      attr(div, "class", "p-2 rounded bg-destructive/10 text-destructive text-[10px] mb-2 animate-in fade-in slide-in-from-top-1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*fetchError*/
      8) set_data(
        t1,
        /*fetchError*/
        ctx2[3]
      );
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_else_block2(ctx) {
  let svg;
  let line0;
  let line1;
  let line2;
  let line3;
  let line4;
  let line5;
  return {
    c() {
      svg = svg_element("svg");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      line3 = svg_element("line");
      line4 = svg_element("line");
      line5 = svg_element("line");
      attr(line0, "x1", "8");
      attr(line0, "y1", "6");
      attr(line0, "x2", "21");
      attr(line0, "y2", "6");
      attr(line1, "x1", "8");
      attr(line1, "y1", "12");
      attr(line1, "x2", "21");
      attr(line1, "y2", "12");
      attr(line2, "x1", "8");
      attr(line2, "y1", "18");
      attr(line2, "x2", "21");
      attr(line2, "y2", "18");
      attr(line3, "x1", "3");
      attr(line3, "y1", "6");
      attr(line3, "x2", "3.01");
      attr(line3, "y2", "6");
      attr(line4, "x1", "3");
      attr(line4, "y1", "12");
      attr(line4, "x2", "3.01");
      attr(line4, "y2", "12");
      attr(line5, "x1", "3");
      attr(line5, "y1", "18");
      attr(line5, "x2", "3.01");
      attr(line5, "y2", "18");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "16");
      attr(svg, "height", "16");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, line0);
      append(svg, line1);
      append(svg, line2);
      append(svg, line3);
      append(svg, line4);
      append(svg, line5);
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_if_block_32(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "h-4 w-4 animate-spin rounded-full border-2 border-current border-t-transparent");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block_16(ctx) {
  let div;
  let label;
  let t1;
  let input;
  let t2;
  let p;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      label = element("label");
      label.textContent = "SearXNG URL";
      t1 = space();
      input = element("input");
      t2 = space();
      p = element("p");
      p.innerHTML = `Use <code class="bg-muted px-1 py-0.5 rounded text-foreground">%s</code> as a placeholder for the query.`;
      attr(label, "class", "text-xs font-medium text-muted-foreground");
      attr(input, "type", "text");
      attr(input, "class", "flex w-full rounded-md border border-input bg-background/50 px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:border-transparent transition-all");
      attr(input, "placeholder", "http://host:port/search?q=%s&language=a");
      attr(p, "class", "text-[10px] text-muted-foreground");
      attr(div, "class", "space-y-1.5 animate-in fade-in slide-in-from-top-1 duration-200");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(div, t1);
      append(div, input);
      set_input_value(
        input,
        /*settings*/
        ctx[1].webSearch.urlTemplate
      );
      append(div, t2);
      append(div, p);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[21]
          ),
          listen(
            input,
            "input",
            /*input_handler_7*/
            ctx[22]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*settings*/
      2 && input.value !== /*settings*/
      ctx2[1].webSearch.urlTemplate) {
        set_input_value(
          input,
          /*settings*/
          ctx2[1].webSearch.urlTemplate
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment2(ctx) {
  let if_block_anchor;
  let if_block = (
    /*open*/
    ctx[0] && create_if_block2(ctx)
  );
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*open*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { open = false } = $$props;
  let { plugin } = $$props;
  let settings = plugin.settings;
  let availableModels = [];
  let isFetching = false;
  let fetchError = null;
  function handleClose() {
    $$invalidate(0, open = false);
  }
  async function openModelSelector(provider) {
    if (isFetching) return;
    await fetchModels(provider);
    if (availableModels.length > 0) {
      new ModelPickerModal(
        plugin.app,
        availableModels,
        (modelId) => {
          updateProviderSetting(provider, "model", modelId);
        }
      ).open();
    }
  }
  async function updateSetting(key, value) {
    if (key === "activeProvider" && value !== settings.activeProvider) {
      availableModels = [];
      $$invalidate(3, fetchError = null);
    }
    $$invalidate(1, settings[key] = value, settings);
    await plugin.saveSettings();
  }
  async function updateProviderSetting(provider, key, value) {
    if (!settings.providers[provider]) {
      $$invalidate(1, settings.providers[provider] = {}, settings);
    }
    $$invalidate(1, settings.providers[provider][key] = value, settings);
    await plugin.saveSettings();
  }
  async function fetchModels(provider) {
    $$invalidate(2, isFetching = true);
    $$invalidate(3, fetchError = null);
    availableModels = [];
    try {
      const providerSettings = settings.providers[provider];
      if (!providerSettings) {
        throw new Error("Provider settings not initialized");
      }
      if (provider === "ollama" && !providerSettings.baseUrl) {
        providerSettings.baseUrl = "http://localhost:11434";
      }
      const client = createProviderClient(provider, providerSettings);
      availableModels = await client.listModels();
      if (availableModels.length === 0) {
        $$invalidate(3, fetchError = "No models found or connection failed");
      }
    } catch (e) {
      $$invalidate(3, fetchError = e.message || "Failed to fetch models");
    } finally {
      $$invalidate(2, isFetching = false);
    }
  }
  const click_handler = () => updateSetting("activeProvider", "ollama");
  const click_handler_1 = () => updateSetting("activeProvider", "openai");
  const input_handler = (e) => updateProviderSetting("ollama", "baseUrl", e.currentTarget.value);
  const input_handler_1 = (e) => updateProviderSetting("ollama", "model", e.currentTarget.value);
  const click_handler_2 = () => openModelSelector("ollama");
  const input_handler_2 = (e) => updateProviderSetting("ollama", "temperature", parseFloat(e.currentTarget.value));
  const input_handler_3 = (e) => updateProviderSetting("openai", "apiKey", e.currentTarget.value);
  const input_handler_4 = (e) => updateProviderSetting("openai", "baseUrl", e.currentTarget.value);
  const input_handler_5 = (e) => updateProviderSetting("openai", "model", e.currentTarget.value);
  const click_handler_3 = () => openModelSelector("openai");
  const input_handler_6 = (e) => updateProviderSetting("openai", "temperature", parseFloat(e.currentTarget.value));
  const click_handler_4 = () => {
    $$invalidate(1, settings.webSearch.enabled = !settings.webSearch.enabled, settings);
    $$invalidate(1, settings);
    updateSetting("webSearch", settings.webSearch);
  };
  function input_input_handler() {
    settings.webSearch.urlTemplate = this.value;
    $$invalidate(1, settings);
  }
  const input_handler_7 = () => updateSetting("webSearch", settings.webSearch);
  $$self.$$set = ($$props2) => {
    if ("open" in $$props2) $$invalidate(0, open = $$props2.open);
    if ("plugin" in $$props2) $$invalidate(8, plugin = $$props2.plugin);
  };
  return [
    open,
    settings,
    isFetching,
    fetchError,
    handleClose,
    openModelSelector,
    updateSetting,
    updateProviderSetting,
    plugin,
    click_handler,
    click_handler_1,
    input_handler,
    input_handler_1,
    click_handler_2,
    input_handler_2,
    input_handler_3,
    input_handler_4,
    input_handler_5,
    click_handler_3,
    input_handler_6,
    click_handler_4,
    input_input_handler,
    input_handler_7
  ];
}
var SettingsDrawer = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, { open: 0, plugin: 8 });
  }
};
var SettingsDrawer_default = SettingsDrawer;

// src/ui/svelte/App.svelte
function create_if_block_33(ctx) {
  let button;
  let button_class_value;
  let button_title_value;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*conversationSaved*/
      ctx2[11]
    ) return create_if_block_43;
    return create_else_block3;
  }
  let current_block_type = select_block_type(ctx, [-1, -1]);
  let if_block = current_block_type(ctx);
  return {
    c() {
      button = element("button");
      if_block.c();
      attr(button, "class", button_class_value = "inline-flex items-center justify-center rounded-md hover:bg-accent hover:text-accent-foreground h-9 w-9 transition-colors " + /*conversationSaved*/
      (ctx[11] ? "text-primary" : ""));
      attr(button, "title", button_title_value = /*conversationSaved*/
      ctx[11] ? "Note created!" : "Save conversation as note");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if_block.m(button, null);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*handleSaveConversation*/
          ctx[22]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (current_block_type !== (current_block_type = select_block_type(ctx2, dirty))) {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(button, null);
        }
      }
      if (dirty[0] & /*conversationSaved*/
      2048 && button_class_value !== (button_class_value = "inline-flex items-center justify-center rounded-md hover:bg-accent hover:text-accent-foreground h-9 w-9 transition-colors " + /*conversationSaved*/
      (ctx2[11] ? "text-primary" : ""))) {
        attr(button, "class", button_class_value);
      }
      if (dirty[0] & /*conversationSaved*/
      2048 && button_title_value !== (button_title_value = /*conversationSaved*/
      ctx2[11] ? "Note created!" : "Save conversation as note")) {
        attr(button, "title", button_title_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_else_block3(ctx) {
  let svg;
  let path;
  let polyline;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      polyline = svg_element("polyline");
      attr(path, "d", "M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z");
      attr(polyline, "points", "14 2 14 8 20 8");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "16");
      attr(svg, "height", "16");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
      append(svg, polyline);
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_if_block_43(ctx) {
  let svg;
  let polyline;
  return {
    c() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      attr(polyline, "points", "20 6 9 17 4 12");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "16");
      attr(svg, "height", "16");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, polyline);
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_if_block_23(ctx) {
  let button0;
  let t;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      button0 = element("button");
      button0.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14"></path><path d="M5 12h14"></path></svg>`;
      t = space();
      button1 = element("button");
      button1.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"></path><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>`;
      attr(button0, "class", "inline-flex items-center justify-center rounded-md hover:bg-accent hover:text-accent-foreground h-9 w-9 transition-colors");
      attr(button0, "title", "New Chat");
      attr(button1, "class", "inline-flex items-center justify-center rounded-md hover:bg-destructive/80 hover:text-destructive-foreground h-9 w-9 transition-colors text-muted-foreground");
      attr(button1, "title", "Clear History");
    },
    m(target, anchor) {
      insert(target, button0, anchor);
      insert(target, t, anchor);
      insert(target, button1, anchor);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*handleReset*/
            ctx[17]
          ),
          listen(
            button1,
            "click",
            /*handleClearHistory*/
            ctx[18]
          )
        ];
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(button0);
        detach(t);
        detach(button1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_17(ctx) {
  let div1;
  let div0;
  let t0;
  let t1;
  let button;
  let div1_transition;
  let current;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t0 = text(
        /*error*/
        ctx[7]
      );
      t1 = space();
      button = element("button");
      button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`;
      attr(div0, "class", "flex-1 break-words font-medium");
      attr(button, "class", "rounded-md p-1 h-fit transition-colors hover:opacity-80");
      attr(button, "title", "Dismiss");
      attr(div1, "class", "absolute top-4 left-4 right-4 z-50 p-3 rounded-md shadow-md flex justify-between gap-2 backdrop-blur-sm");
      set_style(div1, "background-color", "var(--background-modifier-error)");
      set_style(div1, "color", "var(--text-on-accent)");
      set_style(div1, "border", "1px solid var(--text-error)");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, t0);
      append(div1, t1);
      append(div1, button);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_1*/
          ctx[26]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty[0] & /*error*/
      128) set_data(
        t0,
        /*error*/
        ctx2[7]
      );
    },
    i(local) {
      if (current) return;
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (!div1_transition) div1_transition = create_bidirectional_transition(div1, slide, {}, true);
          div1_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      if (local) {
        if (!div1_transition) div1_transition = create_bidirectional_transition(div1, slide, {}, false);
        div1_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (detaching && div1_transition) div1_transition.end();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block3(ctx) {
  let div;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button = element("button");
      button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect></svg>
                    Stop Generating`;
      attr(button, "class", "shadow-lg inline-flex items-center justify-center gap-2 rounded-full text-xs font-semibold bg-destructive/90 hover:bg-destructive text-destructive-foreground h-8 px-4 py-1 transition-all backdrop-blur");
      attr(div, "class", "absolute bottom-24 left-1/2 -translate-x-1/2 z-10");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*handleStopGeneration*/
          ctx[16]
        );
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment3(ctx) {
  let div4;
  let div2;
  let div1;
  let button0;
  let span0;
  let t1;
  let span1;
  let t2_value = (
    /*activeCommand*/
    (ctx[13] ? (
      /*activeCommand*/
      ctx[13].title
    ) : "Pick a command...") + ""
  );
  let t2;
  let t3;
  let span2;
  let t5;
  let div0;
  let t6;
  let t7;
  let button1;
  let t8;
  let div3;
  let t9;
  let chatview;
  let updating_userPrompt;
  let t10;
  let t11;
  let settingsdrawer;
  let updating_open;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*messages*/
    ctx[4].length > 0 && /*activeCommandId*/
    ctx[1] === "research_create_note" && create_if_block_33(ctx)
  );
  let if_block1 = (
    /*messages*/
    ctx[4].length > 0 && create_if_block_23(ctx)
  );
  let if_block2 = (
    /*error*/
    ctx[7] && create_if_block_17(ctx)
  );
  function chatview_userPrompt_binding(value) {
    ctx[27](value);
  }
  let chatview_props = {
    plugin: (
      /*plugin*/
      ctx[0]
    ),
    messages: (
      /*messages*/
      ctx[4]
    ),
    currentResponse: (
      /*currentResponse*/
      ctx[5]
    ),
    status: (
      /*status*/
      ctx[2]
    ),
    webSearchEnabled: (
      /*webSearchEnabled*/
      ctx[12]
    ),
    searchStatus: (
      /*searchStatus*/
      ctx[8]
    ),
    searchQueries: (
      /*searchQueries*/
      ctx[9]
    ),
    webSearchResults: (
      /*webSearchResults*/
      ctx[10]
    ),
    activeCommandId: (
      /*activeCommandId*/
      ctx[1]
    )
  };
  if (
    /*userPrompt*/
    ctx[6] !== void 0
  ) {
    chatview_props.userPrompt = /*userPrompt*/
    ctx[6];
  }
  chatview = new ChatView_default({ props: chatview_props });
  binding_callbacks.push(() => bind(chatview, "userPrompt", chatview_userPrompt_binding));
  chatview.$on(
    "send",
    /*handleSendMessage*/
    ctx[15]
  );
  chatview.$on(
    "replace",
    /*handleReplace*/
    ctx[19]
  );
  chatview.$on(
    "toggleWebSearch",
    /*handleToggleWebSearch*/
    ctx[14]
  );
  chatview.$on(
    "createNote",
    /*handleCreateNote*/
    ctx[20]
  );
  let if_block3 = (
    /*status*/
    ctx[2] === "streaming" && create_if_block3(ctx)
  );
  function settingsdrawer_open_binding(value) {
    ctx[28](value);
  }
  let settingsdrawer_props = { plugin: (
    /*plugin*/
    ctx[0]
  ) };
  if (
    /*settingsOpen*/
    ctx[3] !== void 0
  ) {
    settingsdrawer_props.open = /*settingsOpen*/
    ctx[3];
  }
  settingsdrawer = new SettingsDrawer_default({ props: settingsdrawer_props });
  binding_callbacks.push(() => bind(settingsdrawer, "open", settingsdrawer_open_binding));
  return {
    c() {
      div4 = element("div");
      div2 = element("div");
      div1 = element("div");
      button0 = element("button");
      span0 = element("span");
      span0.textContent = "\u2728";
      t1 = space();
      span1 = element("span");
      t2 = text(t2_value);
      t3 = space();
      span2 = element("span");
      span2.textContent = "\u25BC";
      t5 = space();
      div0 = element("div");
      if (if_block0) if_block0.c();
      t6 = space();
      if (if_block1) if_block1.c();
      t7 = space();
      button1 = element("button");
      button1.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.38a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-1.72v-.51a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"></path><circle cx="12" cy="12" r="3"></circle></svg>`;
      t8 = space();
      div3 = element("div");
      if (if_block2) if_block2.c();
      t9 = space();
      create_component(chatview.$$.fragment);
      t10 = space();
      if (if_block3) if_block3.c();
      t11 = space();
      create_component(settingsdrawer.$$.fragment);
      attr(span0, "class", "text-primary");
      attr(span1, "class", "truncate block flex-1");
      attr(span2, "class", "text-xs opacity-50");
      attr(button0, "class", "flex-1 inline-flex items-center justify-start gap-2 rounded-lg bg-muted/50 hover:bg-muted text-sm font-medium h-9 px-3 text-muted-foreground transition-colors text-left");
      attr(button1, "class", "inline-flex items-center justify-center rounded-md hover:bg-accent hover:text-accent-foreground h-9 w-9 transition-colors");
      attr(button1, "title", "Settings");
      attr(div0, "class", "flex items-center gap-1");
      attr(div1, "class", "flex items-center gap-2 p-2");
      attr(div2, "class", "flex flex-col border-b border-border bg-background/95 backdrop-blur z-20");
      attr(div3, "class", "flex-1 overflow-hidden relative");
      attr(div4, "class", "h-full flex flex-col bg-background text-foreground relative overflow-hidden");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div2);
      append(div2, div1);
      append(div1, button0);
      append(button0, span0);
      append(button0, t1);
      append(button0, span1);
      append(span1, t2);
      append(button0, t3);
      append(button0, span2);
      append(div1, t5);
      append(div1, div0);
      if (if_block0) if_block0.m(div0, null);
      append(div0, t6);
      if (if_block1) if_block1.m(div0, null);
      append(div0, t7);
      append(div0, button1);
      append(div4, t8);
      append(div4, div3);
      if (if_block2) if_block2.m(div3, null);
      append(div3, t9);
      mount_component(chatview, div3, null);
      append(div3, t10);
      if (if_block3) if_block3.m(div3, null);
      append(div4, t11);
      mount_component(settingsdrawer, div4, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*openCommandPicker*/
            ctx[21]
          ),
          listen(
            button1,
            "click",
            /*click_handler*/
            ctx[25]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*activeCommand*/
      8192) && t2_value !== (t2_value = /*activeCommand*/
      (ctx2[13] ? (
        /*activeCommand*/
        ctx2[13].title
      ) : "Pick a command...") + "")) set_data(t2, t2_value);
      if (
        /*messages*/
        ctx2[4].length > 0 && /*activeCommandId*/
        ctx2[1] === "research_create_note"
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_33(ctx2);
          if_block0.c();
          if_block0.m(div0, t6);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*messages*/
        ctx2[4].length > 0
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_23(ctx2);
          if_block1.c();
          if_block1.m(div0, t7);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*error*/
        ctx2[7]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*error*/
          128) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_17(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div3, t9);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      const chatview_changes = {};
      if (dirty[0] & /*plugin*/
      1) chatview_changes.plugin = /*plugin*/
      ctx2[0];
      if (dirty[0] & /*messages*/
      16) chatview_changes.messages = /*messages*/
      ctx2[4];
      if (dirty[0] & /*currentResponse*/
      32) chatview_changes.currentResponse = /*currentResponse*/
      ctx2[5];
      if (dirty[0] & /*status*/
      4) chatview_changes.status = /*status*/
      ctx2[2];
      if (dirty[0] & /*webSearchEnabled*/
      4096) chatview_changes.webSearchEnabled = /*webSearchEnabled*/
      ctx2[12];
      if (dirty[0] & /*searchStatus*/
      256) chatview_changes.searchStatus = /*searchStatus*/
      ctx2[8];
      if (dirty[0] & /*searchQueries*/
      512) chatview_changes.searchQueries = /*searchQueries*/
      ctx2[9];
      if (dirty[0] & /*webSearchResults*/
      1024) chatview_changes.webSearchResults = /*webSearchResults*/
      ctx2[10];
      if (dirty[0] & /*activeCommandId*/
      2) chatview_changes.activeCommandId = /*activeCommandId*/
      ctx2[1];
      if (!updating_userPrompt && dirty[0] & /*userPrompt*/
      64) {
        updating_userPrompt = true;
        chatview_changes.userPrompt = /*userPrompt*/
        ctx2[6];
        add_flush_callback(() => updating_userPrompt = false);
      }
      chatview.$set(chatview_changes);
      if (
        /*status*/
        ctx2[2] === "streaming"
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block3(ctx2);
          if_block3.c();
          if_block3.m(div3, null);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      const settingsdrawer_changes = {};
      if (dirty[0] & /*plugin*/
      1) settingsdrawer_changes.plugin = /*plugin*/
      ctx2[0];
      if (!updating_open && dirty[0] & /*settingsOpen*/
      8) {
        updating_open = true;
        settingsdrawer_changes.open = /*settingsOpen*/
        ctx2[3];
        add_flush_callback(() => updating_open = false);
      }
      settingsdrawer.$set(settingsdrawer_changes);
    },
    i(local) {
      if (current) return;
      transition_in(if_block2);
      transition_in(chatview.$$.fragment, local);
      transition_in(settingsdrawer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block2);
      transition_out(chatview.$$.fragment, local);
      transition_out(settingsdrawer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (if_block2) if_block2.d();
      destroy_component(chatview);
      if (if_block3) if_block3.d();
      destroy_component(settingsdrawer);
      mounted = false;
      run_all(dispose);
    }
  };
}
function stripThinkingTags2(text2) {
  let cleaned = text2;
  cleaned = cleaned.replace(/<think>[\s\S]*?<\/think>/gi, "");
  cleaned = cleaned.replace(/<think>[\s\S]*?<think>/gi, "");
  cleaned = cleaned.replace(/<\/?think>/gi, "");
  return cleaned.trim();
}
function isObsidianCommandMessage(content) {
  return content.trim().startsWith("<obsidian_command>");
}
function cleanReferenceMarkers(text2, searchResults) {
  let cleaned = text2;
  cleaned = cleaned.replace(/\[REF\]web_search_results\.(\d+)\[\/REF\]/gi, (match, index) => {
    const idx = parseInt(index, 10);
    if ((searchResults === null || searchResults === void 0 ? void 0 : searchResults.results) && searchResults.results[idx]) {
      const result = searchResults.results[idx];
      return `[${result.title}](${result.url})`;
    }
    return "";
  });
  if (searchResults === null || searchResults === void 0 ? void 0 : searchResults.results) {
    cleaned = cleaned.replace(/\[Source Title\]\(([^)]+)\)/gi, (match, url) => {
      const result = searchResults.results.find((r) => r.url === url || url.includes(r.url) || r.url.includes(url));
      if (result) {
        return `[${result.title}](${result.url})`;
      }
      try {
        const domain = new URL(url).hostname.replace("www.", "");
        return `[${domain}](${url})`;
      } catch (_a) {
        return match;
      }
    });
  }
  return cleaned;
}
function instance3($$self, $$props, $$invalidate) {
  let activeCommand;
  let { plugin } = $$props;
  let { initialCommandId = void 0 } = $$props;
  const onClose = () => {
  };
  let handleClose = onClose;
  let activeCommandId = initialCommandId || "note_chat";
  let status = initialCommandId ? "sending" : "idle";
  let messages = [];
  let currentResponse = "";
  let userPrompt = "";
  let error = null;
  let settingsOpen = false;
  let searchStatus = "";
  let searchQueries = [];
  let webSearchResults;
  let abortController = null;
  let conversationSaved = false;
  let webSearchEnabled = plugin.settings.webSearch.enabled;
  function handleToggleWebSearch() {
    $$invalidate(12, webSearchEnabled = !webSearchEnabled);
    $$invalidate(0, plugin.settings.webSearch.enabled = webSearchEnabled, plugin);
    plugin.saveSettings();
  }
  function loadHistory() {
    if (!activeCommandId) return;
    const command = COMMANDS.find((c) => c.id === activeCommandId);
    if (!command) return;
    if (command.scope === "note" || command.scope === "vault") {
      const context = getEditorContext(plugin.app);
      if (context) {
        let thread;
        if (command.scope === "note") {
          thread = plugin.historyService.getNoteThread(context.note.path);
        } else {
          thread = plugin.historyService.getVaultThread();
        }
        $$invalidate(4, messages = thread.messages.filter((m) => m.role === "user" || m.role === "assistant").map((m) => ({ role: m.role, content: m.content })));
      }
    } else {
      $$invalidate(4, messages = []);
    }
  }
  async function runCommand() {
    var _a;
    if (status !== "sending" || !activeCommandId) return;
    const command = COMMANDS.find((c) => c.id === activeCommandId);
    if (!command) {
      $$invalidate(7, error = "Command not found");
      $$invalidate(2, status = "error");
      return;
    }
    const activeProvider = plugin.settings.activeProvider;
    const providerConfig = plugin.settings.providers[activeProvider];
    if (!providerConfig) {
      $$invalidate(7, error = `No configuration found for ${activeProvider}. Please configure it in settings.`);
      $$invalidate(2, status = "error");
      return;
    }
    if (activeProvider === "ollama") {
      if (!providerConfig.baseUrl) {
        $$invalidate(7, error = "Ollama URL not configured. Please set the Ollama server URL in settings (e.g., http://localhost:11434).");
        $$invalidate(2, status = "error");
        return;
      }
    } else {
      if (!providerConfig.apiKey) {
        $$invalidate(7, error = `API key not configured for ${activeProvider}. Please add your API key in settings.`);
        $$invalidate(2, status = "error");
        return;
      }
      if (!providerConfig.baseUrl) {
        $$invalidate(7, error = `Base URL not configured for ${activeProvider}. Please set the API endpoint in settings.`);
        $$invalidate(2, status = "error");
        return;
      }
    }
    if (!providerConfig.model) {
      $$invalidate(7, error = `No model selected for ${activeProvider}. Please select a model in settings.`);
      $$invalidate(2, status = "error");
      return;
    }
    let streamError = null;
    try {
      $$invalidate(2, status = "streaming");
      $$invalidate(5, currentResponse = "");
      abortController = new AbortController();
      let context = getEditorContext(plugin.app);
      if (!context && command.scope === "selection") {
        $$invalidate(7, error = `"${command.title}" requires selected text. Please select some text in a note first.`);
        $$invalidate(2, status = "error");
        return;
      }
      if (context && command.scope === "selection" && (!context.selection || !context.selection.text.trim())) {
        $$invalidate(7, error = `"${command.title}" requires selected text. Please select some text in a note first.`);
        $$invalidate(2, status = "error");
        return;
      }
      if (!context && command.scope === "note") {
        $$invalidate(7, error = `"${command.title}" requires an open note. Please open a note first.`);
        $$invalidate(2, status = "error");
        return;
      }
      if (webSearchEnabled) {
        $$invalidate(2, status = "searching");
        $$invalidate(8, searchStatus = "Generating web search query...");
        $$invalidate(9, searchQueries = []);
        $$invalidate(10, webSearchResults = void 0);
        try {
          const providerSettings2 = plugin.settings.providers[plugin.settings.activeProvider];
          const client2 = createProviderClient(plugin.settings.activeProvider, providerSettings2);
          const queryMessages = generateSearchQueryMessages(context, userPrompt, command.scope);
          let refinedQuery = "";
          const refineResponse = await client2.chat(
            {
              messages: queryMessages,
              model: providerSettings2.model,
              temperature: 0.1,
              // Strict factual
              stream: false
            },
            (event) => {
              if (event.type === "token") refinedQuery += event.value;
            },
            abortController.signal
          );
          if (!refinedQuery && refineResponse.content) {
            refinedQuery = refineResponse.content;
          }
          refinedQuery = refinedQuery.trim().replace(/^["']|["']$/g, "");
          console.log("Refined Search Query:", refinedQuery);
          if (refinedQuery) {
            $$invalidate(9, searchQueries = [refinedQuery]);
            $$invalidate(8, searchStatus = `Searching web...`);
            try {
              const results = await runSearxngSearch(refinedQuery, plugin.settings.webSearch);
              $$invalidate(10, webSearchResults = results);
              $$invalidate(8, searchStatus = `Found ${results.results.length} results.`);
            } catch (sErr) {
              console.error("SearXNG Search Failed:", sErr);
              $$invalidate(7, error = `Web Search Failed: ${sErr.message || "Unknown error"}`);
              $$invalidate(8, searchStatus = "Web search failed. Continuing...");
            }
          } else {
            $$invalidate(8, searchStatus = "\u26A0\uFE0F Could not generate a search query.");
          }
        } catch (e) {
          console.warn("Search workflow failed, proceeding without search:", e);
          $$invalidate(8, searchStatus = "");
          if (e.name !== "AbortError") {
          }
        }
      }
      $$invalidate(2, status = "streaming");
      const envelope = await buildPromptEnvelope(command, context, userPrompt, webSearchResults);
      const systemMsgContent = createSystemMessage();
      const userMsgContent = createUserMessage(envelope);
      let threadId;
      if (command.scope === "note" || command.scope === "vault") {
        let thread;
        if (command.scope === "note") {
          thread = plugin.historyService.getNoteThread(context.note.path);
        } else {
          thread = plugin.historyService.getVaultThread();
        }
        threadId = thread.id;
      }
      const messagesForAPI = [
        {
          role: "system",
          content: systemMsgContent
        },
        ...messages.map((m) => ({ role: m.role, content: m.content })),
        { role: "user", content: userMsgContent }
      ];
      const providerSettings = plugin.settings.providers[plugin.settings.activeProvider];
      const client = createProviderClient(plugin.settings.activeProvider, providerSettings);
      await client.chat(
        {
          messages: messagesForAPI,
          model: providerSettings.model,
          temperature: providerSettings.temperature || 0.7,
          stream: true
        },
        (event) => {
          if (event.type === "token") {
            $$invalidate(5, currentResponse += event.value);
          } else if (event.type === "error") {
            streamError = new Error(event.message);
            abortController === null || abortController === void 0 ? void 0 : abortController.abort();
          }
        },
        abortController.signal
      );
      if (streamError) {
        throw streamError;
      }
      const newMessageContext = context;
      $$invalidate(4, messages = [
        ...messages,
        { role: "user", content: userMsgContent },
        {
          role: "assistant",
          content: currentResponse,
          context: newMessageContext
        }
      ]);
      $$invalidate(2, status = "idle");
      $$invalidate(6, userPrompt = "");
      if (threadId) {
        plugin.historyService.addMessage(threadId, { role: "user", content: userMsgContent });
        plugin.historyService.addMessage(threadId, {
          role: "assistant",
          content: currentResponse
        });
      }
    } catch (err) {
      console.error("RunCommand Error:", err);
      if (err.name === "AbortError" || err.message === "Aborted") {
        if (streamError) {
          err = streamError;
        } else {
          $$invalidate(2, status = "idle");
          return;
        }
      }
      $$invalidate(5, currentResponse = "");
      let msg = err.message || "";
      if (err.code) msg += ` ${err.code}`;
      if (!msg && typeof err === "string") msg = err;
      let friendlyMessage = "An unexpected error occurred.";
      const streamMatch = msg.match(/Stream failed: (\d+) ([\s\S]*)/);
      if (streamMatch) {
        const code = parseInt(streamMatch[1]);
        const body = streamMatch[2];
        let remoteMsg = "";
        try {
          const jsonStart = body.indexOf("{");
          if (jsonStart !== -1) {
            const json = JSON.parse(body.substring(jsonStart));
            remoteMsg = ((_a = json.error) === null || _a === void 0 ? void 0 : _a.message) || json.message || "";
          }
        } catch (_b) {
        }
        switch (code) {
          case 401:
            friendlyMessage = "Authentication failed. Please check your API key in settings.";
            break;
          case 403:
            friendlyMessage = "Access denied. Please check your API key and permissions.";
            break;
          case 404:
            friendlyMessage = "The selected model is unavailable or the provider endpoint is incorrect.";
            break;
          case 429:
            friendlyMessage = "Rate limit exceeded. Please wait a moment or check your usage quota.";
            break;
          case 500:
          case 502:
          case 503:
          case 504:
            friendlyMessage = "The AI provider is currently unavailable. Please try again later.";
            break;
          default:
            if (remoteMsg) {
              if (remoteMsg.toLowerCase().includes("quota")) {
                friendlyMessage = "You have exceeded your API quota.";
              } else if (remoteMsg.length < 80) {
                friendlyMessage = remoteMsg;
              } else {
                friendlyMessage = `Provider error (${code}). Check console for details.`;
              }
            } else {
              friendlyMessage = `Connection failed (${code}).`;
            }
        }
      } else {
        const lowerMsg = msg.toLowerCase();
        if (lowerMsg.includes("enotfound") || lowerMsg.includes("econnrefused") || lowerMsg.includes("err_name_not_resolved") || lowerMsg.includes("failed to fetch") || lowerMsg.includes("timed out") || lowerMsg.includes("fetch failed")) {
          if (plugin.settings.activeProvider === "ollama") {
            friendlyMessage = "Unable to connect to Ollama. Ensure it is running (usually localhost:11434).";
          } else {
            friendlyMessage = "Network error. Please check your internet connection and API settings.";
          }
        } else if (lowerMsg.includes("invalid url")) {
          friendlyMessage = "The provider URL is invalid. Please check your settings.";
        } else {
          friendlyMessage = msg.length < 100 ? msg : "An error occurred while communicating with the AI provider.";
        }
      }
      $$invalidate(7, error = friendlyMessage);
      $$invalidate(2, status = "error");
    }
  }
  function handleCommandSelect(commandId) {
    const command = COMMANDS.find((c) => c.id === commandId);
    if (!command) return;
    $$invalidate(1, activeCommandId = commandId);
    $$invalidate(4, messages = []);
    $$invalidate(5, currentResponse = "");
    $$invalidate(7, error = null);
    $$invalidate(9, searchQueries = []);
    $$invalidate(10, webSearchResults = void 0);
    $$invalidate(8, searchStatus = "");
    loadHistory();
    if (command.scope === "selection" || command.delivery !== "chat_only") {
      $$invalidate(2, status = "sending");
    }
  }
  function handleSendMessage() {
    if (status === "error") {
      $$invalidate(7, error = null);
    }
    $$invalidate(2, status = "sending");
  }
  function handleStopGeneration() {
    if (abortController) {
      abortController.abort();
    }
  }
  function handleReset() {
    $$invalidate(4, messages = []);
    $$invalidate(5, currentResponse = "");
    $$invalidate(6, userPrompt = "");
    $$invalidate(7, error = null);
    $$invalidate(2, status = "idle");
    $$invalidate(1, activeCommandId = null);
    $$invalidate(9, searchQueries = []);
    $$invalidate(10, webSearchResults = void 0);
  }
  function handleClearHistory() {
    var _a;
    const command = activeCommand;
    if (command) {
      if (command.scope === "vault") {
        plugin.historyService.clearVaultThread();
      } else if (command.scope === "note") {
        const context = getEditorContext(plugin.app);
        if ((_a = context === null || context === void 0 ? void 0 : context.note) === null || _a === void 0 ? void 0 : _a.path) {
          plugin.historyService.clearNoteThread(context.note.path);
        }
      }
    } else {
      plugin.historyService.clearVaultThread();
    }
    handleReset();
  }
  function handleReplace(event) {
    const { context, text: text2 } = event.detail;
    const leaf = plugin.app.workspace.getLeavesOfType("markdown").find((leaf2) => {
      var _a;
      return ((_a = leaf2.view.file) === null || _a === void 0 ? void 0 : _a.path) === context.note.path;
    });
    if (leaf) {
      const view = leaf.view;
      if (context.selection) {
        const editor = view.editor;
        editor.replaceRange(text2, context.selection.from, context.selection.to);
      } else {
        const editor = view.editor;
        editor.replaceSelection(text2);
      }
    } else {
      $$invalidate(7, error = "Original note not open.");
    }
  }
  async function handleCreateNote(event) {
    const { content } = event.detail;
    let cleanContent = stripThinkingTags2(content);
    cleanContent = cleanContent.replace(/^##?\s*(Answer|Response|Reply):?\s*\n+/i, "").replace(/^(Certainly!?|Sure!?|Of course!?|Here('s| is| are))[^\n]*\n+/i, "").replace(/^(Below is|Here's|The following)[^\n]*:\n+/i, "").trim();
    let researchTitle = "";
    let h1Match = cleanContent.match(/^#\s+([^\n]+)/);
    if (h1Match) {
      researchTitle = h1Match[1].trim();
      cleanContent = cleanContent.replace(/^#\s+[^\n]+\n*/, "").trim();
    } else {
      h1Match = cleanContent.match(/^#\s+([^\n]+)/m);
      if (h1Match) {
        researchTitle = h1Match[1].trim();
        cleanContent = cleanContent.replace(/^#\s+[^\n]+\n*/m, "").trim();
      }
    }
    if (!researchTitle) {
      const firstCommandMsg = messages.find((m) => m.role === "user" && isObsidianCommandMessage(m.content));
      if (firstCommandMsg) {
        try {
          const jsonMatch = firstCommandMsg.content.match(/<obsidian_command>\s*([\s\S]*?)\s*<\/obsidian_command>/);
          if (jsonMatch) {
            const envelope = JSON.parse(jsonMatch[1]);
            if (envelope.user_prompt) {
              researchTitle = envelope.user_prompt.split("\n")[0].slice(0, 80);
            }
          }
        } catch (_a) {
        }
      }
    }
    let fileName = researchTitle.replace(/[\\/:*?"<>|]/g, "").replace(
      /\s+/g,
      " "
      // Normalize whitespace
    ).trim().slice(0, 100);
    if (!fileName) {
      fileName = `Research ${(/* @__PURE__ */ new Date()).toISOString().slice(0, 10)}`;
    }
    fileName += ".md";
    cleanContent = cleanReferenceMarkers(cleanContent, webSearchResults);
    const date = (/* @__PURE__ */ new Date()).toLocaleDateString("en-US", {
      year: "numeric",
      month: "long",
      day: "numeric"
    });
    const titleSection = researchTitle ? `# ${researchTitle}

` : "";
    const finalContent = `${titleSection}*Created on ${date}*

---

${cleanContent}`;
    try {
      const existingFile = plugin.app.vault.getAbstractFileByPath(fileName);
      if (existingFile) {
        $$invalidate(7, error = `A note named "${fileName}" already exists. Please choose a different name.`);
        return;
      }
      const newFile = await plugin.app.vault.create(fileName, finalContent);
      const leaf = plugin.app.workspace.getLeaf(false);
      await leaf.openFile(newFile);
    } catch (err) {
      console.error("Failed to create note:", err);
      $$invalidate(7, error = `Failed to create note: ${err.message || "Unknown error"}`);
    }
  }
  function openCommandPicker() {
    new CommandPickerModal(
      plugin,
      (commandId) => {
        handleCommandSelect(commandId);
      }
    ).open();
  }
  async function handleSaveConversation() {
    if (messages.length === 0) return;
    let noteTitle = "";
    const firstUserMsg = messages.find((m) => m.role === "user" && !isObsidianCommandMessage(m.content));
    const lastAssistantMsg = [...messages].reverse().find((m) => m.role === "assistant" && !isObsidianCommandMessage(m.content));
    if (lastAssistantMsg) {
      const h1Match = lastAssistantMsg.content.match(/^#\s+([^\n]+)/m);
      if (h1Match) {
        noteTitle = h1Match[1].trim();
      }
    }
    if (!noteTitle && firstUserMsg) {
      noteTitle = firstUserMsg.content.split("\n")[0].slice(0, 80);
    }
    if (!noteTitle) {
      noteTitle = `Conversation ${(/* @__PURE__ */ new Date()).toISOString().slice(0, 10)}`;
    }
    let fileName = noteTitle.replace(/[\\/:*?"<>|]/g, "").replace(
      /\s+/g,
      " "
      // Normalize whitespace
    ).trim().slice(0, 100);
    fileName += ".md";
    const content = formatConversationAsMarkdown(noteTitle);
    try {
      const existingFile = plugin.app.vault.getAbstractFileByPath(fileName);
      if (existingFile) {
        $$invalidate(7, error = `A note named "${fileName}" already exists. Please choose a different name.`);
        return;
      }
      const newFile = await plugin.app.vault.create(fileName, content);
      $$invalidate(11, conversationSaved = true);
      setTimeout(
        () => {
          $$invalidate(11, conversationSaved = false);
        },
        1500
      );
      const leaf = plugin.app.workspace.getLeaf(false);
      await leaf.openFile(newFile);
    } catch (err) {
      console.error("Failed to create note:", err);
      $$invalidate(7, error = `Failed to create note: ${err.message || "Unknown error"}`);
    }
  }
  function formatConversationAsMarkdown(title) {
    const lines = [];
    const date = (/* @__PURE__ */ new Date()).toLocaleDateString("en-US", {
      year: "numeric",
      month: "long",
      day: "numeric"
    });
    lines.push(`# ${title}`);
    lines.push(``);
    lines.push(`*Created on ${date}*`);
    lines.push(``);
    lines.push(`---`);
    lines.push(``);
    const assistantMessages = messages.filter((m) => m.role === "assistant" && !isObsidianCommandMessage(m.content));
    if (assistantMessages.length > 0) {
      let content = stripThinkingTags2(assistantMessages[assistantMessages.length - 1].content);
      content = content.replace(/^(Certainly!?|Sure!?|Of course!?|Here('s| is| are))[^\n]*\n+/i, "").replace(/^(Below is|Here's|The following)[^\n]*:\n+/i, "").replace(/^##?\s*(Answer|Response|Reply):?\s*\n+/i, "").trim();
      content = content.replace(/^#\s+[^\n]+\n+/, "");
      content = cleanReferenceMarkers(content, webSearchResults);
      lines.push(content);
    } else {
      for (const msg of messages) {
        if (isObsidianCommandMessage(msg.content)) continue;
        if (msg.role === "assistant") {
          let content = stripThinkingTags2(msg.content);
          content = cleanReferenceMarkers(content, webSearchResults);
          lines.push(content);
          lines.push(``);
        }
      }
    }
    if (webSearchResults && webSearchResults.results.length > 0) {
      lines.push(``);
      lines.push(`---`);
      lines.push(``);
      lines.push(`## Sources`);
      lines.push(``);
      for (const result of webSearchResults.results) {
        lines.push(`- [${result.title}](${result.url})`);
      }
      lines.push(``);
    }
    return lines.join("\n");
  }
  const click_handler = () => $$invalidate(3, settingsOpen = true);
  const click_handler_1 = () => $$invalidate(7, error = null);
  function chatview_userPrompt_binding(value) {
    userPrompt = value;
    $$invalidate(6, userPrompt);
  }
  function settingsdrawer_open_binding(value) {
    settingsOpen = value;
    $$invalidate(3, settingsOpen);
  }
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2) $$invalidate(0, plugin = $$props2.plugin);
    if ("initialCommandId" in $$props2) $$invalidate(23, initialCommandId = $$props2.initialCommandId);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*initialCommandId*/
    8388608) {
      $: if (initialCommandId) {
        handleCommandSelect(initialCommandId);
        $$invalidate(23, initialCommandId = void 0);
      }
    }
    if ($$self.$$.dirty[0] & /*settingsOpen, plugin*/
    9) {
      $: if (!settingsOpen) {
        $$invalidate(12, webSearchEnabled = plugin.settings.webSearch.enabled);
      }
    }
    if ($$self.$$.dirty[0] & /*activeCommandId*/
    2) {
      $: $$invalidate(13, activeCommand = COMMANDS.find((c) => c.id === activeCommandId));
    }
    if ($$self.$$.dirty[0] & /*status*/
    4) {
      $: if (status === "sending") {
        runCommand();
      }
    }
  };
  return [
    plugin,
    activeCommandId,
    status,
    settingsOpen,
    messages,
    currentResponse,
    userPrompt,
    error,
    searchStatus,
    searchQueries,
    webSearchResults,
    conversationSaved,
    webSearchEnabled,
    activeCommand,
    handleToggleWebSearch,
    handleSendMessage,
    handleStopGeneration,
    handleReset,
    handleClearHistory,
    handleReplace,
    handleCreateNote,
    openCommandPicker,
    handleSaveConversation,
    initialCommandId,
    onClose,
    click_handler,
    click_handler_1,
    chatview_userPrompt_binding,
    settingsdrawer_open_binding
  ];
}
var App2 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance3,
      create_fragment3,
      safe_not_equal,
      {
        plugin: 0,
        initialCommandId: 23,
        onClose: 24
      },
      null,
      [-1, -1]
    );
  }
  get onClose() {
    return this.$$.ctx[24];
  }
};
var App_default = App2;

// src/ui/view.ts
var VIEW_TYPE_AI_ASSISTANT = "ai-assistant-view";
var AiAssistantView = class extends import_obsidian7.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_AI_ASSISTANT;
  }
  getDisplayText() {
    return "AI Assistant";
  }
  getIcon() {
    return "bot";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("h-full");
    container.addClass("ai-assistant-view-root");
    this.component = new App_default({
      target: container,
      props: {
        plugin: this.plugin,
        onClose: () => {
        }
      }
    });
  }
  setCommand(commandId) {
    if (this.component) {
      this.component.$set({ initialCommandId: commandId });
    }
  }
  async onClose() {
    if (this.component) {
      this.component.$destroy();
    }
  }
};

// src/main.ts
var AiAssistantPlugin = class extends import_obsidian8.Plugin {
  constructor(app, manifest) {
    super(app, manifest);
    this.settings = JSON.parse(JSON.stringify(DEFAULT_SETTINGS));
  }
  async onload() {
    console.log("Loading AI Assistant Plugin...");
    await this.loadSettings();
    this.registerView(
      VIEW_TYPE_AI_ASSISTANT,
      (leaf) => new AiAssistantView(leaf, this)
    );
    const data = await this.loadData();
    const loadedSettings = (data == null ? void 0 : data.settings) || {};
    this.settings = {
      ...DEFAULT_SETTINGS,
      ...loadedSettings,
      providers: {
        ...DEFAULT_SETTINGS.providers,
        ...loadedSettings.providers || {}
      },
      webSearch: {
        ...DEFAULT_SETTINGS.webSearch,
        ...loadedSettings.webSearch || {}
      },
      history: {
        ...DEFAULT_SETTINGS.history,
        ...loadedSettings.history || {}
      },
      ui: {
        ...DEFAULT_SETTINGS.ui,
        ...loadedSettings.ui || {}
      }
    };
    this.historyService = new HistoryService(this, data == null ? void 0 : data.historyStore);
    this.addRibbonIcon("bot", "AI Assistant", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-ai-assistant",
      name: "Open AI Assistant",
      callback: () => {
        this.activateView();
      }
    });
    COMMANDS.forEach((cmd) => {
      this.addCommand({
        id: cmd.id,
        name: cmd.title,
        editorCallback: (editor, view) => {
          this.activateView(cmd.id);
        }
      });
    });
  }
  async activateView(commandId) {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_AI_ASSISTANT);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({ type: VIEW_TYPE_AI_ASSISTANT, active: true });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
      if (commandId) {
        const view = leaf.view;
        view.setCommand(commandId);
      }
    }
  }
  async onunload() {
    await this.saveSettings();
  }
  async loadSettings() {
  }
  async saveSettings() {
    await this.saveData({
      settings: this.settings,
      historyStore: this.historyService.getStore()
    });
  }
};
