/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/nunjucks/browser/nunjucks.js
var require_nunjucks = __commonJS({
  "node_modules/nunjucks/browser/nunjucks.js"(exports, module2) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module2 === "object")
        module2.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports === "object")
        exports["nunjucks"] = factory();
      else
        root["nunjucks"] = factory();
    })(typeof self !== "undefined" ? self : exports, function() {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module3 = installedModules[moduleId] = {
              /******/
              i: moduleId,
              /******/
              l: false,
              /******/
              exports: {}
              /******/
            };
            modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
            module3.l = true;
            return module3.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.d = function(exports2, name, getter) {
            if (!__webpack_require__.o(exports2, name)) {
              Object.defineProperty(exports2, name, {
                /******/
                configurable: false,
                /******/
                enumerable: true,
                /******/
                get: getter
                /******/
              });
            }
          };
          __webpack_require__.n = function(module3) {
            var getter = module3 && module3.__esModule ? (
              /******/
              function getDefault() {
                return module3["default"];
              }
            ) : (
              /******/
              function getModuleExports() {
                return module3;
              }
            );
            __webpack_require__.d(getter, "a", getter);
            return getter;
          };
          __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __webpack_require__.p = "";
          return __webpack_require__(__webpack_require__.s = 11);
        }([
          /* 0 */
          /***/
          function(module3, exports2, __webpack_require__) {
            "use strict";
            var ArrayProto = Array.prototype;
            var ObjProto = Object.prototype;
            var escapeMap = {
              "&": "&amp;",
              '"': "&quot;",
              "'": "&#39;",
              "<": "&lt;",
              ">": "&gt;",
              "\\": "&#92;"
            };
            var escapeRegex = /[&"'<>\\]/g;
            var exports2 = module3.exports = {};
            function hasOwnProp(obj, k) {
              return ObjProto.hasOwnProperty.call(obj, k);
            }
            exports2.hasOwnProp = hasOwnProp;
            function lookupEscape(ch) {
              return escapeMap[ch];
            }
            function _prettifyError(path, withInternals, err) {
              if (!err.Update) {
                err = new exports2.TemplateError(err);
              }
              err.Update(path);
              if (!withInternals) {
                var old = err;
                err = new Error(old.message);
                err.name = old.name;
              }
              return err;
            }
            exports2._prettifyError = _prettifyError;
            function TemplateError(message, lineno, colno) {
              var err;
              var cause;
              if (message instanceof Error) {
                cause = message;
                message = cause.name + ": " + cause.message;
              }
              if (Object.setPrototypeOf) {
                err = new Error(message);
                Object.setPrototypeOf(err, TemplateError.prototype);
              } else {
                err = this;
                Object.defineProperty(err, "message", {
                  enumerable: false,
                  writable: true,
                  value: message
                });
              }
              Object.defineProperty(err, "name", {
                value: "Template render error"
              });
              if (Error.captureStackTrace) {
                Error.captureStackTrace(err, this.constructor);
              }
              var getStack;
              if (cause) {
                var stackDescriptor = Object.getOwnPropertyDescriptor(cause, "stack");
                getStack = stackDescriptor && (stackDescriptor.get || function() {
                  return stackDescriptor.value;
                });
                if (!getStack) {
                  getStack = function getStack2() {
                    return cause.stack;
                  };
                }
              } else {
                var stack = new Error(message).stack;
                getStack = function getStack2() {
                  return stack;
                };
              }
              Object.defineProperty(err, "stack", {
                get: function get() {
                  return getStack.call(err);
                }
              });
              Object.defineProperty(err, "cause", {
                value: cause
              });
              err.lineno = lineno;
              err.colno = colno;
              err.firstUpdate = true;
              err.Update = function Update(path) {
                var msg = "(" + (path || "unknown path") + ")";
                if (this.firstUpdate) {
                  if (this.lineno && this.colno) {
                    msg += " [Line " + this.lineno + ", Column " + this.colno + "]";
                  } else if (this.lineno) {
                    msg += " [Line " + this.lineno + "]";
                  }
                }
                msg += "\n ";
                if (this.firstUpdate) {
                  msg += " ";
                }
                this.message = msg + (this.message || "");
                this.firstUpdate = false;
                return this;
              };
              return err;
            }
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(TemplateError.prototype, Error.prototype);
            } else {
              TemplateError.prototype = Object.create(Error.prototype, {
                constructor: {
                  value: TemplateError
                }
              });
            }
            exports2.TemplateError = TemplateError;
            function escape2(val) {
              return val.replace(escapeRegex, lookupEscape);
            }
            exports2.escape = escape2;
            function isFunction(obj) {
              return ObjProto.toString.call(obj) === "[object Function]";
            }
            exports2.isFunction = isFunction;
            function isArray(obj) {
              return ObjProto.toString.call(obj) === "[object Array]";
            }
            exports2.isArray = isArray;
            function isString(obj) {
              return ObjProto.toString.call(obj) === "[object String]";
            }
            exports2.isString = isString;
            function isObject(obj) {
              return ObjProto.toString.call(obj) === "[object Object]";
            }
            exports2.isObject = isObject;
            function _prepareAttributeParts(attr2) {
              if (!attr2) {
                return [];
              }
              if (typeof attr2 === "string") {
                return attr2.split(".");
              }
              return [attr2];
            }
            function getAttrGetter(attribute) {
              var parts = _prepareAttributeParts(attribute);
              return function attrGetter(item) {
                var _item = item;
                for (var i = 0; i < parts.length; i++) {
                  var part = parts[i];
                  if (hasOwnProp(_item, part)) {
                    _item = _item[part];
                  } else {
                    return void 0;
                  }
                }
                return _item;
              };
            }
            exports2.getAttrGetter = getAttrGetter;
            function groupBy(obj, val, throwOnUndefined) {
              var result = {};
              var iterator = isFunction(val) ? val : getAttrGetter(val);
              for (var i = 0; i < obj.length; i++) {
                var value = obj[i];
                var key = iterator(value, i);
                if (key === void 0 && throwOnUndefined === true) {
                  throw new TypeError('groupby: attribute "' + val + '" resolved to undefined');
                }
                (result[key] || (result[key] = [])).push(value);
              }
              return result;
            }
            exports2.groupBy = groupBy;
            function toArray(obj) {
              return Array.prototype.slice.call(obj);
            }
            exports2.toArray = toArray;
            function without(array) {
              var result = [];
              if (!array) {
                return result;
              }
              var length = array.length;
              var contains = toArray(arguments).slice(1);
              var index = -1;
              while (++index < length) {
                if (indexOf(contains, array[index]) === -1) {
                  result.push(array[index]);
                }
              }
              return result;
            }
            exports2.without = without;
            function repeat(char_, n) {
              var str = "";
              for (var i = 0; i < n; i++) {
                str += char_;
              }
              return str;
            }
            exports2.repeat = repeat;
            function each(obj, func, context) {
              if (obj == null) {
                return;
              }
              if (ArrayProto.forEach && obj.forEach === ArrayProto.forEach) {
                obj.forEach(func, context);
              } else if (obj.length === +obj.length) {
                for (var i = 0, l = obj.length; i < l; i++) {
                  func.call(context, obj[i], i, obj);
                }
              }
            }
            exports2.each = each;
            function map(obj, func) {
              var results = [];
              if (obj == null) {
                return results;
              }
              if (ArrayProto.map && obj.map === ArrayProto.map) {
                return obj.map(func);
              }
              for (var i = 0; i < obj.length; i++) {
                results[results.length] = func(obj[i], i);
              }
              if (obj.length === +obj.length) {
                results.length = obj.length;
              }
              return results;
            }
            exports2.map = map;
            function asyncIter(arr, iter, cb) {
              var i = -1;
              function next() {
                i++;
                if (i < arr.length) {
                  iter(arr[i], i, next, cb);
                } else {
                  cb();
                }
              }
              next();
            }
            exports2.asyncIter = asyncIter;
            function asyncFor(obj, iter, cb) {
              var keys = keys_(obj || {});
              var len = keys.length;
              var i = -1;
              function next() {
                i++;
                var k = keys[i];
                if (i < len) {
                  iter(k, obj[k], i, len, next);
                } else {
                  cb();
                }
              }
              next();
            }
            exports2.asyncFor = asyncFor;
            function indexOf(arr, searchElement, fromIndex) {
              return Array.prototype.indexOf.call(arr || [], searchElement, fromIndex);
            }
            exports2.indexOf = indexOf;
            function keys_(obj) {
              var arr = [];
              for (var k in obj) {
                if (hasOwnProp(obj, k)) {
                  arr.push(k);
                }
              }
              return arr;
            }
            exports2.keys = keys_;
            function _entries(obj) {
              return keys_(obj).map(function(k) {
                return [k, obj[k]];
              });
            }
            exports2._entries = _entries;
            function _values(obj) {
              return keys_(obj).map(function(k) {
                return obj[k];
              });
            }
            exports2._values = _values;
            function extend(obj1, obj2) {
              obj1 = obj1 || {};
              keys_(obj2).forEach(function(k) {
                obj1[k] = obj2[k];
              });
              return obj1;
            }
            exports2._assign = exports2.extend = extend;
            function inOperator(key, val) {
              if (isArray(val) || isString(val)) {
                return val.indexOf(key) !== -1;
              } else if (isObject(val)) {
                return key in val;
              }
              throw new Error('Cannot use "in" operator to search for "' + key + '" in unexpected types.');
            }
            exports2.inOperator = inOperator;
          },
          /* 1 */
          /***/
          function(module3, exports2, __webpack_require__) {
            "use strict";
            function _defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
              }
            }
            function _createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                _defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                _defineProperties(Constructor, staticProps);
              Object.defineProperty(Constructor, "prototype", { writable: false });
              return Constructor;
            }
            function _toPropertyKey(arg) {
              var key = _toPrimitive(arg, "string");
              return typeof key === "symbol" ? key : String(key);
            }
            function _toPrimitive(input, hint) {
              if (typeof input !== "object" || input === null)
                return input;
              var prim = input[Symbol.toPrimitive];
              if (prim !== void 0) {
                var res = prim.call(input, hint || "default");
                if (typeof res !== "object")
                  return res;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return (hint === "string" ? String : Number)(input);
            }
            function _inheritsLoose(subClass, superClass) {
              subClass.prototype = Object.create(superClass.prototype);
              subClass.prototype.constructor = subClass;
              _setPrototypeOf(subClass, superClass);
            }
            function _setPrototypeOf(o, p) {
              _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return _setPrototypeOf(o, p);
            }
            var EventEmitter = __webpack_require__(16);
            var lib = __webpack_require__(0);
            function parentWrap(parent, prop) {
              if (typeof parent !== "function" || typeof prop !== "function") {
                return prop;
              }
              return function wrap() {
                var tmp = this.parent;
                this.parent = parent;
                var res = prop.apply(this, arguments);
                this.parent = tmp;
                return res;
              };
            }
            function extendClass(cls, name, props) {
              props = props || {};
              lib.keys(props).forEach(function(k) {
                props[k] = parentWrap(cls.prototype[k], props[k]);
              });
              var subclass = /* @__PURE__ */ function(_cls) {
                _inheritsLoose(subclass2, _cls);
                function subclass2() {
                  return _cls.apply(this, arguments) || this;
                }
                _createClass(subclass2, [{
                  key: "typename",
                  get: function get() {
                    return name;
                  }
                }]);
                return subclass2;
              }(cls);
              lib._assign(subclass.prototype, props);
              return subclass;
            }
            var Obj = /* @__PURE__ */ function() {
              function Obj2() {
                this.init.apply(this, arguments);
              }
              var _proto = Obj2.prototype;
              _proto.init = function init2() {
              };
              Obj2.extend = function extend(name, props) {
                if (typeof name === "object") {
                  props = name;
                  name = "anonymous";
                }
                return extendClass(this, name, props);
              };
              _createClass(Obj2, [{
                key: "typename",
                get: function get() {
                  return this.constructor.name;
                }
              }]);
              return Obj2;
            }();
            var EmitterObj = /* @__PURE__ */ function(_EventEmitter) {
              _inheritsLoose(EmitterObj2, _EventEmitter);
              function EmitterObj2() {
                var _this2;
                var _this;
                _this = _EventEmitter.call(this) || this;
                (_this2 = _this).init.apply(_this2, arguments);
                return _this;
              }
              var _proto2 = EmitterObj2.prototype;
              _proto2.init = function init2() {
              };
              EmitterObj2.extend = function extend(name, props) {
                if (typeof name === "object") {
                  props = name;
                  name = "anonymous";
                }
                return extendClass(this, name, props);
              };
              _createClass(EmitterObj2, [{
                key: "typename",
                get: function get() {
                  return this.constructor.name;
                }
              }]);
              return EmitterObj2;
            }(EventEmitter);
            module3.exports = {
              Obj,
              EmitterObj
            };
          },
          /* 2 */
          /***/
          function(module3, exports2, __webpack_require__) {
            "use strict";
            var lib = __webpack_require__(0);
            var arrayFrom = Array.from;
            var supportsIterators = typeof Symbol === "function" && Symbol.iterator && typeof arrayFrom === "function";
            var Frame = /* @__PURE__ */ function() {
              function Frame2(parent, isolateWrites) {
                this.variables = /* @__PURE__ */ Object.create(null);
                this.parent = parent;
                this.topLevel = false;
                this.isolateWrites = isolateWrites;
              }
              var _proto = Frame2.prototype;
              _proto.set = function set(name, val, resolveUp) {
                var parts = name.split(".");
                var obj = this.variables;
                var frame = this;
                if (resolveUp) {
                  if (frame = this.resolve(parts[0], true)) {
                    frame.set(name, val);
                    return;
                  }
                }
                for (var i = 0; i < parts.length - 1; i++) {
                  var id = parts[i];
                  if (!obj[id]) {
                    obj[id] = {};
                  }
                  obj = obj[id];
                }
                obj[parts[parts.length - 1]] = val;
              };
              _proto.get = function get(name) {
                var val = this.variables[name];
                if (val !== void 0) {
                  return val;
                }
                return null;
              };
              _proto.lookup = function lookup(name) {
                var p = this.parent;
                var val = this.variables[name];
                if (val !== void 0) {
                  return val;
                }
                return p && p.lookup(name);
              };
              _proto.resolve = function resolve(name, forWrite) {
                var p = forWrite && this.isolateWrites ? void 0 : this.parent;
                var val = this.variables[name];
                if (val !== void 0) {
                  return this;
                }
                return p && p.resolve(name);
              };
              _proto.push = function push(isolateWrites) {
                return new Frame2(this, isolateWrites);
              };
              _proto.pop = function pop() {
                return this.parent;
              };
              return Frame2;
            }();
            function makeMacro(argNames, kwargNames, func) {
              return function macro() {
                for (var _len = arguments.length, macroArgs = new Array(_len), _key = 0; _key < _len; _key++) {
                  macroArgs[_key] = arguments[_key];
                }
                var argCount = numArgs(macroArgs);
                var args;
                var kwargs = getKeywordArgs(macroArgs);
                if (argCount > argNames.length) {
                  args = macroArgs.slice(0, argNames.length);
                  macroArgs.slice(args.length, argCount).forEach(function(val, i2) {
                    if (i2 < kwargNames.length) {
                      kwargs[kwargNames[i2]] = val;
                    }
                  });
                  args.push(kwargs);
                } else if (argCount < argNames.length) {
                  args = macroArgs.slice(0, argCount);
                  for (var i = argCount; i < argNames.length; i++) {
                    var arg = argNames[i];
                    args.push(kwargs[arg]);
                    delete kwargs[arg];
                  }
                  args.push(kwargs);
                } else {
                  args = macroArgs;
                }
                return func.apply(this, args);
              };
            }
            function makeKeywordArgs(obj) {
              obj.__keywords = true;
              return obj;
            }
            function isKeywordArgs(obj) {
              return obj && Object.prototype.hasOwnProperty.call(obj, "__keywords");
            }
            function getKeywordArgs(args) {
              var len = args.length;
              if (len) {
                var lastArg = args[len - 1];
                if (isKeywordArgs(lastArg)) {
                  return lastArg;
                }
              }
              return {};
            }
            function numArgs(args) {
              var len = args.length;
              if (len === 0) {
                return 0;
              }
              var lastArg = args[len - 1];
              if (isKeywordArgs(lastArg)) {
                return len - 1;
              } else {
                return len;
              }
            }
            function SafeString(val) {
              if (typeof val !== "string") {
                return val;
              }
              this.val = val;
              this.length = val.length;
            }
            SafeString.prototype = Object.create(String.prototype, {
              length: {
                writable: true,
                configurable: true,
                value: 0
              }
            });
            SafeString.prototype.valueOf = function valueOf() {
              return this.val;
            };
            SafeString.prototype.toString = function toString() {
              return this.val;
            };
            function copySafeness(dest, target) {
              if (dest instanceof SafeString) {
                return new SafeString(target);
              }
              return target.toString();
            }
            function markSafe(val) {
              var type = typeof val;
              if (type === "string") {
                return new SafeString(val);
              } else if (type !== "function") {
                return val;
              } else {
                return function wrapSafe(args) {
                  var ret = val.apply(this, arguments);
                  if (typeof ret === "string") {
                    return new SafeString(ret);
                  }
                  return ret;
                };
              }
            }
            function suppressValue(val, autoescape) {
              val = val !== void 0 && val !== null ? val : "";
              if (autoescape && !(val instanceof SafeString)) {
                val = lib.escape(val.toString());
              }
              return val;
            }
            function ensureDefined(val, lineno, colno) {
              if (val === null || val === void 0) {
                throw new lib.TemplateError("attempted to output null or undefined value", lineno + 1, colno + 1);
              }
              return val;
            }
            function memberLookup(obj, val) {
              if (obj === void 0 || obj === null) {
                return void 0;
              }
              if (typeof obj[val] === "function") {
                return function() {
                  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                    args[_key2] = arguments[_key2];
                  }
                  return obj[val].apply(obj, args);
                };
              }
              return obj[val];
            }
            function callWrap(obj, name, context, args) {
              if (!obj) {
                throw new Error("Unable to call `" + name + "`, which is undefined or falsey");
              } else if (typeof obj !== "function") {
                throw new Error("Unable to call `" + name + "`, which is not a function");
              }
              return obj.apply(context, args);
            }
            function contextOrFrameLookup(context, frame, name) {
              var val = frame.lookup(name);
              return val !== void 0 ? val : context.lookup(name);
            }
            function handleError(error, lineno, colno) {
              if (error.lineno) {
                return error;
              } else {
                return new lib.TemplateError(error, lineno, colno);
              }
            }
            function asyncEach(arr, dimen, iter, cb) {
              if (lib.isArray(arr)) {
                var len = arr.length;
                lib.asyncIter(arr, function iterCallback(item, i, next) {
                  switch (dimen) {
                    case 1:
                      iter(item, i, len, next);
                      break;
                    case 2:
                      iter(item[0], item[1], i, len, next);
                      break;
                    case 3:
                      iter(item[0], item[1], item[2], i, len, next);
                      break;
                    default:
                      item.push(i, len, next);
                      iter.apply(this, item);
                  }
                }, cb);
              } else {
                lib.asyncFor(arr, function iterCallback(key, val, i, len2, next) {
                  iter(key, val, i, len2, next);
                }, cb);
              }
            }
            function asyncAll(arr, dimen, func, cb) {
              var finished = 0;
              var len;
              var outputArr;
              function done(i2, output) {
                finished++;
                outputArr[i2] = output;
                if (finished === len) {
                  cb(null, outputArr.join(""));
                }
              }
              if (lib.isArray(arr)) {
                len = arr.length;
                outputArr = new Array(len);
                if (len === 0) {
                  cb(null, "");
                } else {
                  for (var i = 0; i < arr.length; i++) {
                    var item = arr[i];
                    switch (dimen) {
                      case 1:
                        func(item, i, len, done);
                        break;
                      case 2:
                        func(item[0], item[1], i, len, done);
                        break;
                      case 3:
                        func(item[0], item[1], item[2], i, len, done);
                        break;
                      default:
                        item.push(i, len, done);
                        func.apply(this, item);
                    }
                  }
                }
              } else {
                var keys = lib.keys(arr || {});
                len = keys.length;
                outputArr = new Array(len);
                if (len === 0) {
                  cb(null, "");
                } else {
                  for (var _i = 0; _i < keys.length; _i++) {
                    var k = keys[_i];
                    func(k, arr[k], _i, len, done);
                  }
                }
              }
            }
            function fromIterator(arr) {
              if (typeof arr !== "object" || arr === null || lib.isArray(arr)) {
                return arr;
              } else if (supportsIterators && Symbol.iterator in arr) {
                return arrayFrom(arr);
              } else {
                return arr;
              }
            }
            module3.exports = {
              Frame,
              makeMacro,
              makeKeywordArgs,
              numArgs,
              suppressValue,
              ensureDefined,
              memberLookup,
              contextOrFrameLookup,
              callWrap,
              handleError,
              isArray: lib.isArray,
              keys: lib.keys,
              SafeString,
              copySafeness,
              markSafe,
              asyncEach,
              asyncAll,
              inOperator: lib.inOperator,
              fromIterator
            };
          },
          /* 3 */
          /***/
          function(module3, exports2, __webpack_require__) {
            "use strict";
            function _defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
              }
            }
            function _createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                _defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                _defineProperties(Constructor, staticProps);
              Object.defineProperty(Constructor, "prototype", { writable: false });
              return Constructor;
            }
            function _toPropertyKey(arg) {
              var key = _toPrimitive(arg, "string");
              return typeof key === "symbol" ? key : String(key);
            }
            function _toPrimitive(input, hint) {
              if (typeof input !== "object" || input === null)
                return input;
              var prim = input[Symbol.toPrimitive];
              if (prim !== void 0) {
                var res = prim.call(input, hint || "default");
                if (typeof res !== "object")
                  return res;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return (hint === "string" ? String : Number)(input);
            }
            function _inheritsLoose(subClass, superClass) {
              subClass.prototype = Object.create(superClass.prototype);
              subClass.prototype.constructor = subClass;
              _setPrototypeOf(subClass, superClass);
            }
            function _setPrototypeOf(o, p) {
              _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return _setPrototypeOf(o, p);
            }
            var _require = __webpack_require__(1), Obj = _require.Obj;
            function traverseAndCheck(obj, type, results) {
              if (obj instanceof type) {
                results.push(obj);
              }
              if (obj instanceof Node) {
                obj.findAll(type, results);
              }
            }
            var Node = /* @__PURE__ */ function(_Obj) {
              _inheritsLoose(Node2, _Obj);
              function Node2() {
                return _Obj.apply(this, arguments) || this;
              }
              var _proto = Node2.prototype;
              _proto.init = function init2(lineno, colno) {
                var _arguments = arguments, _this = this;
                for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                  args[_key - 2] = arguments[_key];
                }
                this.lineno = lineno;
                this.colno = colno;
                this.fields.forEach(function(field, i) {
                  var val = _arguments[i + 2];
                  if (val === void 0) {
                    val = null;
                  }
                  _this[field] = val;
                });
              };
              _proto.findAll = function findAll(type, results) {
                var _this2 = this;
                results = results || [];
                if (this instanceof NodeList) {
                  this.children.forEach(function(child) {
                    return traverseAndCheck(child, type, results);
                  });
                } else {
                  this.fields.forEach(function(field) {
                    return traverseAndCheck(_this2[field], type, results);
                  });
                }
                return results;
              };
              _proto.iterFields = function iterFields(func) {
                var _this3 = this;
                this.fields.forEach(function(field) {
                  func(_this3[field], field);
                });
              };
              return Node2;
            }(Obj);
            var Value = /* @__PURE__ */ function(_Node) {
              _inheritsLoose(Value2, _Node);
              function Value2() {
                return _Node.apply(this, arguments) || this;
              }
              _createClass(Value2, [{
                key: "typename",
                get: function get() {
                  return "Value";
                }
              }, {
                key: "fields",
                get: function get() {
                  return ["value"];
                }
              }]);
              return Value2;
            }(Node);
            var NodeList = /* @__PURE__ */ function(_Node2) {
              _inheritsLoose(NodeList2, _Node2);
              function NodeList2() {
                return _Node2.apply(this, arguments) || this;
              }
              var _proto2 = NodeList2.prototype;
              _proto2.init = function init2(lineno, colno, nodes) {
                _Node2.prototype.init.call(this, lineno, colno, nodes || []);
              };
              _proto2.addChild = function addChild(node) {
                this.children.push(node);
              };
              _createClass(NodeList2, [{
                key: "typename",
                get: function get() {
                  return "NodeList";
                }
              }, {
                key: "fields",
                get: function get() {
                  return ["children"];
                }
              }]);
              return NodeList2;
            }(Node);
            var Root = NodeList.extend("Root");
            var Literal = Value.extend("Literal");
            var _Symbol = Value.extend("Symbol");
            var Group = NodeList.extend("Group");
            var ArrayNode = NodeList.extend("Array");
            var Pair = Node.extend("Pair", {
              fields: ["key", "value"]
            });
            var Dict = NodeList.extend("Dict");
            var LookupVal = Node.extend("LookupVal", {
              fields: ["target", "val"]
            });
            var If = Node.extend("If", {
              fields: ["cond", "body", "else_"]
            });
            var IfAsync = If.extend("IfAsync");
            var InlineIf = Node.extend("InlineIf", {
              fields: ["cond", "body", "else_"]
            });
            var For = Node.extend("For", {
              fields: ["arr", "name", "body", "else_"]
            });
            var AsyncEach = For.extend("AsyncEach");
            var AsyncAll = For.extend("AsyncAll");
            var Macro = Node.extend("Macro", {
              fields: ["name", "args", "body"]
            });
            var Caller = Macro.extend("Caller");
            var Import = Node.extend("Import", {
              fields: ["template", "target", "withContext"]
            });
            var FromImport = /* @__PURE__ */ function(_Node3) {
              _inheritsLoose(FromImport2, _Node3);
              function FromImport2() {
                return _Node3.apply(this, arguments) || this;
              }
              var _proto3 = FromImport2.prototype;
              _proto3.init = function init2(lineno, colno, template, names, withContext) {
                _Node3.prototype.init.call(this, lineno, colno, template, names || new NodeList(), withContext);
              };
              _createClass(FromImport2, [{
                key: "typename",
                get: function get() {
                  return "FromImport";
                }
              }, {
                key: "fields",
                get: function get() {
                  return ["template", "names", "withContext"];
                }
              }]);
              return FromImport2;
            }(Node);
            var FunCall = Node.extend("FunCall", {
              fields: ["name", "args"]
            });
            var Filter = FunCall.extend("Filter");
            var FilterAsync = Filter.extend("FilterAsync", {
              fields: ["name", "args", "symbol"]
            });
            var KeywordArgs = Dict.extend("KeywordArgs");
            var Block = Node.extend("Block", {
              fields: ["name", "body"]
            });
            var Super = Node.extend("Super", {
              fields: ["blockName", "symbol"]
            });
            var TemplateRef = Node.extend("TemplateRef", {
              fields: ["template"]
            });
            var Extends = TemplateRef.extend("Extends");
            var Include = Node.extend("Include", {
              fields: ["template", "ignoreMissing"]
            });
            var Set2 = Node.extend("Set", {
              fields: ["targets", "value"]
            });
            var Switch = Node.extend("Switch", {
              fields: ["expr", "cases", "default"]
            });
            var Case = Node.extend("Case", {
              fields: ["cond", "body"]
            });
            var Output = NodeList.extend("Output");
            var Capture = Node.extend("Capture", {
              fields: ["body"]
            });
            var TemplateData = Literal.extend("TemplateData");
            var UnaryOp = Node.extend("UnaryOp", {
              fields: ["target"]
            });
            var BinOp = Node.extend("BinOp", {
              fields: ["left", "right"]
            });
            var In = BinOp.extend("In");
            var Is = BinOp.extend("Is");
            var Or = BinOp.extend("Or");
            var And = BinOp.extend("And");
            var Not = UnaryOp.extend("Not");
            var Add = BinOp.extend("Add");
            var Concat = BinOp.extend("Concat");
            var Sub = BinOp.extend("Sub");
            var Mul = BinOp.extend("Mul");
            var Div = BinOp.extend("Div");
            var FloorDiv = BinOp.extend("FloorDiv");
            var Mod = BinOp.extend("Mod");
            var Pow = BinOp.extend("Pow");
            var Neg = UnaryOp.extend("Neg");
            var Pos = UnaryOp.extend("Pos");
            var Compare = Node.extend("Compare", {
              fields: ["expr", "ops"]
            });
            var CompareOperand = Node.extend("CompareOperand", {
              fields: ["expr", "type"]
            });
            var CallExtension = Node.extend("CallExtension", {
              init: function init2(ext, prop, args, contentArgs) {
                this.parent();
                this.extName = ext.__name || ext;
                this.prop = prop;
                this.args = args || new NodeList();
                this.contentArgs = contentArgs || [];
                this.autoescape = ext.autoescape;
              },
              fields: ["extName", "prop", "args", "contentArgs"]
            });
            var CallExtensionAsync = CallExtension.extend("CallExtensionAsync");
            function print(str, indent, inline) {
              var lines = str.split("\n");
              lines.forEach(function(line, i) {
                if (line && (inline && i > 0 || !inline)) {
                  process.stdout.write(" ".repeat(indent));
                }
                var nl = i === lines.length - 1 ? "" : "\n";
                process.stdout.write("" + line + nl);
              });
            }
            function printNodes(node, indent) {
              indent = indent || 0;
              print(node.typename + ": ", indent);
              if (node instanceof NodeList) {
                print("\n");
                node.children.forEach(function(n) {
                  printNodes(n, indent + 2);
                });
              } else if (node instanceof CallExtension) {
                print(node.extName + "." + node.prop + "\n");
                if (node.args) {
                  printNodes(node.args, indent + 2);
                }
                if (node.contentArgs) {
                  node.contentArgs.forEach(function(n) {
                    printNodes(n, indent + 2);
                  });
                }
              } else {
                var nodes = [];
                var props = null;
                node.iterFields(function(val, fieldName) {
                  if (val instanceof Node) {
                    nodes.push([fieldName, val]);
                  } else {
                    props = props || {};
                    props[fieldName] = val;
                  }
                });
                if (props) {
                  print(JSON.stringify(props, null, 2) + "\n", null, true);
                } else {
                  print("\n");
                }
                nodes.forEach(function(_ref) {
                  var fieldName = _ref[0], n = _ref[1];
                  print("[" + fieldName + "] =>", indent + 2);
                  printNodes(n, indent + 4);
                });
              }
            }
            module3.exports = {
              Node,
              Root,
              NodeList,
              Value,
              Literal,
              Symbol: _Symbol,
              Group,
              Array: ArrayNode,
              Pair,
              Dict,
              Output,
              Capture,
              TemplateData,
              If,
              IfAsync,
              InlineIf,
              For,
              AsyncEach,
              AsyncAll,
              Macro,
              Caller,
              Import,
              FromImport,
              FunCall,
              Filter,
              FilterAsync,
              KeywordArgs,
              Block,
              Super,
              Extends,
              Include,
              Set: Set2,
              Switch,
              Case,
              LookupVal,
              BinOp,
              In,
              Is,
              Or,
              And,
              Not,
              Add,
              Concat,
              Sub,
              Mul,
              Div,
              FloorDiv,
              Mod,
              Pow,
              Neg,
              Pos,
              Compare,
              CompareOperand,
              CallExtension,
              CallExtensionAsync,
              printNodes
            };
          },
          /* 4 */
          /***/
          function(module3, exports2) {
          },
          /* 5 */
          /***/
          function(module3, exports2, __webpack_require__) {
            "use strict";
            function _inheritsLoose(subClass, superClass) {
              subClass.prototype = Object.create(superClass.prototype);
              subClass.prototype.constructor = subClass;
              _setPrototypeOf(subClass, superClass);
            }
            function _setPrototypeOf(o, p) {
              _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return _setPrototypeOf(o, p);
            }
            var parser = __webpack_require__(8);
            var transformer = __webpack_require__(17);
            var nodes = __webpack_require__(3);
            var _require = __webpack_require__(0), TemplateError = _require.TemplateError;
            var _require2 = __webpack_require__(2), Frame = _require2.Frame;
            var _require3 = __webpack_require__(1), Obj = _require3.Obj;
            var compareOps = {
              "==": "==",
              "===": "===",
              "!=": "!=",
              "!==": "!==",
              "<": "<",
              ">": ">",
              "<=": "<=",
              ">=": ">="
            };
            var Compiler = /* @__PURE__ */ function(_Obj) {
              _inheritsLoose(Compiler2, _Obj);
              function Compiler2() {
                return _Obj.apply(this, arguments) || this;
              }
              var _proto = Compiler2.prototype;
              _proto.init = function init2(templateName, throwOnUndefined) {
                this.templateName = templateName;
                this.codebuf = [];
                this.lastId = 0;
                this.buffer = null;
                this.bufferStack = [];
                this._scopeClosers = "";
                this.inBlock = false;
                this.throwOnUndefined = throwOnUndefined;
              };
              _proto.fail = function fail(msg, lineno, colno) {
                if (lineno !== void 0) {
                  lineno += 1;
                }
                if (colno !== void 0) {
                  colno += 1;
                }
                throw new TemplateError(msg, lineno, colno);
              };
              _proto._pushBuffer = function _pushBuffer() {
                var id = this._tmpid();
                this.bufferStack.push(this.buffer);
                this.buffer = id;
                this._emit("var " + this.buffer + ' = "";');
                return id;
              };
              _proto._popBuffer = function _popBuffer() {
                this.buffer = this.bufferStack.pop();
              };
              _proto._emit = function _emit(code) {
                this.codebuf.push(code);
              };
              _proto._emitLine = function _emitLine(code) {
                this._emit(code + "\n");
              };
              _proto._emitLines = function _emitLines() {
                var _this = this;
                for (var _len = arguments.length, lines = new Array(_len), _key = 0; _key < _len; _key++) {
                  lines[_key] = arguments[_key];
                }
                lines.forEach(function(line) {
                  return _this._emitLine(line);
                });
              };
              _proto._emitFuncBegin = function _emitFuncBegin(node, name) {
                this.buffer = "output";
                this._scopeClosers = "";
                this._emitLine("function " + name + "(env, context, frame, runtime, cb) {");
                this._emitLine("var lineno = " + node.lineno + ";");
                this._emitLine("var colno = " + node.colno + ";");
                this._emitLine("var " + this.buffer + ' = "";');
                this._emitLine("try {");
              };
              _proto._emitFuncEnd = function _emitFuncEnd(noReturn) {
                if (!noReturn) {
                  this._emitLine("cb(null, " + this.buffer + ");");
                }
                this._closeScopeLevels();
                this._emitLine("} catch (e) {");
                this._emitLine("  cb(runtime.handleError(e, lineno, colno));");
                this._emitLine("}");
                this._emitLine("}");
                this.buffer = null;
              };
              _proto._addScopeLevel = function _addScopeLevel() {
                this._scopeClosers += "})";
              };
              _proto._closeScopeLevels = function _closeScopeLevels() {
                this._emitLine(this._scopeClosers + ";");
                this._scopeClosers = "";
              };
              _proto._withScopedSyntax = function _withScopedSyntax(func) {
                var _scopeClosers = this._scopeClosers;
                this._scopeClosers = "";
                func.call(this);
                this._closeScopeLevels();
                this._scopeClosers = _scopeClosers;
              };
              _proto._makeCallback = function _makeCallback(res) {
                var err = this._tmpid();
                return "function(" + err + (res ? "," + res : "") + ") {\nif(" + err + ") { cb(" + err + "); return; }";
              };
              _proto._tmpid = function _tmpid() {
                this.lastId++;
                return "t_" + this.lastId;
              };
              _proto._templateName = function _templateName() {
                return this.templateName == null ? "undefined" : JSON.stringify(this.templateName);
              };
              _proto._compileChildren = function _compileChildren(node, frame) {
                var _this2 = this;
                node.children.forEach(function(child) {
                  _this2.compile(child, frame);
                });
              };
              _proto._compileAggregate = function _compileAggregate(node, frame, startChar, endChar) {
                var _this3 = this;
                if (startChar) {
                  this._emit(startChar);
                }
                node.children.forEach(function(child, i) {
                  if (i > 0) {
                    _this3._emit(",");
                  }
                  _this3.compile(child, frame);
                });
                if (endChar) {
                  this._emit(endChar);
                }
              };
              _proto._compileExpression = function _compileExpression(node, frame) {
                this.assertType(node, nodes.Literal, nodes.Symbol, nodes.Group, nodes.Array, nodes.Dict, nodes.FunCall, nodes.Caller, nodes.Filter, nodes.LookupVal, nodes.Compare, nodes.InlineIf, nodes.In, nodes.Is, nodes.And, nodes.Or, nodes.Not, nodes.Add, nodes.Concat, nodes.Sub, nodes.Mul, nodes.Div, nodes.FloorDiv, nodes.Mod, nodes.Pow, nodes.Neg, nodes.Pos, nodes.Compare, nodes.NodeList);
                this.compile(node, frame);
              };
              _proto.assertType = function assertType(node) {
                for (var _len2 = arguments.length, types = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  types[_key2 - 1] = arguments[_key2];
                }
                if (!types.some(function(t) {
                  return node instanceof t;
                })) {
                  this.fail("assertType: invalid type: " + node.typename, node.lineno, node.colno);
                }
              };
              _proto.compileCallExtension = function compileCallExtension(node, frame, async) {
                var _this4 = this;
                var args = node.args;
                var contentArgs = node.contentArgs;
                var autoescape = typeof node.autoescape === "boolean" ? node.autoescape : true;
                if (!async) {
                  this._emit(this.buffer + " += runtime.suppressValue(");
                }
                this._emit('env.getExtension("' + node.extName + '")["' + node.prop + '"](');
                this._emit("context");
                if (args || contentArgs) {
                  this._emit(",");
                }
                if (args) {
                  if (!(args instanceof nodes.NodeList)) {
                    this.fail("compileCallExtension: arguments must be a NodeList, use `parser.parseSignature`");
                  }
                  args.children.forEach(function(arg, i) {
                    _this4._compileExpression(arg, frame);
                    if (i !== args.children.length - 1 || contentArgs.length) {
                      _this4._emit(",");
                    }
                  });
                }
                if (contentArgs.length) {
                  contentArgs.forEach(function(arg, i) {
                    if (i > 0) {
                      _this4._emit(",");
                    }
                    if (arg) {
                      _this4._emitLine("function(cb) {");
                      _this4._emitLine("if(!cb) { cb = function(err) { if(err) { throw err; }}}");
                      var id = _this4._pushBuffer();
                      _this4._withScopedSyntax(function() {
                        _this4.compile(arg, frame);
                        _this4._emitLine("cb(null, " + id + ");");
                      });
                      _this4._popBuffer();
                      _this4._emitLine("return " + id + ";");
                      _this4._emitLine("}");
                    } else {
                      _this4._emit("null");
                    }
                  });
                }
                if (async) {
                  var res = this._tmpid();
                  this._emitLine(", " + this._makeCallback(res));
                  this._emitLine(this.buffer + " += runtime.suppressValue(" + res + ", " + autoescape + " && env.opts.autoescape);");
                  this._addScopeLevel();
                } else {
                  this._emit(")");
                  this._emit(", " + autoescape + " && env.opts.autoescape);\n");
                }
              };
              _proto.compileCallExtensionAsync = function compileCallExtensionAsync(node, frame) {
                this.compileCallExtension(node, frame, true);
              };
              _proto.compileNodeList = function compileNodeList(node, frame) {
                this._compileChildren(node, frame);
              };
              _proto.compileLiteral = function compileLiteral(node) {
                if (typeof node.value === "string") {
                  var val = node.value.replace(/\\/g, "\\\\");
                  val = val.replace(/"/g, '\\"');
                  val = val.replace(/\n/g, "\\n");
                  val = val.replace(/\r/g, "\\r");
                  val = val.replace(/\t/g, "\\t");
                  val = val.replace(/\u2028/g, "\\u2028");
                  this._emit('"' + val + '"');
                } else if (node.value === null) {
                  this._emit("null");
                } else {
                  this._emit(node.value.toString());
                }
              };
              _proto.compileSymbol = function compileSymbol(node, frame) {
                var name = node.value;
                var v = frame.lookup(name);
                if (v) {
                  this._emit(v);
                } else {
                  this._emit('runtime.contextOrFrameLookup(context, frame, "' + name + '")');
                }
              };
              _proto.compileGroup = function compileGroup(node, frame) {
                this._compileAggregate(node, frame, "(", ")");
              };
              _proto.compileArray = function compileArray(node, frame) {
                this._compileAggregate(node, frame, "[", "]");
              };
              _proto.compileDict = function compileDict(node, frame) {
                this._compileAggregate(node, frame, "{", "}");
              };
              _proto.compilePair = function compilePair(node, frame) {
                var key = node.key;
                var val = node.value;
                if (key instanceof nodes.Symbol) {
                  key = new nodes.Literal(key.lineno, key.colno, key.value);
                } else if (!(key instanceof nodes.Literal && typeof key.value === "string")) {
                  this.fail("compilePair: Dict keys must be strings or names", key.lineno, key.colno);
                }
                this.compile(key, frame);
                this._emit(": ");
                this._compileExpression(val, frame);
              };
              _proto.compileInlineIf = function compileInlineIf(node, frame) {
                this._emit("(");
                this.compile(node.cond, frame);
                this._emit("?");
                this.compile(node.body, frame);
                this._emit(":");
                if (node.else_ !== null) {
                  this.compile(node.else_, frame);
                } else {
                  this._emit('""');
                }
                this._emit(")");
              };
              _proto.compileIn = function compileIn(node, frame) {
                this._emit("runtime.inOperator(");
                this.compile(node.left, frame);
                this._emit(",");
                this.compile(node.right, frame);
                this._emit(")");
              };
              _proto.compileIs = function compileIs(node, frame) {
                var right = node.right.name ? node.right.name.value : node.right.value;
                this._emit('env.getTest("' + right + '").call(context, ');
                this.compile(node.left, frame);
                if (node.right.args) {
                  this._emit(",");
                  this.compile(node.right.args, frame);
                }
                this._emit(") === true");
              };
              _proto._binOpEmitter = function _binOpEmitter(node, frame, str) {
                this.compile(node.left, frame);
                this._emit(str);
                this.compile(node.right, frame);
              };
              _proto.compileOr = function compileOr(node, frame) {
                return this._binOpEmitter(node, frame, " || ");
              };
              _proto.compileAnd = function compileAnd(node, frame) {
                return this._binOpEmitter(node, frame, " && ");
              };
              _proto.compileAdd = function compileAdd(node, frame) {
                return this._binOpEmitter(node, frame, " + ");
              };
              _proto.compileConcat = function compileConcat(node, frame) {
                return this._binOpEmitter(node, frame, ' + "" + ');
              };
              _proto.compileSub = function compileSub(node, frame) {
                return this._binOpEmitter(node, frame, " - ");
              };
              _proto.compileMul = function compileMul(node, frame) {
                return this._binOpEmitter(node, frame, " * ");
              };
              _proto.compileDiv = function compileDiv(node, frame) {
                return this._binOpEmitter(node, frame, " / ");
              };
              _proto.compileMod = function compileMod(node, frame) {
                return this._binOpEmitter(node, frame, " % ");
              };
              _proto.compileNot = function compileNot(node, frame) {
                this._emit("!");
                this.compile(node.target, frame);
              };
              _proto.compileFloorDiv = function compileFloorDiv(node, frame) {
                this._emit("Math.floor(");
                this.compile(node.left, frame);
                this._emit(" / ");
                this.compile(node.right, frame);
                this._emit(")");
              };
              _proto.compilePow = function compilePow(node, frame) {
                this._emit("Math.pow(");
                this.compile(node.left, frame);
                this._emit(", ");
                this.compile(node.right, frame);
                this._emit(")");
              };
              _proto.compileNeg = function compileNeg(node, frame) {
                this._emit("-");
                this.compile(node.target, frame);
              };
              _proto.compilePos = function compilePos(node, frame) {
                this._emit("+");
                this.compile(node.target, frame);
              };
              _proto.compileCompare = function compileCompare(node, frame) {
                var _this5 = this;
                this.compile(node.expr, frame);
                node.ops.forEach(function(op) {
                  _this5._emit(" " + compareOps[op.type] + " ");
                  _this5.compile(op.expr, frame);
                });
              };
              _proto.compileLookupVal = function compileLookupVal(node, frame) {
                this._emit("runtime.memberLookup((");
                this._compileExpression(node.target, frame);
                this._emit("),");
                this._compileExpression(node.val, frame);
                this._emit(")");
              };
              _proto._getNodeName = function _getNodeName(node) {
                switch (node.typename) {
                  case "Symbol":
                    return node.value;
                  case "FunCall":
                    return "the return value of (" + this._getNodeName(node.name) + ")";
                  case "LookupVal":
                    return this._getNodeName(node.target) + '["' + this._getNodeName(node.val) + '"]';
                  case "Literal":
                    return node.value.toString();
                  default:
                    return "--expression--";
                }
              };
              _proto.compileFunCall = function compileFunCall(node, frame) {
                this._emit("(lineno = " + node.lineno + ", colno = " + node.colno + ", ");
                this._emit("runtime.callWrap(");
                this._compileExpression(node.name, frame);
                this._emit(', "' + this._getNodeName(node.name).replace(/"/g, '\\"') + '", context, ');
                this._compileAggregate(node.args, frame, "[", "])");
                this._emit(")");
              };
              _proto.compileFilter = function compileFilter(node, frame) {
                var name = node.name;
                this.assertType(name, nodes.Symbol);
                this._emit('env.getFilter("' + name.value + '").call(context, ');
                this._compileAggregate(node.args, frame);
                this._emit(")");
              };
              _proto.compileFilterAsync = function compileFilterAsync(node, frame) {
                var name = node.name;
                var symbol = node.symbol.value;
                this.assertType(name, nodes.Symbol);
                frame.set(symbol, symbol);
                this._emit('env.getFilter("' + name.value + '").call(context, ');
                this._compileAggregate(node.args, frame);
                this._emitLine(", " + this._makeCallback(symbol));
                this._addScopeLevel();
              };
              _proto.compileKeywordArgs = function compileKeywordArgs(node, frame) {
                this._emit("runtime.makeKeywordArgs(");
                this.compileDict(node, frame);
                this._emit(")");
              };
              _proto.compileSet = function compileSet(node, frame) {
                var _this6 = this;
                var ids = [];
                node.targets.forEach(function(target) {
                  var name = target.value;
                  var id = frame.lookup(name);
                  if (id === null || id === void 0) {
                    id = _this6._tmpid();
                    _this6._emitLine("var " + id + ";");
                  }
                  ids.push(id);
                });
                if (node.value) {
                  this._emit(ids.join(" = ") + " = ");
                  this._compileExpression(node.value, frame);
                  this._emitLine(";");
                } else {
                  this._emit(ids.join(" = ") + " = ");
                  this.compile(node.body, frame);
                  this._emitLine(";");
                }
                node.targets.forEach(function(target, i) {
                  var id = ids[i];
                  var name = target.value;
                  _this6._emitLine('frame.set("' + name + '", ' + id + ", true);");
                  _this6._emitLine("if(frame.topLevel) {");
                  _this6._emitLine('context.setVariable("' + name + '", ' + id + ");");
                  _this6._emitLine("}");
                  if (name.charAt(0) !== "_") {
                    _this6._emitLine("if(frame.topLevel) {");
                    _this6._emitLine('context.addExport("' + name + '", ' + id + ");");
                    _this6._emitLine("}");
                  }
                });
              };
              _proto.compileSwitch = function compileSwitch(node, frame) {
                var _this7 = this;
                this._emit("switch (");
                this.compile(node.expr, frame);
                this._emit(") {");
                node.cases.forEach(function(c, i) {
                  _this7._emit("case ");
                  _this7.compile(c.cond, frame);
                  _this7._emit(": ");
                  _this7.compile(c.body, frame);
                  if (c.body.children.length) {
                    _this7._emitLine("break;");
                  }
                });
                if (node.default) {
                  this._emit("default:");
                  this.compile(node.default, frame);
                }
                this._emit("}");
              };
              _proto.compileIf = function compileIf(node, frame, async) {
                var _this8 = this;
                this._emit("if(");
                this._compileExpression(node.cond, frame);
                this._emitLine(") {");
                this._withScopedSyntax(function() {
                  _this8.compile(node.body, frame);
                  if (async) {
                    _this8._emit("cb()");
                  }
                });
                if (node.else_) {
                  this._emitLine("}\nelse {");
                  this._withScopedSyntax(function() {
                    _this8.compile(node.else_, frame);
                    if (async) {
                      _this8._emit("cb()");
                    }
                  });
                } else if (async) {
                  this._emitLine("}\nelse {");
                  this._emit("cb()");
                }
                this._emitLine("}");
              };
              _proto.compileIfAsync = function compileIfAsync(node, frame) {
                this._emit("(function(cb) {");
                this.compileIf(node, frame, true);
                this._emit("})(" + this._makeCallback());
                this._addScopeLevel();
              };
              _proto._emitLoopBindings = function _emitLoopBindings(node, arr, i, len) {
                var _this9 = this;
                var bindings = [{
                  name: "index",
                  val: i + " + 1"
                }, {
                  name: "index0",
                  val: i
                }, {
                  name: "revindex",
                  val: len + " - " + i
                }, {
                  name: "revindex0",
                  val: len + " - " + i + " - 1"
                }, {
                  name: "first",
                  val: i + " === 0"
                }, {
                  name: "last",
                  val: i + " === " + len + " - 1"
                }, {
                  name: "length",
                  val: len
                }];
                bindings.forEach(function(b) {
                  _this9._emitLine('frame.set("loop.' + b.name + '", ' + b.val + ");");
                });
              };
              _proto.compileFor = function compileFor(node, frame) {
                var _this10 = this;
                var i = this._tmpid();
                var len = this._tmpid();
                var arr = this._tmpid();
                frame = frame.push();
                this._emitLine("frame = frame.push();");
                this._emit("var " + arr + " = ");
                this._compileExpression(node.arr, frame);
                this._emitLine(";");
                this._emit("if(" + arr + ") {");
                this._emitLine(arr + " = runtime.fromIterator(" + arr + ");");
                if (node.name instanceof nodes.Array) {
                  this._emitLine("var " + i + ";");
                  this._emitLine("if(runtime.isArray(" + arr + ")) {");
                  this._emitLine("var " + len + " = " + arr + ".length;");
                  this._emitLine("for(" + i + "=0; " + i + " < " + arr + ".length; " + i + "++) {");
                  node.name.children.forEach(function(child, u) {
                    var tid = _this10._tmpid();
                    _this10._emitLine("var " + tid + " = " + arr + "[" + i + "][" + u + "];");
                    _this10._emitLine('frame.set("' + child + '", ' + arr + "[" + i + "][" + u + "]);");
                    frame.set(node.name.children[u].value, tid);
                  });
                  this._emitLoopBindings(node, arr, i, len);
                  this._withScopedSyntax(function() {
                    _this10.compile(node.body, frame);
                  });
                  this._emitLine("}");
                  this._emitLine("} else {");
                  var _node$name$children = node.name.children, key = _node$name$children[0], val = _node$name$children[1];
                  var k = this._tmpid();
                  var v = this._tmpid();
                  frame.set(key.value, k);
                  frame.set(val.value, v);
                  this._emitLine(i + " = -1;");
                  this._emitLine("var " + len + " = runtime.keys(" + arr + ").length;");
                  this._emitLine("for(var " + k + " in " + arr + ") {");
                  this._emitLine(i + "++;");
                  this._emitLine("var " + v + " = " + arr + "[" + k + "];");
                  this._emitLine('frame.set("' + key.value + '", ' + k + ");");
                  this._emitLine('frame.set("' + val.value + '", ' + v + ");");
                  this._emitLoopBindings(node, arr, i, len);
                  this._withScopedSyntax(function() {
                    _this10.compile(node.body, frame);
                  });
                  this._emitLine("}");
                  this._emitLine("}");
                } else {
                  var _v = this._tmpid();
                  frame.set(node.name.value, _v);
                  this._emitLine("var " + len + " = " + arr + ".length;");
                  this._emitLine("for(var " + i + "=0; " + i + " < " + arr + ".length; " + i + "++) {");
                  this._emitLine("var " + _v + " = " + arr + "[" + i + "];");
                  this._emitLine('frame.set("' + node.name.value + '", ' + _v + ");");
                  this._emitLoopBindings(node, arr, i, len);
                  this._withScopedSyntax(function() {
                    _this10.compile(node.body, frame);
                  });
                  this._emitLine("}");
                }
                this._emitLine("}");
                if (node.else_) {
                  this._emitLine("if (!" + len + ") {");
                  this.compile(node.else_, frame);
                  this._emitLine("}");
                }
                this._emitLine("frame = frame.pop();");
              };
              _proto._compileAsyncLoop = function _compileAsyncLoop(node, frame, parallel) {
                var _this11 = this;
                var i = this._tmpid();
                var len = this._tmpid();
                var arr = this._tmpid();
                var asyncMethod = parallel ? "asyncAll" : "asyncEach";
                frame = frame.push();
                this._emitLine("frame = frame.push();");
                this._emit("var " + arr + " = runtime.fromIterator(");
                this._compileExpression(node.arr, frame);
                this._emitLine(");");
                if (node.name instanceof nodes.Array) {
                  var arrayLen = node.name.children.length;
                  this._emit("runtime." + asyncMethod + "(" + arr + ", " + arrayLen + ", function(");
                  node.name.children.forEach(function(name) {
                    _this11._emit(name.value + ",");
                  });
                  this._emit(i + "," + len + ",next) {");
                  node.name.children.forEach(function(name) {
                    var id2 = name.value;
                    frame.set(id2, id2);
                    _this11._emitLine('frame.set("' + id2 + '", ' + id2 + ");");
                  });
                } else {
                  var id = node.name.value;
                  this._emitLine("runtime." + asyncMethod + "(" + arr + ", 1, function(" + id + ", " + i + ", " + len + ",next) {");
                  this._emitLine('frame.set("' + id + '", ' + id + ");");
                  frame.set(id, id);
                }
                this._emitLoopBindings(node, arr, i, len);
                this._withScopedSyntax(function() {
                  var buf;
                  if (parallel) {
                    buf = _this11._pushBuffer();
                  }
                  _this11.compile(node.body, frame);
                  _this11._emitLine("next(" + i + (buf ? "," + buf : "") + ");");
                  if (parallel) {
                    _this11._popBuffer();
                  }
                });
                var output = this._tmpid();
                this._emitLine("}, " + this._makeCallback(output));
                this._addScopeLevel();
                if (parallel) {
                  this._emitLine(this.buffer + " += " + output + ";");
                }
                if (node.else_) {
                  this._emitLine("if (!" + arr + ".length) {");
                  this.compile(node.else_, frame);
                  this._emitLine("}");
                }
                this._emitLine("frame = frame.pop();");
              };
              _proto.compileAsyncEach = function compileAsyncEach(node, frame) {
                this._compileAsyncLoop(node, frame);
              };
              _proto.compileAsyncAll = function compileAsyncAll(node, frame) {
                this._compileAsyncLoop(node, frame, true);
              };
              _proto._compileMacro = function _compileMacro(node, frame) {
                var _this12 = this;
                var args = [];
                var kwargs = null;
                var funcId = "macro_" + this._tmpid();
                var keepFrame = frame !== void 0;
                node.args.children.forEach(function(arg, i) {
                  if (i === node.args.children.length - 1 && arg instanceof nodes.Dict) {
                    kwargs = arg;
                  } else {
                    _this12.assertType(arg, nodes.Symbol);
                    args.push(arg);
                  }
                });
                var realNames = [].concat(args.map(function(n) {
                  return "l_" + n.value;
                }), ["kwargs"]);
                var argNames = args.map(function(n) {
                  return '"' + n.value + '"';
                });
                var kwargNames = (kwargs && kwargs.children || []).map(function(n) {
                  return '"' + n.key.value + '"';
                });
                var currFrame;
                if (keepFrame) {
                  currFrame = frame.push(true);
                } else {
                  currFrame = new Frame();
                }
                this._emitLines("var " + funcId + " = runtime.makeMacro(", "[" + argNames.join(", ") + "], ", "[" + kwargNames.join(", ") + "], ", "function (" + realNames.join(", ") + ") {", "var callerFrame = frame;", "frame = " + (keepFrame ? "frame.push(true);" : "new runtime.Frame();"), "kwargs = kwargs || {};", 'if (Object.prototype.hasOwnProperty.call(kwargs, "caller")) {', 'frame.set("caller", kwargs.caller); }');
                args.forEach(function(arg) {
                  _this12._emitLine('frame.set("' + arg.value + '", l_' + arg.value + ");");
                  currFrame.set(arg.value, "l_" + arg.value);
                });
                if (kwargs) {
                  kwargs.children.forEach(function(pair) {
                    var name = pair.key.value;
                    _this12._emit('frame.set("' + name + '", ');
                    _this12._emit('Object.prototype.hasOwnProperty.call(kwargs, "' + name + '")');
                    _this12._emit(' ? kwargs["' + name + '"] : ');
                    _this12._compileExpression(pair.value, currFrame);
                    _this12._emit(");");
                  });
                }
                var bufferId = this._pushBuffer();
                this._withScopedSyntax(function() {
                  _this12.compile(node.body, currFrame);
                });
                this._emitLine("frame = " + (keepFrame ? "frame.pop();" : "callerFrame;"));
                this._emitLine("return new runtime.SafeString(" + bufferId + ");");
                this._emitLine("});");
                this._popBuffer();
                return funcId;
              };
              _proto.compileMacro = function compileMacro(node, frame) {
                var funcId = this._compileMacro(node);
                var name = node.name.value;
                frame.set(name, funcId);
                if (frame.parent) {
                  this._emitLine('frame.set("' + name + '", ' + funcId + ");");
                } else {
                  if (node.name.value.charAt(0) !== "_") {
                    this._emitLine('context.addExport("' + name + '");');
                  }
                  this._emitLine('context.setVariable("' + name + '", ' + funcId + ");");
                }
              };
              _proto.compileCaller = function compileCaller(node, frame) {
                this._emit("(function (){");
                var funcId = this._compileMacro(node, frame);
                this._emit("return " + funcId + ";})()");
              };
              _proto._compileGetTemplate = function _compileGetTemplate(node, frame, eagerCompile, ignoreMissing) {
                var parentTemplateId = this._tmpid();
                var parentName = this._templateName();
                var cb = this._makeCallback(parentTemplateId);
                var eagerCompileArg = eagerCompile ? "true" : "false";
                var ignoreMissingArg = ignoreMissing ? "true" : "false";
                this._emit("env.getTemplate(");
                this._compileExpression(node.template, frame);
                this._emitLine(", " + eagerCompileArg + ", " + parentName + ", " + ignoreMissingArg + ", " + cb);
                return parentTemplateId;
              };
              _proto.compileImport = function compileImport(node, frame) {
                var target = node.target.value;
                var id = this._compileGetTemplate(node, frame, false, false);
                this._addScopeLevel();
                this._emitLine(id + ".getExported(" + (node.withContext ? "context.getVariables(), frame, " : "") + this._makeCallback(id));
                this._addScopeLevel();
                frame.set(target, id);
                if (frame.parent) {
                  this._emitLine('frame.set("' + target + '", ' + id + ");");
                } else {
                  this._emitLine('context.setVariable("' + target + '", ' + id + ");");
                }
              };
              _proto.compileFromImport = function compileFromImport(node, frame) {
                var _this13 = this;
                var importedId = this._compileGetTemplate(node, frame, false, false);
                this._addScopeLevel();
                this._emitLine(importedId + ".getExported(" + (node.withContext ? "context.getVariables(), frame, " : "") + this._makeCallback(importedId));
                this._addScopeLevel();
                node.names.children.forEach(function(nameNode) {
                  var name;
                  var alias;
                  var id = _this13._tmpid();
                  if (nameNode instanceof nodes.Pair) {
                    name = nameNode.key.value;
                    alias = nameNode.value.value;
                  } else {
                    name = nameNode.value;
                    alias = name;
                  }
                  _this13._emitLine("if(Object.prototype.hasOwnProperty.call(" + importedId + ', "' + name + '")) {');
                  _this13._emitLine("var " + id + " = " + importedId + "." + name + ";");
                  _this13._emitLine("} else {");
                  _this13._emitLine(`cb(new Error("cannot import '` + name + `'")); return;`);
                  _this13._emitLine("}");
                  frame.set(alias, id);
                  if (frame.parent) {
                    _this13._emitLine('frame.set("' + alias + '", ' + id + ");");
                  } else {
                    _this13._emitLine('context.setVariable("' + alias + '", ' + id + ");");
                  }
                });
              };
              _proto.compileBlock = function compileBlock(node) {
                var id = this._tmpid();
                if (!this.inBlock) {
                  this._emit('(parentTemplate ? function(e, c, f, r, cb) { cb(""); } : ');
                }
                this._emit('context.getBlock("' + node.name.value + '")');
                if (!this.inBlock) {
                  this._emit(")");
                }
                this._emitLine("(env, context, frame, runtime, " + this._makeCallback(id));
                this._emitLine(this.buffer + " += " + id + ";");
                this._addScopeLevel();
              };
              _proto.compileSuper = function compileSuper(node, frame) {
                var name = node.blockName.value;
                var id = node.symbol.value;
                var cb = this._makeCallback(id);
                this._emitLine('context.getSuper(env, "' + name + '", b_' + name + ", frame, runtime, " + cb);
                this._emitLine(id + " = runtime.markSafe(" + id + ");");
                this._addScopeLevel();
                frame.set(id, id);
              };
              _proto.compileExtends = function compileExtends(node, frame) {
                var k = this._tmpid();
                var parentTemplateId = this._compileGetTemplate(node, frame, true, false);
                this._emitLine("parentTemplate = " + parentTemplateId);
                this._emitLine("for(var " + k + " in parentTemplate.blocks) {");
                this._emitLine("context.addBlock(" + k + ", parentTemplate.blocks[" + k + "]);");
                this._emitLine("}");
                this._addScopeLevel();
              };
              _proto.compileInclude = function compileInclude(node, frame) {
                this._emitLine("var tasks = [];");
                this._emitLine("tasks.push(");
                this._emitLine("function(callback) {");
                var id = this._compileGetTemplate(node, frame, false, node.ignoreMissing);
                this._emitLine("callback(null," + id + ");});");
                this._emitLine("});");
                var id2 = this._tmpid();
                this._emitLine("tasks.push(");
                this._emitLine("function(template, callback){");
                this._emitLine("template.render(context.getVariables(), frame, " + this._makeCallback(id2));
                this._emitLine("callback(null," + id2 + ");});");
                this._emitLine("});");
                this._emitLine("tasks.push(");
                this._emitLine("function(result, callback){");
                this._emitLine(this.buffer + " += result;");
                this._emitLine("callback(null);");
                this._emitLine("});");
                this._emitLine("env.waterfall(tasks, function(){");
                this._addScopeLevel();
              };
              _proto.compileTemplateData = function compileTemplateData(node, frame) {
                this.compileLiteral(node, frame);
              };
              _proto.compileCapture = function compileCapture(node, frame) {
                var _this14 = this;
                var buffer = this.buffer;
                this.buffer = "output";
                this._emitLine("(function() {");
                this._emitLine('var output = "";');
                this._withScopedSyntax(function() {
                  _this14.compile(node.body, frame);
                });
                this._emitLine("return output;");
                this._emitLine("})()");
                this.buffer = buffer;
              };
              _proto.compileOutput = function compileOutput(node, frame) {
                var _this15 = this;
                var children2 = node.children;
                children2.forEach(function(child) {
                  if (child instanceof nodes.TemplateData) {
                    if (child.value) {
                      _this15._emit(_this15.buffer + " += ");
                      _this15.compileLiteral(child, frame);
                      _this15._emitLine(";");
                    }
                  } else {
                    _this15._emit(_this15.buffer + " += runtime.suppressValue(");
                    if (_this15.throwOnUndefined) {
                      _this15._emit("runtime.ensureDefined(");
                    }
                    _this15.compile(child, frame);
                    if (_this15.throwOnUndefined) {
                      _this15._emit("," + node.lineno + "," + node.colno + ")");
                    }
                    _this15._emit(", env.opts.autoescape);\n");
                  }
                });
              };
              _proto.compileRoot = function compileRoot(node, frame) {
                var _this16 = this;
                if (frame) {
                  this.fail("compileRoot: root node can't have frame");
                }
                frame = new Frame();
                this._emitFuncBegin(node, "root");
                this._emitLine("var parentTemplate = null;");
                this._compileChildren(node, frame);
                this._emitLine("if(parentTemplate) {");
                this._emitLine("parentTemplate.rootRenderFunc(env, context, frame, runtime, cb);");
                this._emitLine("} else {");
                this._emitLine("cb(null, " + this.buffer + ");");
                this._emitLine("}");
                this._emitFuncEnd(true);
                this.inBlock = true;
                var blockNames = [];
                var blocks = node.findAll(nodes.Block);
                blocks.forEach(function(block, i) {
                  var name = block.name.value;
                  if (blockNames.indexOf(name) !== -1) {
                    throw new Error('Block "' + name + '" defined more than once.');
                  }
                  blockNames.push(name);
                  _this16._emitFuncBegin(block, "b_" + name);
                  var tmpFrame = new Frame();
                  _this16._emitLine("var frame = frame.push(true);");
                  _this16.compile(block.body, tmpFrame);
                  _this16._emitFuncEnd();
                });
                this._emitLine("return {");
                blocks.forEach(function(block, i) {
                  var blockName = "b_" + block.name.value;
                  _this16._emitLine(blockName + ": " + blockName + ",");
                });
                this._emitLine("root: root\n};");
              };
              _proto.compile = function compile(node, frame) {
                var _compile = this["compile" + node.typename];
                if (_compile) {
                  _compile.call(this, node, frame);
                } else {
                  this.fail("compile: Cannot compile node: " + node.typename, node.lineno, node.colno);
                }
              };
              _proto.getCode = function getCode() {
                return this.codebuf.join("");
              };
              return Compiler2;
            }(Obj);
            module3.exports = {
              compile: function compile(src, asyncFilters, extensions, name, opts) {
                if (opts === void 0) {
                  opts = {};
                }
                var c = new Compiler(name, opts.throwOnUndefined);
                var preprocessors = (extensions || []).map(function(ext) {
                  return ext.preprocess;
                }).filter(function(f) {
                  return !!f;
                });
                var processedSrc = preprocessors.reduce(function(s, processor) {
                  return processor(s);
                }, src);
                c.compile(transformer.transform(parser.parse(processedSrc, extensions, opts), asyncFilters, name));
                return c.getCode();
              },
              Compiler
            };
          },
          /* 6 */
          /***/
          function(module3, exports2, __webpack_require__) {
            "use strict";
            function _inheritsLoose(subClass, superClass) {
              subClass.prototype = Object.create(superClass.prototype);
              subClass.prototype.constructor = subClass;
              _setPrototypeOf(subClass, superClass);
            }
            function _setPrototypeOf(o, p) {
              _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return _setPrototypeOf(o, p);
            }
            var path = __webpack_require__(4);
            var _require = __webpack_require__(1), EmitterObj = _require.EmitterObj;
            module3.exports = /* @__PURE__ */ function(_EmitterObj) {
              _inheritsLoose(Loader, _EmitterObj);
              function Loader() {
                return _EmitterObj.apply(this, arguments) || this;
              }
              var _proto = Loader.prototype;
              _proto.resolve = function resolve(from, to) {
                return path.resolve(path.dirname(from), to);
              };
              _proto.isRelative = function isRelative(filename) {
                return filename.indexOf("./") === 0 || filename.indexOf("../") === 0;
              };
              return Loader;
            }(EmitterObj);
          },
          /* 7 */
          /***/
          function(module3, exports2, __webpack_require__) {
            "use strict";
            function _inheritsLoose(subClass, superClass) {
              subClass.prototype = Object.create(superClass.prototype);
              subClass.prototype.constructor = subClass;
              _setPrototypeOf(subClass, superClass);
            }
            function _setPrototypeOf(o, p) {
              _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return _setPrototypeOf(o, p);
            }
            var asap = __webpack_require__(12);
            var _waterfall = __webpack_require__(15);
            var lib = __webpack_require__(0);
            var compiler = __webpack_require__(5);
            var filters = __webpack_require__(18);
            var _require = __webpack_require__(10), FileSystemLoader = _require.FileSystemLoader, WebLoader = _require.WebLoader, PrecompiledLoader = _require.PrecompiledLoader;
            var tests = __webpack_require__(20);
            var globals2 = __webpack_require__(21);
            var _require2 = __webpack_require__(1), Obj = _require2.Obj, EmitterObj = _require2.EmitterObj;
            var globalRuntime = __webpack_require__(2);
            var handleError = globalRuntime.handleError, Frame = globalRuntime.Frame;
            var expressApp = __webpack_require__(22);
            function callbackAsap(cb, err, res) {
              asap(function() {
                cb(err, res);
              });
            }
            var noopTmplSrc = {
              type: "code",
              obj: {
                root: function root(env2, context, frame, runtime, cb) {
                  try {
                    cb(null, "");
                  } catch (e) {
                    cb(handleError(e, null, null));
                  }
                }
              }
            };
            var Environment = /* @__PURE__ */ function(_EmitterObj) {
              _inheritsLoose(Environment2, _EmitterObj);
              function Environment2() {
                return _EmitterObj.apply(this, arguments) || this;
              }
              var _proto = Environment2.prototype;
              _proto.init = function init2(loaders, opts) {
                var _this = this;
                opts = this.opts = opts || {};
                this.opts.dev = !!opts.dev;
                this.opts.autoescape = opts.autoescape != null ? opts.autoescape : true;
                this.opts.throwOnUndefined = !!opts.throwOnUndefined;
                this.opts.trimBlocks = !!opts.trimBlocks;
                this.opts.lstripBlocks = !!opts.lstripBlocks;
                this.loaders = [];
                if (!loaders) {
                  if (FileSystemLoader) {
                    this.loaders = [new FileSystemLoader("views")];
                  } else if (WebLoader) {
                    this.loaders = [new WebLoader("/views")];
                  }
                } else {
                  this.loaders = lib.isArray(loaders) ? loaders : [loaders];
                }
                if (typeof window !== "undefined" && window.nunjucksPrecompiled) {
                  this.loaders.unshift(new PrecompiledLoader(window.nunjucksPrecompiled));
                }
                this._initLoaders();
                this.globals = globals2();
                this.filters = {};
                this.tests = {};
                this.asyncFilters = [];
                this.extensions = {};
                this.extensionsList = [];
                lib._entries(filters).forEach(function(_ref) {
                  var name = _ref[0], filter = _ref[1];
                  return _this.addFilter(name, filter);
                });
                lib._entries(tests).forEach(function(_ref2) {
                  var name = _ref2[0], test = _ref2[1];
                  return _this.addTest(name, test);
                });
              };
              _proto._initLoaders = function _initLoaders() {
                var _this2 = this;
                this.loaders.forEach(function(loader) {
                  loader.cache = {};
                  if (typeof loader.on === "function") {
                    loader.on("update", function(name, fullname) {
                      loader.cache[name] = null;
                      _this2.emit("update", name, fullname, loader);
                    });
                    loader.on("load", function(name, source) {
                      _this2.emit("load", name, source, loader);
                    });
                  }
                });
              };
              _proto.invalidateCache = function invalidateCache() {
                this.loaders.forEach(function(loader) {
                  loader.cache = {};
                });
              };
              _proto.addExtension = function addExtension(name, extension) {
                extension.__name = name;
                this.extensions[name] = extension;
                this.extensionsList.push(extension);
                return this;
              };
              _proto.removeExtension = function removeExtension(name) {
                var extension = this.getExtension(name);
                if (!extension) {
                  return;
                }
                this.extensionsList = lib.without(this.extensionsList, extension);
                delete this.extensions[name];
              };
              _proto.getExtension = function getExtension(name) {
                return this.extensions[name];
              };
              _proto.hasExtension = function hasExtension(name) {
                return !!this.extensions[name];
              };
              _proto.addGlobal = function addGlobal(name, value) {
                this.globals[name] = value;
                return this;
              };
              _proto.getGlobal = function getGlobal(name) {
                if (typeof this.globals[name] === "undefined") {
                  throw new Error("global not found: " + name);
                }
                return this.globals[name];
              };
              _proto.addFilter = function addFilter(name, func, async) {
                var wrapped = func;
                if (async) {
                  this.asyncFilters.push(name);
                }
                this.filters[name] = wrapped;
                return this;
              };
              _proto.getFilter = function getFilter(name) {
                if (!this.filters[name]) {
                  throw new Error("filter not found: " + name);
                }
                return this.filters[name];
              };
              _proto.addTest = function addTest(name, func) {
                this.tests[name] = func;
                return this;
              };
              _proto.getTest = function getTest(name) {
                if (!this.tests[name]) {
                  throw new Error("test not found: " + name);
                }
                return this.tests[name];
              };
              _proto.resolveTemplate = function resolveTemplate(loader, parentName, filename) {
                var isRelative = loader.isRelative && parentName ? loader.isRelative(filename) : false;
                return isRelative && loader.resolve ? loader.resolve(parentName, filename) : filename;
              };
              _proto.getTemplate = function getTemplate(name, eagerCompile, parentName, ignoreMissing, cb) {
                var _this3 = this;
                var that = this;
                var tmpl = null;
                if (name && name.raw) {
                  name = name.raw;
                }
                if (lib.isFunction(parentName)) {
                  cb = parentName;
                  parentName = null;
                  eagerCompile = eagerCompile || false;
                }
                if (lib.isFunction(eagerCompile)) {
                  cb = eagerCompile;
                  eagerCompile = false;
                }
                if (name instanceof Template) {
                  tmpl = name;
                } else if (typeof name !== "string") {
                  throw new Error("template names must be a string: " + name);
                } else {
                  for (var i = 0; i < this.loaders.length; i++) {
                    var loader = this.loaders[i];
                    tmpl = loader.cache[this.resolveTemplate(loader, parentName, name)];
                    if (tmpl) {
                      break;
                    }
                  }
                }
                if (tmpl) {
                  if (eagerCompile) {
                    tmpl.compile();
                  }
                  if (cb) {
                    cb(null, tmpl);
                    return void 0;
                  } else {
                    return tmpl;
                  }
                }
                var syncResult;
                var createTemplate = function createTemplate2(err, info) {
                  if (!info && !err && !ignoreMissing) {
                    err = new Error("template not found: " + name);
                  }
                  if (err) {
                    if (cb) {
                      cb(err);
                      return;
                    } else {
                      throw err;
                    }
                  }
                  var newTmpl;
                  if (!info) {
                    newTmpl = new Template(noopTmplSrc, _this3, "", eagerCompile);
                  } else {
                    newTmpl = new Template(info.src, _this3, info.path, eagerCompile);
                    if (!info.noCache) {
                      info.loader.cache[name] = newTmpl;
                    }
                  }
                  if (cb) {
                    cb(null, newTmpl);
                  } else {
                    syncResult = newTmpl;
                  }
                };
                lib.asyncIter(this.loaders, function(loader2, i2, next, done) {
                  function handle(err, src) {
                    if (err) {
                      done(err);
                    } else if (src) {
                      src.loader = loader2;
                      done(null, src);
                    } else {
                      next();
                    }
                  }
                  name = that.resolveTemplate(loader2, parentName, name);
                  if (loader2.async) {
                    loader2.getSource(name, handle);
                  } else {
                    handle(null, loader2.getSource(name));
                  }
                }, createTemplate);
                return syncResult;
              };
              _proto.express = function express(app) {
                return expressApp(this, app);
              };
              _proto.render = function render(name, ctx, cb) {
                if (lib.isFunction(ctx)) {
                  cb = ctx;
                  ctx = null;
                }
                var syncResult = null;
                this.getTemplate(name, function(err, tmpl) {
                  if (err && cb) {
                    callbackAsap(cb, err);
                  } else if (err) {
                    throw err;
                  } else {
                    syncResult = tmpl.render(ctx, cb);
                  }
                });
                return syncResult;
              };
              _proto.renderString = function renderString(src, ctx, opts, cb) {
                if (lib.isFunction(opts)) {
                  cb = opts;
                  opts = {};
                }
                opts = opts || {};
                var tmpl = new Template(src, this, opts.path);
                return tmpl.render(ctx, cb);
              };
              _proto.waterfall = function waterfall(tasks2, callback, forceAsync) {
                return _waterfall(tasks2, callback, forceAsync);
              };
              return Environment2;
            }(EmitterObj);
            var Context = /* @__PURE__ */ function(_Obj) {
              _inheritsLoose(Context2, _Obj);
              function Context2() {
                return _Obj.apply(this, arguments) || this;
              }
              var _proto2 = Context2.prototype;
              _proto2.init = function init2(ctx, blocks, env2) {
                var _this4 = this;
                this.env = env2 || new Environment();
                this.ctx = lib.extend({}, ctx);
                this.blocks = {};
                this.exported = [];
                lib.keys(blocks).forEach(function(name) {
                  _this4.addBlock(name, blocks[name]);
                });
              };
              _proto2.lookup = function lookup(name) {
                if (name in this.env.globals && !(name in this.ctx)) {
                  return this.env.globals[name];
                } else {
                  return this.ctx[name];
                }
              };
              _proto2.setVariable = function setVariable(name, val) {
                this.ctx[name] = val;
              };
              _proto2.getVariables = function getVariables() {
                return this.ctx;
              };
              _proto2.addBlock = function addBlock(name, block) {
                this.blocks[name] = this.blocks[name] || [];
                this.blocks[name].push(block);
                return this;
              };
              _proto2.getBlock = function getBlock(name) {
                if (!this.blocks[name]) {
                  throw new Error('unknown block "' + name + '"');
                }
                return this.blocks[name][0];
              };
              _proto2.getSuper = function getSuper(env2, name, block, frame, runtime, cb) {
                var idx = lib.indexOf(this.blocks[name] || [], block);
                var blk = this.blocks[name][idx + 1];
                var context = this;
                if (idx === -1 || !blk) {
                  throw new Error('no super block available for "' + name + '"');
                }
                blk(env2, context, frame, runtime, cb);
              };
              _proto2.addExport = function addExport(name) {
                this.exported.push(name);
              };
              _proto2.getExported = function getExported() {
                var _this5 = this;
                var exported = {};
                this.exported.forEach(function(name) {
                  exported[name] = _this5.ctx[name];
                });
                return exported;
              };
              return Context2;
            }(Obj);
            var Template = /* @__PURE__ */ function(_Obj2) {
              _inheritsLoose(Template2, _Obj2);
              function Template2() {
                return _Obj2.apply(this, arguments) || this;
              }
              var _proto3 = Template2.prototype;
              _proto3.init = function init2(src, env2, path, eagerCompile) {
                this.env = env2 || new Environment();
                if (lib.isObject(src)) {
                  switch (src.type) {
                    case "code":
                      this.tmplProps = src.obj;
                      break;
                    case "string":
                      this.tmplStr = src.obj;
                      break;
                    default:
                      throw new Error("Unexpected template object type " + src.type + "; expected 'code', or 'string'");
                  }
                } else if (lib.isString(src)) {
                  this.tmplStr = src;
                } else {
                  throw new Error("src must be a string or an object describing the source");
                }
                this.path = path;
                if (eagerCompile) {
                  try {
                    this._compile();
                  } catch (err) {
                    throw lib._prettifyError(this.path, this.env.opts.dev, err);
                  }
                } else {
                  this.compiled = false;
                }
              };
              _proto3.render = function render(ctx, parentFrame, cb) {
                var _this6 = this;
                if (typeof ctx === "function") {
                  cb = ctx;
                  ctx = {};
                } else if (typeof parentFrame === "function") {
                  cb = parentFrame;
                  parentFrame = null;
                }
                var forceAsync = !parentFrame;
                try {
                  this.compile();
                } catch (e) {
                  var err = lib._prettifyError(this.path, this.env.opts.dev, e);
                  if (cb) {
                    return callbackAsap(cb, err);
                  } else {
                    throw err;
                  }
                }
                var context = new Context(ctx || {}, this.blocks, this.env);
                var frame = parentFrame ? parentFrame.push(true) : new Frame();
                frame.topLevel = true;
                var syncResult = null;
                var didError = false;
                this.rootRenderFunc(this.env, context, frame, globalRuntime, function(err2, res) {
                  if (didError && cb && typeof res !== "undefined") {
                    return;
                  }
                  if (err2) {
                    err2 = lib._prettifyError(_this6.path, _this6.env.opts.dev, err2);
                    didError = true;
                  }
                  if (cb) {
                    if (forceAsync) {
                      callbackAsap(cb, err2, res);
                    } else {
                      cb(err2, res);
                    }
                  } else {
                    if (err2) {
                      throw err2;
                    }
                    syncResult = res;
                  }
                });
                return syncResult;
              };
              _proto3.getExported = function getExported(ctx, parentFrame, cb) {
                if (typeof ctx === "function") {
                  cb = ctx;
                  ctx = {};
                }
                if (typeof parentFrame === "function") {
                  cb = parentFrame;
                  parentFrame = null;
                }
                try {
                  this.compile();
                } catch (e) {
                  if (cb) {
                    return cb(e);
                  } else {
                    throw e;
                  }
                }
                var frame = parentFrame ? parentFrame.push() : new Frame();
                frame.topLevel = true;
                var context = new Context(ctx || {}, this.blocks, this.env);
                this.rootRenderFunc(this.env, context, frame, globalRuntime, function(err) {
                  if (err) {
                    cb(err, null);
                  } else {
                    cb(null, context.getExported());
                  }
                });
              };
              _proto3.compile = function compile() {
                if (!this.compiled) {
                  this._compile();
                }
              };
              _proto3._compile = function _compile() {
                var props;
                if (this.tmplProps) {
                  props = this.tmplProps;
                } else {
                  var source = compiler.compile(this.tmplStr, this.env.asyncFilters, this.env.extensionsList, this.path, this.env.opts);
                  var func = new Function(source);
                  props = func();
                }
                this.blocks = this._getBlocks(props);
                this.rootRenderFunc = props.root;
                this.compiled = true;
              };
              _proto3._getBlocks = function _getBlocks(props) {
                var blocks = {};
                lib.keys(props).forEach(function(k) {
                  if (k.slice(0, 2) === "b_") {
                    blocks[k.slice(2)] = props[k];
                  }
                });
                return blocks;
              };
              return Template2;
            }(Obj);
            module3.exports = {
              Environment,
              Template
            };
          },
          /* 8 */
          /***/
          function(module3, exports2, __webpack_require__) {
            "use strict";
            function _inheritsLoose(subClass, superClass) {
              subClass.prototype = Object.create(superClass.prototype);
              subClass.prototype.constructor = subClass;
              _setPrototypeOf(subClass, superClass);
            }
            function _setPrototypeOf(o, p) {
              _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return _setPrototypeOf(o, p);
            }
            var lexer = __webpack_require__(9);
            var nodes = __webpack_require__(3);
            var Obj = __webpack_require__(1).Obj;
            var lib = __webpack_require__(0);
            var Parser = /* @__PURE__ */ function(_Obj) {
              _inheritsLoose(Parser2, _Obj);
              function Parser2() {
                return _Obj.apply(this, arguments) || this;
              }
              var _proto = Parser2.prototype;
              _proto.init = function init2(tokens) {
                this.tokens = tokens;
                this.peeked = null;
                this.breakOnBlocks = null;
                this.dropLeadingWhitespace = false;
                this.extensions = [];
              };
              _proto.nextToken = function nextToken(withWhitespace) {
                var tok;
                if (this.peeked) {
                  if (!withWhitespace && this.peeked.type === lexer.TOKEN_WHITESPACE) {
                    this.peeked = null;
                  } else {
                    tok = this.peeked;
                    this.peeked = null;
                    return tok;
                  }
                }
                tok = this.tokens.nextToken();
                if (!withWhitespace) {
                  while (tok && tok.type === lexer.TOKEN_WHITESPACE) {
                    tok = this.tokens.nextToken();
                  }
                }
                return tok;
              };
              _proto.peekToken = function peekToken() {
                this.peeked = this.peeked || this.nextToken();
                return this.peeked;
              };
              _proto.pushToken = function pushToken(tok) {
                if (this.peeked) {
                  throw new Error("pushToken: can only push one token on between reads");
                }
                this.peeked = tok;
              };
              _proto.error = function error(msg, lineno, colno) {
                if (lineno === void 0 || colno === void 0) {
                  var tok = this.peekToken() || {};
                  lineno = tok.lineno;
                  colno = tok.colno;
                }
                if (lineno !== void 0) {
                  lineno += 1;
                }
                if (colno !== void 0) {
                  colno += 1;
                }
                return new lib.TemplateError(msg, lineno, colno);
              };
              _proto.fail = function fail(msg, lineno, colno) {
                throw this.error(msg, lineno, colno);
              };
              _proto.skip = function skip(type) {
                var tok = this.nextToken();
                if (!tok || tok.type !== type) {
                  this.pushToken(tok);
                  return false;
                }
                return true;
              };
              _proto.expect = function expect(type) {
                var tok = this.nextToken();
                if (tok.type !== type) {
                  this.fail("expected " + type + ", got " + tok.type, tok.lineno, tok.colno);
                }
                return tok;
              };
              _proto.skipValue = function skipValue(type, val) {
                var tok = this.nextToken();
                if (!tok || tok.type !== type || tok.value !== val) {
                  this.pushToken(tok);
                  return false;
                }
                return true;
              };
              _proto.skipSymbol = function skipSymbol(val) {
                return this.skipValue(lexer.TOKEN_SYMBOL, val);
              };
              _proto.advanceAfterBlockEnd = function advanceAfterBlockEnd(name) {
                var tok;
                if (!name) {
                  tok = this.peekToken();
                  if (!tok) {
                    this.fail("unexpected end of file");
                  }
                  if (tok.type !== lexer.TOKEN_SYMBOL) {
                    this.fail("advanceAfterBlockEnd: expected symbol token or explicit name to be passed");
                  }
                  name = this.nextToken().value;
                }
                tok = this.nextToken();
                if (tok && tok.type === lexer.TOKEN_BLOCK_END) {
                  if (tok.value.charAt(0) === "-") {
                    this.dropLeadingWhitespace = true;
                  }
                } else {
                  this.fail("expected block end in " + name + " statement");
                }
                return tok;
              };
              _proto.advanceAfterVariableEnd = function advanceAfterVariableEnd() {
                var tok = this.nextToken();
                if (tok && tok.type === lexer.TOKEN_VARIABLE_END) {
                  this.dropLeadingWhitespace = tok.value.charAt(tok.value.length - this.tokens.tags.VARIABLE_END.length - 1) === "-";
                } else {
                  this.pushToken(tok);
                  this.fail("expected variable end");
                }
              };
              _proto.parseFor = function parseFor() {
                var forTok = this.peekToken();
                var node;
                var endBlock;
                if (this.skipSymbol("for")) {
                  node = new nodes.For(forTok.lineno, forTok.colno);
                  endBlock = "endfor";
                } else if (this.skipSymbol("asyncEach")) {
                  node = new nodes.AsyncEach(forTok.lineno, forTok.colno);
                  endBlock = "endeach";
                } else if (this.skipSymbol("asyncAll")) {
                  node = new nodes.AsyncAll(forTok.lineno, forTok.colno);
                  endBlock = "endall";
                } else {
                  this.fail("parseFor: expected for{Async}", forTok.lineno, forTok.colno);
                }
                node.name = this.parsePrimary();
                if (!(node.name instanceof nodes.Symbol)) {
                  this.fail("parseFor: variable name expected for loop");
                }
                var type = this.peekToken().type;
                if (type === lexer.TOKEN_COMMA) {
                  var key = node.name;
                  node.name = new nodes.Array(key.lineno, key.colno);
                  node.name.addChild(key);
                  while (this.skip(lexer.TOKEN_COMMA)) {
                    var prim = this.parsePrimary();
                    node.name.addChild(prim);
                  }
                }
                if (!this.skipSymbol("in")) {
                  this.fail('parseFor: expected "in" keyword for loop', forTok.lineno, forTok.colno);
                }
                node.arr = this.parseExpression();
                this.advanceAfterBlockEnd(forTok.value);
                node.body = this.parseUntilBlocks(endBlock, "else");
                if (this.skipSymbol("else")) {
                  this.advanceAfterBlockEnd("else");
                  node.else_ = this.parseUntilBlocks(endBlock);
                }
                this.advanceAfterBlockEnd();
                return node;
              };
              _proto.parseMacro = function parseMacro() {
                var macroTok = this.peekToken();
                if (!this.skipSymbol("macro")) {
                  this.fail("expected macro");
                }
                var name = this.parsePrimary(true);
                var args = this.parseSignature();
                var node = new nodes.Macro(macroTok.lineno, macroTok.colno, name, args);
                this.advanceAfterBlockEnd(macroTok.value);
                node.body = this.parseUntilBlocks("endmacro");
                this.advanceAfterBlockEnd();
                return node;
              };
              _proto.parseCall = function parseCall() {
                var callTok = this.peekToken();
                if (!this.skipSymbol("call")) {
                  this.fail("expected call");
                }
                var callerArgs = this.parseSignature(true) || new nodes.NodeList();
                var macroCall = this.parsePrimary();
                this.advanceAfterBlockEnd(callTok.value);
                var body = this.parseUntilBlocks("endcall");
                this.advanceAfterBlockEnd();
                var callerName = new nodes.Symbol(callTok.lineno, callTok.colno, "caller");
                var callerNode = new nodes.Caller(callTok.lineno, callTok.colno, callerName, callerArgs, body);
                var args = macroCall.args.children;
                if (!(args[args.length - 1] instanceof nodes.KeywordArgs)) {
                  args.push(new nodes.KeywordArgs());
                }
                var kwargs = args[args.length - 1];
                kwargs.addChild(new nodes.Pair(callTok.lineno, callTok.colno, callerName, callerNode));
                return new nodes.Output(callTok.lineno, callTok.colno, [macroCall]);
              };
              _proto.parseWithContext = function parseWithContext() {
                var tok = this.peekToken();
                var withContext = null;
                if (this.skipSymbol("with")) {
                  withContext = true;
                } else if (this.skipSymbol("without")) {
                  withContext = false;
                }
                if (withContext !== null) {
                  if (!this.skipSymbol("context")) {
                    this.fail("parseFrom: expected context after with/without", tok.lineno, tok.colno);
                  }
                }
                return withContext;
              };
              _proto.parseImport = function parseImport() {
                var importTok = this.peekToken();
                if (!this.skipSymbol("import")) {
                  this.fail("parseImport: expected import", importTok.lineno, importTok.colno);
                }
                var template = this.parseExpression();
                if (!this.skipSymbol("as")) {
                  this.fail('parseImport: expected "as" keyword', importTok.lineno, importTok.colno);
                }
                var target = this.parseExpression();
                var withContext = this.parseWithContext();
                var node = new nodes.Import(importTok.lineno, importTok.colno, template, target, withContext);
                this.advanceAfterBlockEnd(importTok.value);
                return node;
              };
              _proto.parseFrom = function parseFrom() {
                var fromTok = this.peekToken();
                if (!this.skipSymbol("from")) {
                  this.fail("parseFrom: expected from");
                }
                var template = this.parseExpression();
                if (!this.skipSymbol("import")) {
                  this.fail("parseFrom: expected import", fromTok.lineno, fromTok.colno);
                }
                var names = new nodes.NodeList();
                var withContext;
                while (1) {
                  var nextTok = this.peekToken();
                  if (nextTok.type === lexer.TOKEN_BLOCK_END) {
                    if (!names.children.length) {
                      this.fail("parseFrom: Expected at least one import name", fromTok.lineno, fromTok.colno);
                    }
                    if (nextTok.value.charAt(0) === "-") {
                      this.dropLeadingWhitespace = true;
                    }
                    this.nextToken();
                    break;
                  }
                  if (names.children.length > 0 && !this.skip(lexer.TOKEN_COMMA)) {
                    this.fail("parseFrom: expected comma", fromTok.lineno, fromTok.colno);
                  }
                  var name = this.parsePrimary();
                  if (name.value.charAt(0) === "_") {
                    this.fail("parseFrom: names starting with an underscore cannot be imported", name.lineno, name.colno);
                  }
                  if (this.skipSymbol("as")) {
                    var alias = this.parsePrimary();
                    names.addChild(new nodes.Pair(name.lineno, name.colno, name, alias));
                  } else {
                    names.addChild(name);
                  }
                  withContext = this.parseWithContext();
                }
                return new nodes.FromImport(fromTok.lineno, fromTok.colno, template, names, withContext);
              };
              _proto.parseBlock = function parseBlock() {
                var tag = this.peekToken();
                if (!this.skipSymbol("block")) {
                  this.fail("parseBlock: expected block", tag.lineno, tag.colno);
                }
                var node = new nodes.Block(tag.lineno, tag.colno);
                node.name = this.parsePrimary();
                if (!(node.name instanceof nodes.Symbol)) {
                  this.fail("parseBlock: variable name expected", tag.lineno, tag.colno);
                }
                this.advanceAfterBlockEnd(tag.value);
                node.body = this.parseUntilBlocks("endblock");
                this.skipSymbol("endblock");
                this.skipSymbol(node.name.value);
                var tok = this.peekToken();
                if (!tok) {
                  this.fail("parseBlock: expected endblock, got end of file");
                }
                this.advanceAfterBlockEnd(tok.value);
                return node;
              };
              _proto.parseExtends = function parseExtends() {
                var tagName = "extends";
                var tag = this.peekToken();
                if (!this.skipSymbol(tagName)) {
                  this.fail("parseTemplateRef: expected " + tagName);
                }
                var node = new nodes.Extends(tag.lineno, tag.colno);
                node.template = this.parseExpression();
                this.advanceAfterBlockEnd(tag.value);
                return node;
              };
              _proto.parseInclude = function parseInclude() {
                var tagName = "include";
                var tag = this.peekToken();
                if (!this.skipSymbol(tagName)) {
                  this.fail("parseInclude: expected " + tagName);
                }
                var node = new nodes.Include(tag.lineno, tag.colno);
                node.template = this.parseExpression();
                if (this.skipSymbol("ignore") && this.skipSymbol("missing")) {
                  node.ignoreMissing = true;
                }
                this.advanceAfterBlockEnd(tag.value);
                return node;
              };
              _proto.parseIf = function parseIf() {
                var tag = this.peekToken();
                var node;
                if (this.skipSymbol("if") || this.skipSymbol("elif") || this.skipSymbol("elseif")) {
                  node = new nodes.If(tag.lineno, tag.colno);
                } else if (this.skipSymbol("ifAsync")) {
                  node = new nodes.IfAsync(tag.lineno, tag.colno);
                } else {
                  this.fail("parseIf: expected if, elif, or elseif", tag.lineno, tag.colno);
                }
                node.cond = this.parseExpression();
                this.advanceAfterBlockEnd(tag.value);
                node.body = this.parseUntilBlocks("elif", "elseif", "else", "endif");
                var tok = this.peekToken();
                switch (tok && tok.value) {
                  case "elseif":
                  case "elif":
                    node.else_ = this.parseIf();
                    break;
                  case "else":
                    this.advanceAfterBlockEnd();
                    node.else_ = this.parseUntilBlocks("endif");
                    this.advanceAfterBlockEnd();
                    break;
                  case "endif":
                    node.else_ = null;
                    this.advanceAfterBlockEnd();
                    break;
                  default:
                    this.fail("parseIf: expected elif, else, or endif, got end of file");
                }
                return node;
              };
              _proto.parseSet = function parseSet() {
                var tag = this.peekToken();
                if (!this.skipSymbol("set")) {
                  this.fail("parseSet: expected set", tag.lineno, tag.colno);
                }
                var node = new nodes.Set(tag.lineno, tag.colno, []);
                var target;
                while (target = this.parsePrimary()) {
                  node.targets.push(target);
                  if (!this.skip(lexer.TOKEN_COMMA)) {
                    break;
                  }
                }
                if (!this.skipValue(lexer.TOKEN_OPERATOR, "=")) {
                  if (!this.skip(lexer.TOKEN_BLOCK_END)) {
                    this.fail("parseSet: expected = or block end in set tag", tag.lineno, tag.colno);
                  } else {
                    node.body = new nodes.Capture(tag.lineno, tag.colno, this.parseUntilBlocks("endset"));
                    node.value = null;
                    this.advanceAfterBlockEnd();
                  }
                } else {
                  node.value = this.parseExpression();
                  this.advanceAfterBlockEnd(tag.value);
                }
                return node;
              };
              _proto.parseSwitch = function parseSwitch() {
                var switchStart = "switch";
                var switchEnd = "endswitch";
                var caseStart = "case";
                var caseDefault = "default";
                var tag = this.peekToken();
                if (!this.skipSymbol(switchStart) && !this.skipSymbol(caseStart) && !this.skipSymbol(caseDefault)) {
                  this.fail('parseSwitch: expected "switch," "case" or "default"', tag.lineno, tag.colno);
                }
                var expr = this.parseExpression();
                this.advanceAfterBlockEnd(switchStart);
                this.parseUntilBlocks(caseStart, caseDefault, switchEnd);
                var tok = this.peekToken();
                var cases = [];
                var defaultCase;
                do {
                  this.skipSymbol(caseStart);
                  var cond = this.parseExpression();
                  this.advanceAfterBlockEnd(switchStart);
                  var body = this.parseUntilBlocks(caseStart, caseDefault, switchEnd);
                  cases.push(new nodes.Case(tok.line, tok.col, cond, body));
                  tok = this.peekToken();
                } while (tok && tok.value === caseStart);
                switch (tok.value) {
                  case caseDefault:
                    this.advanceAfterBlockEnd();
                    defaultCase = this.parseUntilBlocks(switchEnd);
                    this.advanceAfterBlockEnd();
                    break;
                  case switchEnd:
                    this.advanceAfterBlockEnd();
                    break;
                  default:
                    this.fail('parseSwitch: expected "case," "default" or "endswitch," got EOF.');
                }
                return new nodes.Switch(tag.lineno, tag.colno, expr, cases, defaultCase);
              };
              _proto.parseStatement = function parseStatement() {
                var tok = this.peekToken();
                var node;
                if (tok.type !== lexer.TOKEN_SYMBOL) {
                  this.fail("tag name expected", tok.lineno, tok.colno);
                }
                if (this.breakOnBlocks && lib.indexOf(this.breakOnBlocks, tok.value) !== -1) {
                  return null;
                }
                switch (tok.value) {
                  case "raw":
                    return this.parseRaw();
                  case "verbatim":
                    return this.parseRaw("verbatim");
                  case "if":
                  case "ifAsync":
                    return this.parseIf();
                  case "for":
                  case "asyncEach":
                  case "asyncAll":
                    return this.parseFor();
                  case "block":
                    return this.parseBlock();
                  case "extends":
                    return this.parseExtends();
                  case "include":
                    return this.parseInclude();
                  case "set":
                    return this.parseSet();
                  case "macro":
                    return this.parseMacro();
                  case "call":
                    return this.parseCall();
                  case "import":
                    return this.parseImport();
                  case "from":
                    return this.parseFrom();
                  case "filter":
                    return this.parseFilterStatement();
                  case "switch":
                    return this.parseSwitch();
                  default:
                    if (this.extensions.length) {
                      for (var i = 0; i < this.extensions.length; i++) {
                        var ext = this.extensions[i];
                        if (lib.indexOf(ext.tags || [], tok.value) !== -1) {
                          return ext.parse(this, nodes, lexer);
                        }
                      }
                    }
                    this.fail("unknown block tag: " + tok.value, tok.lineno, tok.colno);
                }
                return node;
              };
              _proto.parseRaw = function parseRaw(tagName) {
                tagName = tagName || "raw";
                var endTagName = "end" + tagName;
                var rawBlockRegex = new RegExp("([\\s\\S]*?){%\\s*(" + tagName + "|" + endTagName + ")\\s*(?=%})%}");
                var rawLevel = 1;
                var str = "";
                var matches = null;
                var begun = this.advanceAfterBlockEnd();
                while ((matches = this.tokens._extractRegex(rawBlockRegex)) && rawLevel > 0) {
                  var all = matches[0];
                  var pre = matches[1];
                  var blockName = matches[2];
                  if (blockName === tagName) {
                    rawLevel += 1;
                  } else if (blockName === endTagName) {
                    rawLevel -= 1;
                  }
                  if (rawLevel === 0) {
                    str += pre;
                    this.tokens.backN(all.length - pre.length);
                  } else {
                    str += all;
                  }
                }
                return new nodes.Output(begun.lineno, begun.colno, [new nodes.TemplateData(begun.lineno, begun.colno, str)]);
              };
              _proto.parsePostfix = function parsePostfix(node) {
                var lookup;
                var tok = this.peekToken();
                while (tok) {
                  if (tok.type === lexer.TOKEN_LEFT_PAREN) {
                    node = new nodes.FunCall(tok.lineno, tok.colno, node, this.parseSignature());
                  } else if (tok.type === lexer.TOKEN_LEFT_BRACKET) {
                    lookup = this.parseAggregate();
                    if (lookup.children.length > 1) {
                      this.fail("invalid index");
                    }
                    node = new nodes.LookupVal(tok.lineno, tok.colno, node, lookup.children[0]);
                  } else if (tok.type === lexer.TOKEN_OPERATOR && tok.value === ".") {
                    this.nextToken();
                    var val = this.nextToken();
                    if (val.type !== lexer.TOKEN_SYMBOL) {
                      this.fail("expected name as lookup value, got " + val.value, val.lineno, val.colno);
                    }
                    lookup = new nodes.Literal(val.lineno, val.colno, val.value);
                    node = new nodes.LookupVal(tok.lineno, tok.colno, node, lookup);
                  } else {
                    break;
                  }
                  tok = this.peekToken();
                }
                return node;
              };
              _proto.parseExpression = function parseExpression() {
                var node = this.parseInlineIf();
                return node;
              };
              _proto.parseInlineIf = function parseInlineIf() {
                var node = this.parseOr();
                if (this.skipSymbol("if")) {
                  var condNode = this.parseOr();
                  var bodyNode = node;
                  node = new nodes.InlineIf(node.lineno, node.colno);
                  node.body = bodyNode;
                  node.cond = condNode;
                  if (this.skipSymbol("else")) {
                    node.else_ = this.parseOr();
                  } else {
                    node.else_ = null;
                  }
                }
                return node;
              };
              _proto.parseOr = function parseOr() {
                var node = this.parseAnd();
                while (this.skipSymbol("or")) {
                  var node2 = this.parseAnd();
                  node = new nodes.Or(node.lineno, node.colno, node, node2);
                }
                return node;
              };
              _proto.parseAnd = function parseAnd() {
                var node = this.parseNot();
                while (this.skipSymbol("and")) {
                  var node2 = this.parseNot();
                  node = new nodes.And(node.lineno, node.colno, node, node2);
                }
                return node;
              };
              _proto.parseNot = function parseNot() {
                var tok = this.peekToken();
                if (this.skipSymbol("not")) {
                  return new nodes.Not(tok.lineno, tok.colno, this.parseNot());
                }
                return this.parseIn();
              };
              _proto.parseIn = function parseIn() {
                var node = this.parseIs();
                while (1) {
                  var tok = this.nextToken();
                  if (!tok) {
                    break;
                  }
                  var invert = tok.type === lexer.TOKEN_SYMBOL && tok.value === "not";
                  if (!invert) {
                    this.pushToken(tok);
                  }
                  if (this.skipSymbol("in")) {
                    var node2 = this.parseIs();
                    node = new nodes.In(node.lineno, node.colno, node, node2);
                    if (invert) {
                      node = new nodes.Not(node.lineno, node.colno, node);
                    }
                  } else {
                    if (invert) {
                      this.pushToken(tok);
                    }
                    break;
                  }
                }
                return node;
              };
              _proto.parseIs = function parseIs() {
                var node = this.parseCompare();
                if (this.skipSymbol("is")) {
                  var not = this.skipSymbol("not");
                  var node2 = this.parseCompare();
                  node = new nodes.Is(node.lineno, node.colno, node, node2);
                  if (not) {
                    node = new nodes.Not(node.lineno, node.colno, node);
                  }
                }
                return node;
              };
              _proto.parseCompare = function parseCompare() {
                var compareOps = ["==", "===", "!=", "!==", "<", ">", "<=", ">="];
                var expr = this.parseConcat();
                var ops = [];
                while (1) {
                  var tok = this.nextToken();
                  if (!tok) {
                    break;
                  } else if (compareOps.indexOf(tok.value) !== -1) {
                    ops.push(new nodes.CompareOperand(tok.lineno, tok.colno, this.parseConcat(), tok.value));
                  } else {
                    this.pushToken(tok);
                    break;
                  }
                }
                if (ops.length) {
                  return new nodes.Compare(ops[0].lineno, ops[0].colno, expr, ops);
                } else {
                  return expr;
                }
              };
              _proto.parseConcat = function parseConcat() {
                var node = this.parseAdd();
                while (this.skipValue(lexer.TOKEN_TILDE, "~")) {
                  var node2 = this.parseAdd();
                  node = new nodes.Concat(node.lineno, node.colno, node, node2);
                }
                return node;
              };
              _proto.parseAdd = function parseAdd() {
                var node = this.parseSub();
                while (this.skipValue(lexer.TOKEN_OPERATOR, "+")) {
                  var node2 = this.parseSub();
                  node = new nodes.Add(node.lineno, node.colno, node, node2);
                }
                return node;
              };
              _proto.parseSub = function parseSub() {
                var node = this.parseMul();
                while (this.skipValue(lexer.TOKEN_OPERATOR, "-")) {
                  var node2 = this.parseMul();
                  node = new nodes.Sub(node.lineno, node.colno, node, node2);
                }
                return node;
              };
              _proto.parseMul = function parseMul() {
                var node = this.parseDiv();
                while (this.skipValue(lexer.TOKEN_OPERATOR, "*")) {
                  var node2 = this.parseDiv();
                  node = new nodes.Mul(node.lineno, node.colno, node, node2);
                }
                return node;
              };
              _proto.parseDiv = function parseDiv() {
                var node = this.parseFloorDiv();
                while (this.skipValue(lexer.TOKEN_OPERATOR, "/")) {
                  var node2 = this.parseFloorDiv();
                  node = new nodes.Div(node.lineno, node.colno, node, node2);
                }
                return node;
              };
              _proto.parseFloorDiv = function parseFloorDiv() {
                var node = this.parseMod();
                while (this.skipValue(lexer.TOKEN_OPERATOR, "//")) {
                  var node2 = this.parseMod();
                  node = new nodes.FloorDiv(node.lineno, node.colno, node, node2);
                }
                return node;
              };
              _proto.parseMod = function parseMod() {
                var node = this.parsePow();
                while (this.skipValue(lexer.TOKEN_OPERATOR, "%")) {
                  var node2 = this.parsePow();
                  node = new nodes.Mod(node.lineno, node.colno, node, node2);
                }
                return node;
              };
              _proto.parsePow = function parsePow() {
                var node = this.parseUnary();
                while (this.skipValue(lexer.TOKEN_OPERATOR, "**")) {
                  var node2 = this.parseUnary();
                  node = new nodes.Pow(node.lineno, node.colno, node, node2);
                }
                return node;
              };
              _proto.parseUnary = function parseUnary(noFilters) {
                var tok = this.peekToken();
                var node;
                if (this.skipValue(lexer.TOKEN_OPERATOR, "-")) {
                  node = new nodes.Neg(tok.lineno, tok.colno, this.parseUnary(true));
                } else if (this.skipValue(lexer.TOKEN_OPERATOR, "+")) {
                  node = new nodes.Pos(tok.lineno, tok.colno, this.parseUnary(true));
                } else {
                  node = this.parsePrimary();
                }
                if (!noFilters) {
                  node = this.parseFilter(node);
                }
                return node;
              };
              _proto.parsePrimary = function parsePrimary(noPostfix) {
                var tok = this.nextToken();
                var val;
                var node = null;
                if (!tok) {
                  this.fail("expected expression, got end of file");
                } else if (tok.type === lexer.TOKEN_STRING) {
                  val = tok.value;
                } else if (tok.type === lexer.TOKEN_INT) {
                  val = parseInt(tok.value, 10);
                } else if (tok.type === lexer.TOKEN_FLOAT) {
                  val = parseFloat(tok.value);
                } else if (tok.type === lexer.TOKEN_BOOLEAN) {
                  if (tok.value === "true") {
                    val = true;
                  } else if (tok.value === "false") {
                    val = false;
                  } else {
                    this.fail("invalid boolean: " + tok.value, tok.lineno, tok.colno);
                  }
                } else if (tok.type === lexer.TOKEN_NONE) {
                  val = null;
                } else if (tok.type === lexer.TOKEN_REGEX) {
                  val = new RegExp(tok.value.body, tok.value.flags);
                }
                if (val !== void 0) {
                  node = new nodes.Literal(tok.lineno, tok.colno, val);
                } else if (tok.type === lexer.TOKEN_SYMBOL) {
                  node = new nodes.Symbol(tok.lineno, tok.colno, tok.value);
                } else {
                  this.pushToken(tok);
                  node = this.parseAggregate();
                }
                if (!noPostfix) {
                  node = this.parsePostfix(node);
                }
                if (node) {
                  return node;
                } else {
                  throw this.error("unexpected token: " + tok.value, tok.lineno, tok.colno);
                }
              };
              _proto.parseFilterName = function parseFilterName() {
                var tok = this.expect(lexer.TOKEN_SYMBOL);
                var name = tok.value;
                while (this.skipValue(lexer.TOKEN_OPERATOR, ".")) {
                  name += "." + this.expect(lexer.TOKEN_SYMBOL).value;
                }
                return new nodes.Symbol(tok.lineno, tok.colno, name);
              };
              _proto.parseFilterArgs = function parseFilterArgs(node) {
                if (this.peekToken().type === lexer.TOKEN_LEFT_PAREN) {
                  var call = this.parsePostfix(node);
                  return call.args.children;
                }
                return [];
              };
              _proto.parseFilter = function parseFilter(node) {
                while (this.skip(lexer.TOKEN_PIPE)) {
                  var name = this.parseFilterName();
                  node = new nodes.Filter(name.lineno, name.colno, name, new nodes.NodeList(name.lineno, name.colno, [node].concat(this.parseFilterArgs(node))));
                }
                return node;
              };
              _proto.parseFilterStatement = function parseFilterStatement() {
                var filterTok = this.peekToken();
                if (!this.skipSymbol("filter")) {
                  this.fail("parseFilterStatement: expected filter");
                }
                var name = this.parseFilterName();
                var args = this.parseFilterArgs(name);
                this.advanceAfterBlockEnd(filterTok.value);
                var body = new nodes.Capture(name.lineno, name.colno, this.parseUntilBlocks("endfilter"));
                this.advanceAfterBlockEnd();
                var node = new nodes.Filter(name.lineno, name.colno, name, new nodes.NodeList(name.lineno, name.colno, [body].concat(args)));
                return new nodes.Output(name.lineno, name.colno, [node]);
              };
              _proto.parseAggregate = function parseAggregate() {
                var tok = this.nextToken();
                var node;
                switch (tok.type) {
                  case lexer.TOKEN_LEFT_PAREN:
                    node = new nodes.Group(tok.lineno, tok.colno);
                    break;
                  case lexer.TOKEN_LEFT_BRACKET:
                    node = new nodes.Array(tok.lineno, tok.colno);
                    break;
                  case lexer.TOKEN_LEFT_CURLY:
                    node = new nodes.Dict(tok.lineno, tok.colno);
                    break;
                  default:
                    return null;
                }
                while (1) {
                  var type = this.peekToken().type;
                  if (type === lexer.TOKEN_RIGHT_PAREN || type === lexer.TOKEN_RIGHT_BRACKET || type === lexer.TOKEN_RIGHT_CURLY) {
                    this.nextToken();
                    break;
                  }
                  if (node.children.length > 0) {
                    if (!this.skip(lexer.TOKEN_COMMA)) {
                      this.fail("parseAggregate: expected comma after expression", tok.lineno, tok.colno);
                    }
                  }
                  if (node instanceof nodes.Dict) {
                    var key = this.parsePrimary();
                    if (!this.skip(lexer.TOKEN_COLON)) {
                      this.fail("parseAggregate: expected colon after dict key", tok.lineno, tok.colno);
                    }
                    var value = this.parseExpression();
                    node.addChild(new nodes.Pair(key.lineno, key.colno, key, value));
                  } else {
                    var expr = this.parseExpression();
                    node.addChild(expr);
                  }
                }
                return node;
              };
              _proto.parseSignature = function parseSignature(tolerant, noParens) {
                var tok = this.peekToken();
                if (!noParens && tok.type !== lexer.TOKEN_LEFT_PAREN) {
                  if (tolerant) {
                    return null;
                  } else {
                    this.fail("expected arguments", tok.lineno, tok.colno);
                  }
                }
                if (tok.type === lexer.TOKEN_LEFT_PAREN) {
                  tok = this.nextToken();
                }
                var args = new nodes.NodeList(tok.lineno, tok.colno);
                var kwargs = new nodes.KeywordArgs(tok.lineno, tok.colno);
                var checkComma = false;
                while (1) {
                  tok = this.peekToken();
                  if (!noParens && tok.type === lexer.TOKEN_RIGHT_PAREN) {
                    this.nextToken();
                    break;
                  } else if (noParens && tok.type === lexer.TOKEN_BLOCK_END) {
                    break;
                  }
                  if (checkComma && !this.skip(lexer.TOKEN_COMMA)) {
                    this.fail("parseSignature: expected comma after expression", tok.lineno, tok.colno);
                  } else {
                    var arg = this.parseExpression();
                    if (this.skipValue(lexer.TOKEN_OPERATOR, "=")) {
                      kwargs.addChild(new nodes.Pair(arg.lineno, arg.colno, arg, this.parseExpression()));
                    } else {
                      args.addChild(arg);
                    }
                  }
                  checkComma = true;
                }
                if (kwargs.children.length) {
                  args.addChild(kwargs);
                }
                return args;
              };
              _proto.parseUntilBlocks = function parseUntilBlocks() {
                var prev = this.breakOnBlocks;
                for (var _len = arguments.length, blockNames = new Array(_len), _key = 0; _key < _len; _key++) {
                  blockNames[_key] = arguments[_key];
                }
                this.breakOnBlocks = blockNames;
                var ret = this.parse();
                this.breakOnBlocks = prev;
                return ret;
              };
              _proto.parseNodes = function parseNodes() {
                var tok;
                var buf = [];
                while (tok = this.nextToken()) {
                  if (tok.type === lexer.TOKEN_DATA) {
                    var data = tok.value;
                    var nextToken = this.peekToken();
                    var nextVal = nextToken && nextToken.value;
                    if (this.dropLeadingWhitespace) {
                      data = data.replace(/^\s*/, "");
                      this.dropLeadingWhitespace = false;
                    }
                    if (nextToken && (nextToken.type === lexer.TOKEN_BLOCK_START && nextVal.charAt(nextVal.length - 1) === "-" || nextToken.type === lexer.TOKEN_VARIABLE_START && nextVal.charAt(this.tokens.tags.VARIABLE_START.length) === "-" || nextToken.type === lexer.TOKEN_COMMENT && nextVal.charAt(this.tokens.tags.COMMENT_START.length) === "-")) {
                      data = data.replace(/\s*$/, "");
                    }
                    buf.push(new nodes.Output(tok.lineno, tok.colno, [new nodes.TemplateData(tok.lineno, tok.colno, data)]));
                  } else if (tok.type === lexer.TOKEN_BLOCK_START) {
                    this.dropLeadingWhitespace = false;
                    var n = this.parseStatement();
                    if (!n) {
                      break;
                    }
                    buf.push(n);
                  } else if (tok.type === lexer.TOKEN_VARIABLE_START) {
                    var e = this.parseExpression();
                    this.dropLeadingWhitespace = false;
                    this.advanceAfterVariableEnd();
                    buf.push(new nodes.Output(tok.lineno, tok.colno, [e]));
                  } else if (tok.type === lexer.TOKEN_COMMENT) {
                    this.dropLeadingWhitespace = tok.value.charAt(tok.value.length - this.tokens.tags.COMMENT_END.length - 1) === "-";
                  } else {
                    this.fail("Unexpected token at top-level: " + tok.type, tok.lineno, tok.colno);
                  }
                }
                return buf;
              };
              _proto.parse = function parse() {
                return new nodes.NodeList(0, 0, this.parseNodes());
              };
              _proto.parseAsRoot = function parseAsRoot() {
                return new nodes.Root(0, 0, this.parseNodes());
              };
              return Parser2;
            }(Obj);
            module3.exports = {
              parse: function parse(src, extensions, opts) {
                var p = new Parser(lexer.lex(src, opts));
                if (extensions !== void 0) {
                  p.extensions = extensions;
                }
                return p.parseAsRoot();
              },
              Parser
            };
          },
          /* 9 */
          /***/
          function(module3, exports2, __webpack_require__) {
            "use strict";
            var lib = __webpack_require__(0);
            var whitespaceChars = " \n	\r\xA0";
            var delimChars = "()[]{}%*-+~/#,:|.<>=!";
            var intChars = "0123456789";
            var BLOCK_START = "{%";
            var BLOCK_END = "%}";
            var VARIABLE_START = "{{";
            var VARIABLE_END = "}}";
            var COMMENT_START = "{#";
            var COMMENT_END = "#}";
            var TOKEN_STRING = "string";
            var TOKEN_WHITESPACE = "whitespace";
            var TOKEN_DATA = "data";
            var TOKEN_BLOCK_START = "block-start";
            var TOKEN_BLOCK_END = "block-end";
            var TOKEN_VARIABLE_START = "variable-start";
            var TOKEN_VARIABLE_END = "variable-end";
            var TOKEN_COMMENT = "comment";
            var TOKEN_LEFT_PAREN = "left-paren";
            var TOKEN_RIGHT_PAREN = "right-paren";
            var TOKEN_LEFT_BRACKET = "left-bracket";
            var TOKEN_RIGHT_BRACKET = "right-bracket";
            var TOKEN_LEFT_CURLY = "left-curly";
            var TOKEN_RIGHT_CURLY = "right-curly";
            var TOKEN_OPERATOR = "operator";
            var TOKEN_COMMA = "comma";
            var TOKEN_COLON = "colon";
            var TOKEN_TILDE = "tilde";
            var TOKEN_PIPE = "pipe";
            var TOKEN_INT = "int";
            var TOKEN_FLOAT = "float";
            var TOKEN_BOOLEAN = "boolean";
            var TOKEN_NONE = "none";
            var TOKEN_SYMBOL = "symbol";
            var TOKEN_SPECIAL = "special";
            var TOKEN_REGEX = "regex";
            function token(type, value, lineno, colno) {
              return {
                type,
                value,
                lineno,
                colno
              };
            }
            var Tokenizer = /* @__PURE__ */ function() {
              function Tokenizer2(str, opts) {
                this.str = str;
                this.index = 0;
                this.len = str.length;
                this.lineno = 0;
                this.colno = 0;
                this.in_code = false;
                opts = opts || {};
                var tags = opts.tags || {};
                this.tags = {
                  BLOCK_START: tags.blockStart || BLOCK_START,
                  BLOCK_END: tags.blockEnd || BLOCK_END,
                  VARIABLE_START: tags.variableStart || VARIABLE_START,
                  VARIABLE_END: tags.variableEnd || VARIABLE_END,
                  COMMENT_START: tags.commentStart || COMMENT_START,
                  COMMENT_END: tags.commentEnd || COMMENT_END
                };
                this.trimBlocks = !!opts.trimBlocks;
                this.lstripBlocks = !!opts.lstripBlocks;
              }
              var _proto = Tokenizer2.prototype;
              _proto.nextToken = function nextToken() {
                var lineno = this.lineno;
                var colno = this.colno;
                var tok;
                if (this.in_code) {
                  var cur = this.current();
                  if (this.isFinished()) {
                    return null;
                  } else if (cur === '"' || cur === "'") {
                    return token(TOKEN_STRING, this._parseString(cur), lineno, colno);
                  } else if (tok = this._extract(whitespaceChars)) {
                    return token(TOKEN_WHITESPACE, tok, lineno, colno);
                  } else if ((tok = this._extractString(this.tags.BLOCK_END)) || (tok = this._extractString("-" + this.tags.BLOCK_END))) {
                    this.in_code = false;
                    if (this.trimBlocks) {
                      cur = this.current();
                      if (cur === "\n") {
                        this.forward();
                      } else if (cur === "\r") {
                        this.forward();
                        cur = this.current();
                        if (cur === "\n") {
                          this.forward();
                        } else {
                          this.back();
                        }
                      }
                    }
                    return token(TOKEN_BLOCK_END, tok, lineno, colno);
                  } else if ((tok = this._extractString(this.tags.VARIABLE_END)) || (tok = this._extractString("-" + this.tags.VARIABLE_END))) {
                    this.in_code = false;
                    return token(TOKEN_VARIABLE_END, tok, lineno, colno);
                  } else if (cur === "r" && this.str.charAt(this.index + 1) === "/") {
                    this.forwardN(2);
                    var regexBody = "";
                    while (!this.isFinished()) {
                      if (this.current() === "/" && this.previous() !== "\\") {
                        this.forward();
                        break;
                      } else {
                        regexBody += this.current();
                        this.forward();
                      }
                    }
                    var POSSIBLE_FLAGS = ["g", "i", "m", "y"];
                    var regexFlags = "";
                    while (!this.isFinished()) {
                      var isCurrentAFlag = POSSIBLE_FLAGS.indexOf(this.current()) !== -1;
                      if (isCurrentAFlag) {
                        regexFlags += this.current();
                        this.forward();
                      } else {
                        break;
                      }
                    }
                    return token(TOKEN_REGEX, {
                      body: regexBody,
                      flags: regexFlags
                    }, lineno, colno);
                  } else if (delimChars.indexOf(cur) !== -1) {
                    this.forward();
                    var complexOps = ["==", "===", "!=", "!==", "<=", ">=", "//", "**"];
                    var curComplex = cur + this.current();
                    var type;
                    if (lib.indexOf(complexOps, curComplex) !== -1) {
                      this.forward();
                      cur = curComplex;
                      if (lib.indexOf(complexOps, curComplex + this.current()) !== -1) {
                        cur = curComplex + this.current();
                        this.forward();
                      }
                    }
                    switch (cur) {
                      case "(":
                        type = TOKEN_LEFT_PAREN;
                        break;
                      case ")":
                        type = TOKEN_RIGHT_PAREN;
                        break;
                      case "[":
                        type = TOKEN_LEFT_BRACKET;
                        break;
                      case "]":
                        type = TOKEN_RIGHT_BRACKET;
                        break;
                      case "{":
                        type = TOKEN_LEFT_CURLY;
                        break;
                      case "}":
                        type = TOKEN_RIGHT_CURLY;
                        break;
                      case ",":
                        type = TOKEN_COMMA;
                        break;
                      case ":":
                        type = TOKEN_COLON;
                        break;
                      case "~":
                        type = TOKEN_TILDE;
                        break;
                      case "|":
                        type = TOKEN_PIPE;
                        break;
                      default:
                        type = TOKEN_OPERATOR;
                    }
                    return token(type, cur, lineno, colno);
                  } else {
                    tok = this._extractUntil(whitespaceChars + delimChars);
                    if (tok.match(/^[-+]?[0-9]+$/)) {
                      if (this.current() === ".") {
                        this.forward();
                        var dec = this._extract(intChars);
                        return token(TOKEN_FLOAT, tok + "." + dec, lineno, colno);
                      } else {
                        return token(TOKEN_INT, tok, lineno, colno);
                      }
                    } else if (tok.match(/^(true|false)$/)) {
                      return token(TOKEN_BOOLEAN, tok, lineno, colno);
                    } else if (tok === "none") {
                      return token(TOKEN_NONE, tok, lineno, colno);
                    } else if (tok === "null") {
                      return token(TOKEN_NONE, tok, lineno, colno);
                    } else if (tok) {
                      return token(TOKEN_SYMBOL, tok, lineno, colno);
                    } else {
                      throw new Error("Unexpected value while parsing: " + tok);
                    }
                  }
                } else {
                  var beginChars = this.tags.BLOCK_START.charAt(0) + this.tags.VARIABLE_START.charAt(0) + this.tags.COMMENT_START.charAt(0) + this.tags.COMMENT_END.charAt(0);
                  if (this.isFinished()) {
                    return null;
                  } else if ((tok = this._extractString(this.tags.BLOCK_START + "-")) || (tok = this._extractString(this.tags.BLOCK_START))) {
                    this.in_code = true;
                    return token(TOKEN_BLOCK_START, tok, lineno, colno);
                  } else if ((tok = this._extractString(this.tags.VARIABLE_START + "-")) || (tok = this._extractString(this.tags.VARIABLE_START))) {
                    this.in_code = true;
                    return token(TOKEN_VARIABLE_START, tok, lineno, colno);
                  } else {
                    tok = "";
                    var data;
                    var inComment = false;
                    if (this._matches(this.tags.COMMENT_START)) {
                      inComment = true;
                      tok = this._extractString(this.tags.COMMENT_START);
                    }
                    while ((data = this._extractUntil(beginChars)) !== null) {
                      tok += data;
                      if ((this._matches(this.tags.BLOCK_START) || this._matches(this.tags.VARIABLE_START) || this._matches(this.tags.COMMENT_START)) && !inComment) {
                        if (this.lstripBlocks && this._matches(this.tags.BLOCK_START) && this.colno > 0 && this.colno <= tok.length) {
                          var lastLine = tok.slice(-this.colno);
                          if (/^\s+$/.test(lastLine)) {
                            tok = tok.slice(0, -this.colno);
                            if (!tok.length) {
                              return this.nextToken();
                            }
                          }
                        }
                        break;
                      } else if (this._matches(this.tags.COMMENT_END)) {
                        if (!inComment) {
                          throw new Error("unexpected end of comment");
                        }
                        tok += this._extractString(this.tags.COMMENT_END);
                        break;
                      } else {
                        tok += this.current();
                        this.forward();
                      }
                    }
                    if (data === null && inComment) {
                      throw new Error("expected end of comment, got end of file");
                    }
                    return token(inComment ? TOKEN_COMMENT : TOKEN_DATA, tok, lineno, colno);
                  }
                }
              };
              _proto._parseString = function _parseString(delimiter) {
                this.forward();
                var str = "";
                while (!this.isFinished() && this.current() !== delimiter) {
                  var cur = this.current();
                  if (cur === "\\") {
                    this.forward();
                    switch (this.current()) {
                      case "n":
                        str += "\n";
                        break;
                      case "t":
                        str += "	";
                        break;
                      case "r":
                        str += "\r";
                        break;
                      default:
                        str += this.current();
                    }
                    this.forward();
                  } else {
                    str += cur;
                    this.forward();
                  }
                }
                this.forward();
                return str;
              };
              _proto._matches = function _matches(str) {
                if (this.index + str.length > this.len) {
                  return null;
                }
                var m = this.str.slice(this.index, this.index + str.length);
                return m === str;
              };
              _proto._extractString = function _extractString(str) {
                if (this._matches(str)) {
                  this.forwardN(str.length);
                  return str;
                }
                return null;
              };
              _proto._extractUntil = function _extractUntil(charString) {
                return this._extractMatching(true, charString || "");
              };
              _proto._extract = function _extract(charString) {
                return this._extractMatching(false, charString);
              };
              _proto._extractMatching = function _extractMatching(breakOnMatch, charString) {
                if (this.isFinished()) {
                  return null;
                }
                var first = charString.indexOf(this.current());
                if (breakOnMatch && first === -1 || !breakOnMatch && first !== -1) {
                  var t = this.current();
                  this.forward();
                  var idx = charString.indexOf(this.current());
                  while ((breakOnMatch && idx === -1 || !breakOnMatch && idx !== -1) && !this.isFinished()) {
                    t += this.current();
                    this.forward();
                    idx = charString.indexOf(this.current());
                  }
                  return t;
                }
                return "";
              };
              _proto._extractRegex = function _extractRegex(regex) {
                var matches = this.currentStr().match(regex);
                if (!matches) {
                  return null;
                }
                this.forwardN(matches[0].length);
                return matches;
              };
              _proto.isFinished = function isFinished() {
                return this.index >= this.len;
              };
              _proto.forwardN = function forwardN(n) {
                for (var i = 0; i < n; i++) {
                  this.forward();
                }
              };
              _proto.forward = function forward() {
                this.index++;
                if (this.previous() === "\n") {
                  this.lineno++;
                  this.colno = 0;
                } else {
                  this.colno++;
                }
              };
              _proto.backN = function backN(n) {
                for (var i = 0; i < n; i++) {
                  this.back();
                }
              };
              _proto.back = function back() {
                this.index--;
                if (this.current() === "\n") {
                  this.lineno--;
                  var idx = this.src.lastIndexOf("\n", this.index - 1);
                  if (idx === -1) {
                    this.colno = this.index;
                  } else {
                    this.colno = this.index - idx;
                  }
                } else {
                  this.colno--;
                }
              };
              _proto.current = function current() {
                if (!this.isFinished()) {
                  return this.str.charAt(this.index);
                }
                return "";
              };
              _proto.currentStr = function currentStr() {
                if (!this.isFinished()) {
                  return this.str.substr(this.index);
                }
                return "";
              };
              _proto.previous = function previous() {
                return this.str.charAt(this.index - 1);
              };
              return Tokenizer2;
            }();
            module3.exports = {
              lex: function lex(src, opts) {
                return new Tokenizer(src, opts);
              },
              TOKEN_STRING,
              TOKEN_WHITESPACE,
              TOKEN_DATA,
              TOKEN_BLOCK_START,
              TOKEN_BLOCK_END,
              TOKEN_VARIABLE_START,
              TOKEN_VARIABLE_END,
              TOKEN_COMMENT,
              TOKEN_LEFT_PAREN,
              TOKEN_RIGHT_PAREN,
              TOKEN_LEFT_BRACKET,
              TOKEN_RIGHT_BRACKET,
              TOKEN_LEFT_CURLY,
              TOKEN_RIGHT_CURLY,
              TOKEN_OPERATOR,
              TOKEN_COMMA,
              TOKEN_COLON,
              TOKEN_TILDE,
              TOKEN_PIPE,
              TOKEN_INT,
              TOKEN_FLOAT,
              TOKEN_BOOLEAN,
              TOKEN_NONE,
              TOKEN_SYMBOL,
              TOKEN_SPECIAL,
              TOKEN_REGEX
            };
          },
          /* 10 */
          /***/
          function(module3, exports2, __webpack_require__) {
            "use strict";
            function _inheritsLoose(subClass, superClass) {
              subClass.prototype = Object.create(superClass.prototype);
              subClass.prototype.constructor = subClass;
              _setPrototypeOf(subClass, superClass);
            }
            function _setPrototypeOf(o, p) {
              _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return _setPrototypeOf(o, p);
            }
            var Loader = __webpack_require__(6);
            var _require = __webpack_require__(19), PrecompiledLoader = _require.PrecompiledLoader;
            var WebLoader = /* @__PURE__ */ function(_Loader) {
              _inheritsLoose(WebLoader2, _Loader);
              function WebLoader2(baseURL, opts) {
                var _this;
                _this = _Loader.call(this) || this;
                _this.baseURL = baseURL || ".";
                opts = opts || {};
                _this.useCache = !!opts.useCache;
                _this.async = !!opts.async;
                return _this;
              }
              var _proto = WebLoader2.prototype;
              _proto.resolve = function resolve(from, to) {
                throw new Error("relative templates not support in the browser yet");
              };
              _proto.getSource = function getSource(name, cb) {
                var _this2 = this;
                var useCache = this.useCache;
                var result;
                this.fetch(this.baseURL + "/" + name, function(err, src) {
                  if (err) {
                    if (cb) {
                      cb(err.content);
                    } else if (err.status === 404) {
                      result = null;
                    } else {
                      throw err.content;
                    }
                  } else {
                    result = {
                      src,
                      path: name,
                      noCache: !useCache
                    };
                    _this2.emit("load", name, result);
                    if (cb) {
                      cb(null, result);
                    }
                  }
                });
                return result;
              };
              _proto.fetch = function fetch(url, cb) {
                if (typeof window === "undefined") {
                  throw new Error("WebLoader can only by used in a browser");
                }
                var ajax = new XMLHttpRequest();
                var loading = true;
                ajax.onreadystatechange = function() {
                  if (ajax.readyState === 4 && loading) {
                    loading = false;
                    if (ajax.status === 0 || ajax.status === 200) {
                      cb(null, ajax.responseText);
                    } else {
                      cb({
                        status: ajax.status,
                        content: ajax.responseText
                      });
                    }
                  }
                };
                url += (url.indexOf("?") === -1 ? "?" : "&") + "s=" + new Date().getTime();
                ajax.open("GET", url, this.async);
                ajax.send();
              };
              return WebLoader2;
            }(Loader);
            module3.exports = {
              WebLoader,
              PrecompiledLoader
            };
          },
          /* 11 */
          /***/
          function(module3, exports2, __webpack_require__) {
            "use strict";
            var lib = __webpack_require__(0);
            var _require = __webpack_require__(7), Environment = _require.Environment, Template = _require.Template;
            var Loader = __webpack_require__(6);
            var loaders = __webpack_require__(10);
            var precompile = __webpack_require__(23);
            var compiler = __webpack_require__(5);
            var parser = __webpack_require__(8);
            var lexer = __webpack_require__(9);
            var runtime = __webpack_require__(2);
            var nodes = __webpack_require__(3);
            var installJinjaCompat = __webpack_require__(25);
            var e;
            function configure(templatesPath, opts) {
              opts = opts || {};
              if (lib.isObject(templatesPath)) {
                opts = templatesPath;
                templatesPath = null;
              }
              var TemplateLoader;
              if (loaders.FileSystemLoader) {
                TemplateLoader = new loaders.FileSystemLoader(templatesPath, {
                  watch: opts.watch,
                  noCache: opts.noCache
                });
              } else if (loaders.WebLoader) {
                TemplateLoader = new loaders.WebLoader(templatesPath, {
                  useCache: opts.web && opts.web.useCache,
                  async: opts.web && opts.web.async
                });
              }
              e = new Environment(TemplateLoader, opts);
              if (opts && opts.express) {
                e.express(opts.express);
              }
              return e;
            }
            module3.exports = {
              Environment,
              Template,
              Loader,
              FileSystemLoader: loaders.FileSystemLoader,
              NodeResolveLoader: loaders.NodeResolveLoader,
              PrecompiledLoader: loaders.PrecompiledLoader,
              WebLoader: loaders.WebLoader,
              compiler,
              parser,
              lexer,
              runtime,
              lib,
              nodes,
              installJinjaCompat,
              configure,
              reset: function reset() {
                e = void 0;
              },
              compile: function compile(src, env2, path, eagerCompile) {
                if (!e) {
                  configure();
                }
                return new Template(src, env2, path, eagerCompile);
              },
              render: function render(name, ctx, cb) {
                if (!e) {
                  configure();
                }
                return e.render(name, ctx, cb);
              },
              renderString: function renderString(src, ctx, cb) {
                if (!e) {
                  configure();
                }
                return e.renderString(src, ctx, cb);
              },
              precompile: precompile ? precompile.precompile : void 0,
              precompileString: precompile ? precompile.precompileString : void 0
            };
          },
          /* 12 */
          /***/
          function(module3, exports2, __webpack_require__) {
            "use strict";
            var rawAsap = __webpack_require__(13);
            var freeTasks = [];
            var pendingErrors = [];
            var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);
            function throwFirstError() {
              if (pendingErrors.length) {
                throw pendingErrors.shift();
              }
            }
            module3.exports = asap;
            function asap(task) {
              var rawTask;
              if (freeTasks.length) {
                rawTask = freeTasks.pop();
              } else {
                rawTask = new RawTask();
              }
              rawTask.task = task;
              rawAsap(rawTask);
            }
            function RawTask() {
              this.task = null;
            }
            RawTask.prototype.call = function() {
              try {
                this.task.call();
              } catch (error) {
                if (asap.onerror) {
                  asap.onerror(error);
                } else {
                  pendingErrors.push(error);
                  requestErrorThrow();
                }
              } finally {
                this.task = null;
                freeTasks[freeTasks.length] = this;
              }
            };
          },
          /* 13 */
          /***/
          function(module3, exports2, __webpack_require__) {
            "use strict";
            (function(global2) {
              module3.exports = rawAsap;
              function rawAsap(task) {
                if (!queue.length) {
                  requestFlush();
                  flushing = true;
                }
                queue[queue.length] = task;
              }
              var queue = [];
              var flushing = false;
              var requestFlush;
              var index = 0;
              var capacity = 1024;
              function flush2() {
                while (index < queue.length) {
                  var currentIndex = index;
                  index = index + 1;
                  queue[currentIndex].call();
                  if (index > capacity) {
                    for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
                      queue[scan] = queue[scan + index];
                    }
                    queue.length -= index;
                    index = 0;
                  }
                }
                queue.length = 0;
                index = 0;
                flushing = false;
              }
              var scope = typeof global2 !== "undefined" ? global2 : self;
              var BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;
              if (typeof BrowserMutationObserver === "function") {
                requestFlush = makeRequestCallFromMutationObserver(flush2);
              } else {
                requestFlush = makeRequestCallFromTimer(flush2);
              }
              rawAsap.requestFlush = requestFlush;
              function makeRequestCallFromMutationObserver(callback) {
                var toggle = 1;
                var observer = new BrowserMutationObserver(callback);
                var node = document.createTextNode("");
                observer.observe(node, { characterData: true });
                return function requestCall() {
                  toggle = -toggle;
                  node.data = toggle;
                };
              }
              function makeRequestCallFromTimer(callback) {
                return function requestCall() {
                  var timeoutHandle = setTimeout(handleTimer, 0);
                  var intervalHandle = setInterval(handleTimer, 50);
                  function handleTimer() {
                    clearTimeout(timeoutHandle);
                    clearInterval(intervalHandle);
                    callback();
                  }
                };
              }
              rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;
            }).call(exports2, __webpack_require__(14));
          },
          /* 14 */
          /***/
          function(module3, exports2) {
            var g;
            g = function() {
              return this;
            }();
            try {
              g = g || Function("return this")() || (1, eval)("this");
            } catch (e) {
              if (typeof window === "object")
                g = window;
            }
            module3.exports = g;
          },
          /* 15 */
          /***/
          function(module3, exports2, __webpack_require__) {
            var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
            (function(globals2) {
              "use strict";
              var executeSync = function() {
                var args = Array.prototype.slice.call(arguments);
                if (typeof args[0] === "function") {
                  args[0].apply(null, args.splice(1));
                }
              };
              var executeAsync = function(fn) {
                if (typeof setImmediate === "function") {
                  setImmediate(fn);
                } else if (typeof process !== "undefined" && process.nextTick) {
                  process.nextTick(fn);
                } else {
                  setTimeout(fn, 0);
                }
              };
              var makeIterator = function(tasks2) {
                var makeCallback = function(index) {
                  var fn = function() {
                    if (tasks2.length) {
                      tasks2[index].apply(null, arguments);
                    }
                    return fn.next();
                  };
                  fn.next = function() {
                    return index < tasks2.length - 1 ? makeCallback(index + 1) : null;
                  };
                  return fn;
                };
                return makeCallback(0);
              };
              var _isArray = Array.isArray || function(maybeArray) {
                return Object.prototype.toString.call(maybeArray) === "[object Array]";
              };
              var waterfall = function(tasks2, callback, forceAsync) {
                var nextTick = forceAsync ? executeAsync : executeSync;
                callback = callback || function() {
                };
                if (!_isArray(tasks2)) {
                  var err = new Error("First argument to waterfall must be an array of functions");
                  return callback(err);
                }
                if (!tasks2.length) {
                  return callback();
                }
                var wrapIterator = function(iterator) {
                  return function(err2) {
                    if (err2) {
                      callback.apply(null, arguments);
                      callback = function() {
                      };
                    } else {
                      var args = Array.prototype.slice.call(arguments, 1);
                      var next = iterator.next();
                      if (next) {
                        args.push(wrapIterator(next));
                      } else {
                        args.push(callback);
                      }
                      nextTick(function() {
                        iterator.apply(null, args);
                      });
                    }
                  };
                };
                wrapIterator(makeIterator(tasks2))();
              };
              if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
                  return waterfall;
                }.apply(exports2, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module3.exports = __WEBPACK_AMD_DEFINE_RESULT__));
              } else if (typeof module3 !== "undefined" && module3.exports) {
                module3.exports = waterfall;
              } else {
                globals2.waterfall = waterfall;
              }
            })(this);
          },
          /* 16 */
          /***/
          function(module3, exports2, __webpack_require__) {
            "use strict";
            var R = typeof Reflect === "object" ? Reflect : null;
            var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
              return Function.prototype.apply.call(target, receiver, args);
            };
            var ReflectOwnKeys;
            if (R && typeof R.ownKeys === "function") {
              ReflectOwnKeys = R.ownKeys;
            } else if (Object.getOwnPropertySymbols) {
              ReflectOwnKeys = function ReflectOwnKeys2(target) {
                return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
              };
            } else {
              ReflectOwnKeys = function ReflectOwnKeys2(target) {
                return Object.getOwnPropertyNames(target);
              };
            }
            function ProcessEmitWarning(warning) {
              if (console && console.warn)
                console.warn(warning);
            }
            var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
              return value !== value;
            };
            function EventEmitter() {
              EventEmitter.init.call(this);
            }
            module3.exports = EventEmitter;
            module3.exports.once = once;
            EventEmitter.EventEmitter = EventEmitter;
            EventEmitter.prototype._events = void 0;
            EventEmitter.prototype._eventsCount = 0;
            EventEmitter.prototype._maxListeners = void 0;
            var defaultMaxListeners = 10;
            function checkListener(listener) {
              if (typeof listener !== "function") {
                throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
              }
            }
            Object.defineProperty(EventEmitter, "defaultMaxListeners", {
              enumerable: true,
              get: function() {
                return defaultMaxListeners;
              },
              set: function(arg) {
                if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
                  throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
                }
                defaultMaxListeners = arg;
              }
            });
            EventEmitter.init = function() {
              if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
                this._events = /* @__PURE__ */ Object.create(null);
                this._eventsCount = 0;
              }
              this._maxListeners = this._maxListeners || void 0;
            };
            EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
              if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
                throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
              }
              this._maxListeners = n;
              return this;
            };
            function _getMaxListeners(that) {
              if (that._maxListeners === void 0)
                return EventEmitter.defaultMaxListeners;
              return that._maxListeners;
            }
            EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
              return _getMaxListeners(this);
            };
            EventEmitter.prototype.emit = function emit(type) {
              var args = [];
              for (var i = 1; i < arguments.length; i++)
                args.push(arguments[i]);
              var doError = type === "error";
              var events = this._events;
              if (events !== void 0)
                doError = doError && events.error === void 0;
              else if (!doError)
                return false;
              if (doError) {
                var er;
                if (args.length > 0)
                  er = args[0];
                if (er instanceof Error) {
                  throw er;
                }
                var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
                err.context = er;
                throw err;
              }
              var handler = events[type];
              if (handler === void 0)
                return false;
              if (typeof handler === "function") {
                ReflectApply(handler, this, args);
              } else {
                var len = handler.length;
                var listeners = arrayClone(handler, len);
                for (var i = 0; i < len; ++i)
                  ReflectApply(listeners[i], this, args);
              }
              return true;
            };
            function _addListener(target, type, listener, prepend) {
              var m;
              var events;
              var existing;
              checkListener(listener);
              events = target._events;
              if (events === void 0) {
                events = target._events = /* @__PURE__ */ Object.create(null);
                target._eventsCount = 0;
              } else {
                if (events.newListener !== void 0) {
                  target.emit(
                    "newListener",
                    type,
                    listener.listener ? listener.listener : listener
                  );
                  events = target._events;
                }
                existing = events[type];
              }
              if (existing === void 0) {
                existing = events[type] = listener;
                ++target._eventsCount;
              } else {
                if (typeof existing === "function") {
                  existing = events[type] = prepend ? [listener, existing] : [existing, listener];
                } else if (prepend) {
                  existing.unshift(listener);
                } else {
                  existing.push(listener);
                }
                m = _getMaxListeners(target);
                if (m > 0 && existing.length > m && !existing.warned) {
                  existing.warned = true;
                  var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                  w.name = "MaxListenersExceededWarning";
                  w.emitter = target;
                  w.type = type;
                  w.count = existing.length;
                  ProcessEmitWarning(w);
                }
              }
              return target;
            }
            EventEmitter.prototype.addListener = function addListener(type, listener) {
              return _addListener(this, type, listener, false);
            };
            EventEmitter.prototype.on = EventEmitter.prototype.addListener;
            EventEmitter.prototype.prependListener = function prependListener(type, listener) {
              return _addListener(this, type, listener, true);
            };
            function onceWrapper() {
              if (!this.fired) {
                this.target.removeListener(this.type, this.wrapFn);
                this.fired = true;
                if (arguments.length === 0)
                  return this.listener.call(this.target);
                return this.listener.apply(this.target, arguments);
              }
            }
            function _onceWrap(target, type, listener) {
              var state = { fired: false, wrapFn: void 0, target, type, listener };
              var wrapped = onceWrapper.bind(state);
              wrapped.listener = listener;
              state.wrapFn = wrapped;
              return wrapped;
            }
            EventEmitter.prototype.once = function once2(type, listener) {
              checkListener(listener);
              this.on(type, _onceWrap(this, type, listener));
              return this;
            };
            EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
              checkListener(listener);
              this.prependListener(type, _onceWrap(this, type, listener));
              return this;
            };
            EventEmitter.prototype.removeListener = function removeListener(type, listener) {
              var list, events, position, i, originalListener;
              checkListener(listener);
              events = this._events;
              if (events === void 0)
                return this;
              list = events[type];
              if (list === void 0)
                return this;
              if (list === listener || list.listener === listener) {
                if (--this._eventsCount === 0)
                  this._events = /* @__PURE__ */ Object.create(null);
                else {
                  delete events[type];
                  if (events.removeListener)
                    this.emit("removeListener", type, list.listener || listener);
                }
              } else if (typeof list !== "function") {
                position = -1;
                for (i = list.length - 1; i >= 0; i--) {
                  if (list[i] === listener || list[i].listener === listener) {
                    originalListener = list[i].listener;
                    position = i;
                    break;
                  }
                }
                if (position < 0)
                  return this;
                if (position === 0)
                  list.shift();
                else {
                  spliceOne(list, position);
                }
                if (list.length === 1)
                  events[type] = list[0];
                if (events.removeListener !== void 0)
                  this.emit("removeListener", type, originalListener || listener);
              }
              return this;
            };
            EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
            EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
              var listeners, events, i;
              events = this._events;
              if (events === void 0)
                return this;
              if (events.removeListener === void 0) {
                if (arguments.length === 0) {
                  this._events = /* @__PURE__ */ Object.create(null);
                  this._eventsCount = 0;
                } else if (events[type] !== void 0) {
                  if (--this._eventsCount === 0)
                    this._events = /* @__PURE__ */ Object.create(null);
                  else
                    delete events[type];
                }
                return this;
              }
              if (arguments.length === 0) {
                var keys = Object.keys(events);
                var key;
                for (i = 0; i < keys.length; ++i) {
                  key = keys[i];
                  if (key === "removeListener")
                    continue;
                  this.removeAllListeners(key);
                }
                this.removeAllListeners("removeListener");
                this._events = /* @__PURE__ */ Object.create(null);
                this._eventsCount = 0;
                return this;
              }
              listeners = events[type];
              if (typeof listeners === "function") {
                this.removeListener(type, listeners);
              } else if (listeners !== void 0) {
                for (i = listeners.length - 1; i >= 0; i--) {
                  this.removeListener(type, listeners[i]);
                }
              }
              return this;
            };
            function _listeners(target, type, unwrap) {
              var events = target._events;
              if (events === void 0)
                return [];
              var evlistener = events[type];
              if (evlistener === void 0)
                return [];
              if (typeof evlistener === "function")
                return unwrap ? [evlistener.listener || evlistener] : [evlistener];
              return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
            }
            EventEmitter.prototype.listeners = function listeners(type) {
              return _listeners(this, type, true);
            };
            EventEmitter.prototype.rawListeners = function rawListeners(type) {
              return _listeners(this, type, false);
            };
            EventEmitter.listenerCount = function(emitter, type) {
              if (typeof emitter.listenerCount === "function") {
                return emitter.listenerCount(type);
              } else {
                return listenerCount.call(emitter, type);
              }
            };
            EventEmitter.prototype.listenerCount = listenerCount;
            function listenerCount(type) {
              var events = this._events;
              if (events !== void 0) {
                var evlistener = events[type];
                if (typeof evlistener === "function") {
                  return 1;
                } else if (evlistener !== void 0) {
                  return evlistener.length;
                }
              }
              return 0;
            }
            EventEmitter.prototype.eventNames = function eventNames() {
              return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
            };
            function arrayClone(arr, n) {
              var copy = new Array(n);
              for (var i = 0; i < n; ++i)
                copy[i] = arr[i];
              return copy;
            }
            function spliceOne(list, index) {
              for (; index + 1 < list.length; index++)
                list[index] = list[index + 1];
              list.pop();
            }
            function unwrapListeners(arr) {
              var ret = new Array(arr.length);
              for (var i = 0; i < ret.length; ++i) {
                ret[i] = arr[i].listener || arr[i];
              }
              return ret;
            }
            function once(emitter, name) {
              return new Promise(function(resolve, reject) {
                function errorListener(err) {
                  emitter.removeListener(name, resolver);
                  reject(err);
                }
                function resolver() {
                  if (typeof emitter.removeListener === "function") {
                    emitter.removeListener("error", errorListener);
                  }
                  resolve([].slice.call(arguments));
                }
                ;
                eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
                if (name !== "error") {
                  addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
                }
              });
            }
            function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
              if (typeof emitter.on === "function") {
                eventTargetAgnosticAddListener(emitter, "error", handler, flags);
              }
            }
            function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
              if (typeof emitter.on === "function") {
                if (flags.once) {
                  emitter.once(name, listener);
                } else {
                  emitter.on(name, listener);
                }
              } else if (typeof emitter.addEventListener === "function") {
                emitter.addEventListener(name, function wrapListener(arg) {
                  if (flags.once) {
                    emitter.removeEventListener(name, wrapListener);
                  }
                  listener(arg);
                });
              } else {
                throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
              }
            }
          },
          /* 17 */
          /***/
          function(module3, exports2, __webpack_require__) {
            "use strict";
            var nodes = __webpack_require__(3);
            var lib = __webpack_require__(0);
            var sym = 0;
            function gensym() {
              return "hole_" + sym++;
            }
            function mapCOW(arr, func) {
              var res = null;
              for (var i = 0; i < arr.length; i++) {
                var item = func(arr[i]);
                if (item !== arr[i]) {
                  if (!res) {
                    res = arr.slice();
                  }
                  res[i] = item;
                }
              }
              return res || arr;
            }
            function walk(ast, func, depthFirst) {
              if (!(ast instanceof nodes.Node)) {
                return ast;
              }
              if (!depthFirst) {
                var astT = func(ast);
                if (astT && astT !== ast) {
                  return astT;
                }
              }
              if (ast instanceof nodes.NodeList) {
                var children2 = mapCOW(ast.children, function(node) {
                  return walk(node, func, depthFirst);
                });
                if (children2 !== ast.children) {
                  ast = new nodes[ast.typename](ast.lineno, ast.colno, children2);
                }
              } else if (ast instanceof nodes.CallExtension) {
                var args = walk(ast.args, func, depthFirst);
                var contentArgs = mapCOW(ast.contentArgs, function(node) {
                  return walk(node, func, depthFirst);
                });
                if (args !== ast.args || contentArgs !== ast.contentArgs) {
                  ast = new nodes[ast.typename](ast.extName, ast.prop, args, contentArgs);
                }
              } else {
                var props = ast.fields.map(function(field) {
                  return ast[field];
                });
                var propsT = mapCOW(props, function(prop) {
                  return walk(prop, func, depthFirst);
                });
                if (propsT !== props) {
                  ast = new nodes[ast.typename](ast.lineno, ast.colno);
                  propsT.forEach(function(prop, i) {
                    ast[ast.fields[i]] = prop;
                  });
                }
              }
              return depthFirst ? func(ast) || ast : ast;
            }
            function depthWalk(ast, func) {
              return walk(ast, func, true);
            }
            function _liftFilters(node, asyncFilters, prop) {
              var children2 = [];
              var walked = depthWalk(prop ? node[prop] : node, function(descNode) {
                var symbol;
                if (descNode instanceof nodes.Block) {
                  return descNode;
                } else if (descNode instanceof nodes.Filter && lib.indexOf(asyncFilters, descNode.name.value) !== -1 || descNode instanceof nodes.CallExtensionAsync) {
                  symbol = new nodes.Symbol(descNode.lineno, descNode.colno, gensym());
                  children2.push(new nodes.FilterAsync(descNode.lineno, descNode.colno, descNode.name, descNode.args, symbol));
                }
                return symbol;
              });
              if (prop) {
                node[prop] = walked;
              } else {
                node = walked;
              }
              if (children2.length) {
                children2.push(node);
                return new nodes.NodeList(node.lineno, node.colno, children2);
              } else {
                return node;
              }
            }
            function liftFilters(ast, asyncFilters) {
              return depthWalk(ast, function(node) {
                if (node instanceof nodes.Output) {
                  return _liftFilters(node, asyncFilters);
                } else if (node instanceof nodes.Set) {
                  return _liftFilters(node, asyncFilters, "value");
                } else if (node instanceof nodes.For) {
                  return _liftFilters(node, asyncFilters, "arr");
                } else if (node instanceof nodes.If) {
                  return _liftFilters(node, asyncFilters, "cond");
                } else if (node instanceof nodes.CallExtension) {
                  return _liftFilters(node, asyncFilters, "args");
                } else {
                  return void 0;
                }
              });
            }
            function liftSuper(ast) {
              return walk(ast, function(blockNode) {
                if (!(blockNode instanceof nodes.Block)) {
                  return;
                }
                var hasSuper = false;
                var symbol = gensym();
                blockNode.body = walk(blockNode.body, function(node) {
                  if (node instanceof nodes.FunCall && node.name.value === "super") {
                    hasSuper = true;
                    return new nodes.Symbol(node.lineno, node.colno, symbol);
                  }
                });
                if (hasSuper) {
                  blockNode.body.children.unshift(new nodes.Super(0, 0, blockNode.name, new nodes.Symbol(0, 0, symbol)));
                }
              });
            }
            function convertStatements(ast) {
              return depthWalk(ast, function(node) {
                if (!(node instanceof nodes.If) && !(node instanceof nodes.For)) {
                  return void 0;
                }
                var async = false;
                walk(node, function(child) {
                  if (child instanceof nodes.FilterAsync || child instanceof nodes.IfAsync || child instanceof nodes.AsyncEach || child instanceof nodes.AsyncAll || child instanceof nodes.CallExtensionAsync) {
                    async = true;
                    return child;
                  }
                  return void 0;
                });
                if (async) {
                  if (node instanceof nodes.If) {
                    return new nodes.IfAsync(node.lineno, node.colno, node.cond, node.body, node.else_);
                  } else if (node instanceof nodes.For && !(node instanceof nodes.AsyncAll)) {
                    return new nodes.AsyncEach(node.lineno, node.colno, node.arr, node.name, node.body, node.else_);
                  }
                }
                return void 0;
              });
            }
            function cps(ast, asyncFilters) {
              return convertStatements(liftSuper(liftFilters(ast, asyncFilters)));
            }
            function transform(ast, asyncFilters) {
              return cps(ast, asyncFilters || []);
            }
            module3.exports = {
              transform
            };
          },
          /* 18 */
          /***/
          function(module3, exports2, __webpack_require__) {
            "use strict";
            var lib = __webpack_require__(0);
            var r = __webpack_require__(2);
            var exports2 = module3.exports = {};
            function normalize(value, defaultValue) {
              if (value === null || value === void 0 || value === false) {
                return defaultValue;
              }
              return value;
            }
            exports2.abs = Math.abs;
            function isNaN(num) {
              return num !== num;
            }
            function batch(arr, linecount, fillWith) {
              var i;
              var res = [];
              var tmp = [];
              for (i = 0; i < arr.length; i++) {
                if (i % linecount === 0 && tmp.length) {
                  res.push(tmp);
                  tmp = [];
                }
                tmp.push(arr[i]);
              }
              if (tmp.length) {
                if (fillWith) {
                  for (i = tmp.length; i < linecount; i++) {
                    tmp.push(fillWith);
                  }
                }
                res.push(tmp);
              }
              return res;
            }
            exports2.batch = batch;
            function capitalize(str) {
              str = normalize(str, "");
              var ret = str.toLowerCase();
              return r.copySafeness(str, ret.charAt(0).toUpperCase() + ret.slice(1));
            }
            exports2.capitalize = capitalize;
            function center(str, width) {
              str = normalize(str, "");
              width = width || 80;
              if (str.length >= width) {
                return str;
              }
              var spaces = width - str.length;
              var pre = lib.repeat(" ", spaces / 2 - spaces % 2);
              var post = lib.repeat(" ", spaces / 2);
              return r.copySafeness(str, pre + str + post);
            }
            exports2.center = center;
            function default_(val, def, bool) {
              if (bool) {
                return val || def;
              } else {
                return val !== void 0 ? val : def;
              }
            }
            exports2["default"] = default_;
            function dictsort(val, caseSensitive, by) {
              if (!lib.isObject(val)) {
                throw new lib.TemplateError("dictsort filter: val must be an object");
              }
              var array = [];
              for (var k in val) {
                array.push([k, val[k]]);
              }
              var si;
              if (by === void 0 || by === "key") {
                si = 0;
              } else if (by === "value") {
                si = 1;
              } else {
                throw new lib.TemplateError("dictsort filter: You can only sort by either key or value");
              }
              array.sort(function(t1, t2) {
                var a = t1[si];
                var b = t2[si];
                if (!caseSensitive) {
                  if (lib.isString(a)) {
                    a = a.toUpperCase();
                  }
                  if (lib.isString(b)) {
                    b = b.toUpperCase();
                  }
                }
                return a > b ? 1 : a === b ? 0 : -1;
              });
              return array;
            }
            exports2.dictsort = dictsort;
            function dump(obj, spaces) {
              return JSON.stringify(obj, null, spaces);
            }
            exports2.dump = dump;
            function escape2(str) {
              if (str instanceof r.SafeString) {
                return str;
              }
              str = str === null || str === void 0 ? "" : str;
              return r.markSafe(lib.escape(str.toString()));
            }
            exports2.escape = escape2;
            function safe(str) {
              if (str instanceof r.SafeString) {
                return str;
              }
              str = str === null || str === void 0 ? "" : str;
              return r.markSafe(str.toString());
            }
            exports2.safe = safe;
            function first(arr) {
              return arr[0];
            }
            exports2.first = first;
            function forceescape(str) {
              str = str === null || str === void 0 ? "" : str;
              return r.markSafe(lib.escape(str.toString()));
            }
            exports2.forceescape = forceescape;
            function groupby(arr, attr2) {
              return lib.groupBy(arr, attr2, this.env.opts.throwOnUndefined);
            }
            exports2.groupby = groupby;
            function indent(str, width, indentfirst) {
              str = normalize(str, "");
              if (str === "") {
                return "";
              }
              width = width || 4;
              var lines = str.split("\n");
              var sp = lib.repeat(" ", width);
              var res = lines.map(function(l, i) {
                return i === 0 && !indentfirst ? l : "" + sp + l;
              }).join("\n");
              return r.copySafeness(str, res);
            }
            exports2.indent = indent;
            function join(arr, del, attr2) {
              del = del || "";
              if (attr2) {
                arr = lib.map(arr, function(v) {
                  return v[attr2];
                });
              }
              return arr.join(del);
            }
            exports2.join = join;
            function last(arr) {
              return arr[arr.length - 1];
            }
            exports2.last = last;
            function lengthFilter(val) {
              var value = normalize(val, "");
              if (value !== void 0) {
                if (typeof Map === "function" && value instanceof Map || typeof Set === "function" && value instanceof Set) {
                  return value.size;
                }
                if (lib.isObject(value) && !(value instanceof r.SafeString)) {
                  return lib.keys(value).length;
                }
                return value.length;
              }
              return 0;
            }
            exports2.length = lengthFilter;
            function list(val) {
              if (lib.isString(val)) {
                return val.split("");
              } else if (lib.isObject(val)) {
                return lib._entries(val || {}).map(function(_ref) {
                  var key = _ref[0], value = _ref[1];
                  return {
                    key,
                    value
                  };
                });
              } else if (lib.isArray(val)) {
                return val;
              } else {
                throw new lib.TemplateError("list filter: type not iterable");
              }
            }
            exports2.list = list;
            function lower(str) {
              str = normalize(str, "");
              return str.toLowerCase();
            }
            exports2.lower = lower;
            function nl2br(str) {
              if (str === null || str === void 0) {
                return "";
              }
              return r.copySafeness(str, str.replace(/\r\n|\n/g, "<br />\n"));
            }
            exports2.nl2br = nl2br;
            function random(arr) {
              return arr[Math.floor(Math.random() * arr.length)];
            }
            exports2.random = random;
            function getSelectOrReject(expectedTestResult) {
              function filter(arr, testName, secondArg) {
                if (testName === void 0) {
                  testName = "truthy";
                }
                var context = this;
                var test = context.env.getTest(testName);
                return lib.toArray(arr).filter(function examineTestResult(item) {
                  return test.call(context, item, secondArg) === expectedTestResult;
                });
              }
              return filter;
            }
            exports2.reject = getSelectOrReject(false);
            function rejectattr(arr, attr2) {
              return arr.filter(function(item) {
                return !item[attr2];
              });
            }
            exports2.rejectattr = rejectattr;
            exports2.select = getSelectOrReject(true);
            function selectattr(arr, attr2) {
              return arr.filter(function(item) {
                return !!item[attr2];
              });
            }
            exports2.selectattr = selectattr;
            function replace(str, old, new_, maxCount) {
              var originalStr = str;
              if (old instanceof RegExp) {
                return str.replace(old, new_);
              }
              if (typeof maxCount === "undefined") {
                maxCount = -1;
              }
              var res = "";
              if (typeof old === "number") {
                old = "" + old;
              } else if (typeof old !== "string") {
                return str;
              }
              if (typeof str === "number") {
                str = "" + str;
              }
              if (typeof str !== "string" && !(str instanceof r.SafeString)) {
                return str;
              }
              if (old === "") {
                res = new_ + str.split("").join(new_) + new_;
                return r.copySafeness(str, res);
              }
              var nextIndex = str.indexOf(old);
              if (maxCount === 0 || nextIndex === -1) {
                return str;
              }
              var pos = 0;
              var count = 0;
              while (nextIndex > -1 && (maxCount === -1 || count < maxCount)) {
                res += str.substring(pos, nextIndex) + new_;
                pos = nextIndex + old.length;
                count++;
                nextIndex = str.indexOf(old, pos);
              }
              if (pos < str.length) {
                res += str.substring(pos);
              }
              return r.copySafeness(originalStr, res);
            }
            exports2.replace = replace;
            function reverse(val) {
              var arr;
              if (lib.isString(val)) {
                arr = list(val);
              } else {
                arr = lib.map(val, function(v) {
                  return v;
                });
              }
              arr.reverse();
              if (lib.isString(val)) {
                return r.copySafeness(val, arr.join(""));
              }
              return arr;
            }
            exports2.reverse = reverse;
            function round(val, precision, method) {
              precision = precision || 0;
              var factor = Math.pow(10, precision);
              var rounder;
              if (method === "ceil") {
                rounder = Math.ceil;
              } else if (method === "floor") {
                rounder = Math.floor;
              } else {
                rounder = Math.round;
              }
              return rounder(val * factor) / factor;
            }
            exports2.round = round;
            function slice(arr, slices, fillWith) {
              var sliceLength = Math.floor(arr.length / slices);
              var extra = arr.length % slices;
              var res = [];
              var offset = 0;
              for (var i = 0; i < slices; i++) {
                var start = offset + i * sliceLength;
                if (i < extra) {
                  offset++;
                }
                var end = offset + (i + 1) * sliceLength;
                var currSlice = arr.slice(start, end);
                if (fillWith && i >= extra) {
                  currSlice.push(fillWith);
                }
                res.push(currSlice);
              }
              return res;
            }
            exports2.slice = slice;
            function sum(arr, attr2, start) {
              if (start === void 0) {
                start = 0;
              }
              if (attr2) {
                arr = lib.map(arr, function(v) {
                  return v[attr2];
                });
              }
              return start + arr.reduce(function(a, b) {
                return a + b;
              }, 0);
            }
            exports2.sum = sum;
            exports2.sort = r.makeMacro(["value", "reverse", "case_sensitive", "attribute"], [], function sortFilter(arr, reversed, caseSens, attr2) {
              var _this = this;
              var array = lib.map(arr, function(v) {
                return v;
              });
              var getAttribute = lib.getAttrGetter(attr2);
              array.sort(function(a, b) {
                var x = attr2 ? getAttribute(a) : a;
                var y = attr2 ? getAttribute(b) : b;
                if (_this.env.opts.throwOnUndefined && attr2 && (x === void 0 || y === void 0)) {
                  throw new TypeError('sort: attribute "' + attr2 + '" resolved to undefined');
                }
                if (!caseSens && lib.isString(x) && lib.isString(y)) {
                  x = x.toLowerCase();
                  y = y.toLowerCase();
                }
                if (x < y) {
                  return reversed ? 1 : -1;
                } else if (x > y) {
                  return reversed ? -1 : 1;
                } else {
                  return 0;
                }
              });
              return array;
            });
            function string(obj) {
              return r.copySafeness(obj, obj);
            }
            exports2.string = string;
            function striptags(input, preserveLinebreaks) {
              input = normalize(input, "");
              var tags = /<\/?([a-z][a-z0-9]*)\b[^>]*>|<!--[\s\S]*?-->/gi;
              var trimmedInput = trim(input.replace(tags, ""));
              var res = "";
              if (preserveLinebreaks) {
                res = trimmedInput.replace(/^ +| +$/gm, "").replace(/ +/g, " ").replace(/(\r\n)/g, "\n").replace(/\n\n\n+/g, "\n\n");
              } else {
                res = trimmedInput.replace(/\s+/gi, " ");
              }
              return r.copySafeness(input, res);
            }
            exports2.striptags = striptags;
            function title(str) {
              str = normalize(str, "");
              var words = str.split(" ").map(function(word) {
                return capitalize(word);
              });
              return r.copySafeness(str, words.join(" "));
            }
            exports2.title = title;
            function trim(str) {
              return r.copySafeness(str, str.replace(/^\s*|\s*$/g, ""));
            }
            exports2.trim = trim;
            function truncate(input, length, killwords, end) {
              var orig = input;
              input = normalize(input, "");
              length = length || 255;
              if (input.length <= length) {
                return input;
              }
              if (killwords) {
                input = input.substring(0, length);
              } else {
                var idx = input.lastIndexOf(" ", length);
                if (idx === -1) {
                  idx = length;
                }
                input = input.substring(0, idx);
              }
              input += end !== void 0 && end !== null ? end : "...";
              return r.copySafeness(orig, input);
            }
            exports2.truncate = truncate;
            function upper(str) {
              str = normalize(str, "");
              return str.toUpperCase();
            }
            exports2.upper = upper;
            function urlencode(obj) {
              var enc = encodeURIComponent;
              if (lib.isString(obj)) {
                return enc(obj);
              } else {
                var keyvals = lib.isArray(obj) ? obj : lib._entries(obj);
                return keyvals.map(function(_ref2) {
                  var k = _ref2[0], v = _ref2[1];
                  return enc(k) + "=" + enc(v);
                }).join("&");
              }
            }
            exports2.urlencode = urlencode;
            var puncRe = /^(?:\(|<|&lt;)?(.*?)(?:\.|,|\)|\n|&gt;)?$/;
            var emailRe = /^[\w.!#$%&'*+\-\/=?\^`{|}~]+@[a-z\d\-]+(\.[a-z\d\-]+)+$/i;
            var httpHttpsRe = /^https?:\/\/.*$/;
            var wwwRe = /^www\./;
            var tldRe = /\.(?:org|net|com)(?:\:|\/|$)/;
            function urlize(str, length, nofollow) {
              if (isNaN(length)) {
                length = Infinity;
              }
              var noFollowAttr = nofollow === true ? ' rel="nofollow"' : "";
              var words = str.split(/(\s+)/).filter(function(word) {
                return word && word.length;
              }).map(function(word) {
                var matches = word.match(puncRe);
                var possibleUrl = matches ? matches[1] : word;
                var shortUrl = possibleUrl.substr(0, length);
                if (httpHttpsRe.test(possibleUrl)) {
                  return '<a href="' + possibleUrl + '"' + noFollowAttr + ">" + shortUrl + "</a>";
                }
                if (wwwRe.test(possibleUrl)) {
                  return '<a href="http://' + possibleUrl + '"' + noFollowAttr + ">" + shortUrl + "</a>";
                }
                if (emailRe.test(possibleUrl)) {
                  return '<a href="mailto:' + possibleUrl + '">' + possibleUrl + "</a>";
                }
                if (tldRe.test(possibleUrl)) {
                  return '<a href="http://' + possibleUrl + '"' + noFollowAttr + ">" + shortUrl + "</a>";
                }
                return word;
              });
              return words.join("");
            }
            exports2.urlize = urlize;
            function wordcount(str) {
              str = normalize(str, "");
              var words = str ? str.match(/\w+/g) : null;
              return words ? words.length : null;
            }
            exports2.wordcount = wordcount;
            function float(val, def) {
              var res = parseFloat(val);
              return isNaN(res) ? def : res;
            }
            exports2.float = float;
            var intFilter = r.makeMacro(["value", "default", "base"], [], function doInt(value, defaultValue, base) {
              if (base === void 0) {
                base = 10;
              }
              var res = parseInt(value, base);
              return isNaN(res) ? defaultValue : res;
            });
            exports2.int = intFilter;
            exports2.d = exports2.default;
            exports2.e = exports2.escape;
          },
          /* 19 */
          /***/
          function(module3, exports2, __webpack_require__) {
            "use strict";
            function _inheritsLoose(subClass, superClass) {
              subClass.prototype = Object.create(superClass.prototype);
              subClass.prototype.constructor = subClass;
              _setPrototypeOf(subClass, superClass);
            }
            function _setPrototypeOf(o, p) {
              _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return _setPrototypeOf(o, p);
            }
            var Loader = __webpack_require__(6);
            var PrecompiledLoader = /* @__PURE__ */ function(_Loader) {
              _inheritsLoose(PrecompiledLoader2, _Loader);
              function PrecompiledLoader2(compiledTemplates) {
                var _this;
                _this = _Loader.call(this) || this;
                _this.precompiled = compiledTemplates || {};
                return _this;
              }
              var _proto = PrecompiledLoader2.prototype;
              _proto.getSource = function getSource(name) {
                if (this.precompiled[name]) {
                  return {
                    src: {
                      type: "code",
                      obj: this.precompiled[name]
                    },
                    path: name
                  };
                }
                return null;
              };
              return PrecompiledLoader2;
            }(Loader);
            module3.exports = {
              PrecompiledLoader
            };
          },
          /* 20 */
          /***/
          function(module3, exports2, __webpack_require__) {
            "use strict";
            var SafeString = __webpack_require__(2).SafeString;
            function callable(value) {
              return typeof value === "function";
            }
            exports2.callable = callable;
            function defined(value) {
              return value !== void 0;
            }
            exports2.defined = defined;
            function divisibleby(one, two) {
              return one % two === 0;
            }
            exports2.divisibleby = divisibleby;
            function escaped(value) {
              return value instanceof SafeString;
            }
            exports2.escaped = escaped;
            function equalto(one, two) {
              return one === two;
            }
            exports2.equalto = equalto;
            exports2.eq = exports2.equalto;
            exports2.sameas = exports2.equalto;
            function even(value) {
              return value % 2 === 0;
            }
            exports2.even = even;
            function falsy(value) {
              return !value;
            }
            exports2.falsy = falsy;
            function ge(one, two) {
              return one >= two;
            }
            exports2.ge = ge;
            function greaterthan(one, two) {
              return one > two;
            }
            exports2.greaterthan = greaterthan;
            exports2.gt = exports2.greaterthan;
            function le(one, two) {
              return one <= two;
            }
            exports2.le = le;
            function lessthan(one, two) {
              return one < two;
            }
            exports2.lessthan = lessthan;
            exports2.lt = exports2.lessthan;
            function lower(value) {
              return value.toLowerCase() === value;
            }
            exports2.lower = lower;
            function ne(one, two) {
              return one !== two;
            }
            exports2.ne = ne;
            function nullTest(value) {
              return value === null;
            }
            exports2.null = nullTest;
            function number(value) {
              return typeof value === "number";
            }
            exports2.number = number;
            function odd(value) {
              return value % 2 === 1;
            }
            exports2.odd = odd;
            function string(value) {
              return typeof value === "string";
            }
            exports2.string = string;
            function truthy(value) {
              return !!value;
            }
            exports2.truthy = truthy;
            function undefinedTest(value) {
              return value === void 0;
            }
            exports2.undefined = undefinedTest;
            function upper(value) {
              return value.toUpperCase() === value;
            }
            exports2.upper = upper;
            function iterable(value) {
              if (typeof Symbol !== "undefined") {
                return !!value[Symbol.iterator];
              } else {
                return Array.isArray(value) || typeof value === "string";
              }
            }
            exports2.iterable = iterable;
            function mapping(value) {
              var bool = value !== null && value !== void 0 && typeof value === "object" && !Array.isArray(value);
              if (Set) {
                return bool && !(value instanceof Set);
              } else {
                return bool;
              }
            }
            exports2.mapping = mapping;
          },
          /* 21 */
          /***/
          function(module3, exports2, __webpack_require__) {
            "use strict";
            function _cycler(items) {
              var index = -1;
              return {
                current: null,
                reset: function reset() {
                  index = -1;
                  this.current = null;
                },
                next: function next() {
                  index++;
                  if (index >= items.length) {
                    index = 0;
                  }
                  this.current = items[index];
                  return this.current;
                }
              };
            }
            function _joiner(sep) {
              sep = sep || ",";
              var first = true;
              return function() {
                var val = first ? "" : sep;
                first = false;
                return val;
              };
            }
            function globals2() {
              return {
                range: function range(start, stop, step) {
                  if (typeof stop === "undefined") {
                    stop = start;
                    start = 0;
                    step = 1;
                  } else if (!step) {
                    step = 1;
                  }
                  var arr = [];
                  if (step > 0) {
                    for (var i = start; i < stop; i += step) {
                      arr.push(i);
                    }
                  } else {
                    for (var _i = start; _i > stop; _i += step) {
                      arr.push(_i);
                    }
                  }
                  return arr;
                },
                cycler: function cycler() {
                  return _cycler(Array.prototype.slice.call(arguments));
                },
                joiner: function joiner(sep) {
                  return _joiner(sep);
                }
              };
            }
            module3.exports = globals2;
          },
          /* 22 */
          /***/
          function(module3, exports2, __webpack_require__) {
            var path = __webpack_require__(4);
            module3.exports = function express(env2, app) {
              function NunjucksView(name, opts) {
                this.name = name;
                this.path = name;
                this.defaultEngine = opts.defaultEngine;
                this.ext = path.extname(name);
                if (!this.ext && !this.defaultEngine) {
                  throw new Error("No default engine was specified and no extension was provided.");
                }
                if (!this.ext) {
                  this.name += this.ext = (this.defaultEngine[0] !== "." ? "." : "") + this.defaultEngine;
                }
              }
              NunjucksView.prototype.render = function render(opts, cb) {
                env2.render(this.name, opts, cb);
              };
              app.set("view", NunjucksView);
              app.set("nunjucksEnv", env2);
              return env2;
            };
          },
          /* 23 */
          /***/
          function(module3, exports2, __webpack_require__) {
            "use strict";
            var fs = __webpack_require__(4);
            var path = __webpack_require__(4);
            var _require = __webpack_require__(0), _prettifyError = _require._prettifyError;
            var compiler = __webpack_require__(5);
            var _require2 = __webpack_require__(7), Environment = _require2.Environment;
            var precompileGlobal = __webpack_require__(24);
            function match(filename, patterns) {
              if (!Array.isArray(patterns)) {
                return false;
              }
              return patterns.some(function(pattern) {
                return filename.match(pattern);
              });
            }
            function precompileString(str, opts) {
              opts = opts || {};
              opts.isString = true;
              var env2 = opts.env || new Environment([]);
              var wrapper = opts.wrapper || precompileGlobal;
              if (!opts.name) {
                throw new Error('the "name" option is required when compiling a string');
              }
              return wrapper([_precompile(str, opts.name, env2)], opts);
            }
            function precompile(input, opts) {
              opts = opts || {};
              var env2 = opts.env || new Environment([]);
              var wrapper = opts.wrapper || precompileGlobal;
              if (opts.isString) {
                return precompileString(input, opts);
              }
              var pathStats = fs.existsSync(input) && fs.statSync(input);
              var precompiled = [];
              var templates = [];
              function addTemplates(dir) {
                fs.readdirSync(dir).forEach(function(file) {
                  var filepath = path.join(dir, file);
                  var subpath = filepath.substr(path.join(input, "/").length);
                  var stat = fs.statSync(filepath);
                  if (stat && stat.isDirectory()) {
                    subpath += "/";
                    if (!match(subpath, opts.exclude)) {
                      addTemplates(filepath);
                    }
                  } else if (match(subpath, opts.include)) {
                    templates.push(filepath);
                  }
                });
              }
              if (pathStats.isFile()) {
                precompiled.push(_precompile(fs.readFileSync(input, "utf-8"), opts.name || input, env2));
              } else if (pathStats.isDirectory()) {
                addTemplates(input);
                for (var i = 0; i < templates.length; i++) {
                  var name = templates[i].replace(path.join(input, "/"), "");
                  try {
                    precompiled.push(_precompile(fs.readFileSync(templates[i], "utf-8"), name, env2));
                  } catch (e) {
                    if (opts.force) {
                      console.error(e);
                    } else {
                      throw e;
                    }
                  }
                }
              }
              return wrapper(precompiled, opts);
            }
            function _precompile(str, name, env2) {
              env2 = env2 || new Environment([]);
              var asyncFilters = env2.asyncFilters;
              var extensions = env2.extensionsList;
              var template;
              name = name.replace(/\\/g, "/");
              try {
                template = compiler.compile(str, asyncFilters, extensions, name, env2.opts);
              } catch (err) {
                throw _prettifyError(name, false, err);
              }
              return {
                name,
                template
              };
            }
            module3.exports = {
              precompile,
              precompileString
            };
          },
          /* 24 */
          /***/
          function(module3, exports2, __webpack_require__) {
            "use strict";
            function precompileGlobal(templates, opts) {
              var out = "";
              opts = opts || {};
              for (var i = 0; i < templates.length; i++) {
                var name = JSON.stringify(templates[i].name);
                var template = templates[i].template;
                out += "(function() {(window.nunjucksPrecompiled = window.nunjucksPrecompiled || {})[" + name + "] = (function() {\n" + template + "\n})();\n";
                if (opts.asFunction) {
                  out += "return function(ctx, cb) { return nunjucks.render(" + name + ", ctx, cb); }\n";
                }
                out += "})();\n";
              }
              return out;
            }
            module3.exports = precompileGlobal;
          },
          /* 25 */
          /***/
          function(module3, exports2, __webpack_require__) {
            function installCompat() {
              "use strict";
              var runtime = this.runtime;
              var lib = this.lib;
              var Compiler = this.compiler.Compiler;
              var Parser = this.parser.Parser;
              var nodes = this.nodes;
              var lexer = this.lexer;
              var orig_contextOrFrameLookup = runtime.contextOrFrameLookup;
              var orig_memberLookup = runtime.memberLookup;
              var orig_Compiler_assertType;
              var orig_Parser_parseAggregate;
              if (Compiler) {
                orig_Compiler_assertType = Compiler.prototype.assertType;
              }
              if (Parser) {
                orig_Parser_parseAggregate = Parser.prototype.parseAggregate;
              }
              function uninstall() {
                runtime.contextOrFrameLookup = orig_contextOrFrameLookup;
                runtime.memberLookup = orig_memberLookup;
                if (Compiler) {
                  Compiler.prototype.assertType = orig_Compiler_assertType;
                }
                if (Parser) {
                  Parser.prototype.parseAggregate = orig_Parser_parseAggregate;
                }
              }
              runtime.contextOrFrameLookup = function contextOrFrameLookup(context, frame, key) {
                var val = orig_contextOrFrameLookup.apply(this, arguments);
                if (val !== void 0) {
                  return val;
                }
                switch (key) {
                  case "True":
                    return true;
                  case "False":
                    return false;
                  case "None":
                    return null;
                  default:
                    return void 0;
                }
              };
              function getTokensState(tokens) {
                return {
                  index: tokens.index,
                  lineno: tokens.lineno,
                  colno: tokens.colno
                };
              }
              if (nodes && Compiler && Parser) {
                var Slice = nodes.Node.extend("Slice", {
                  fields: ["start", "stop", "step"],
                  init: function init2(lineno, colno, start, stop, step) {
                    start = start || new nodes.Literal(lineno, colno, null);
                    stop = stop || new nodes.Literal(lineno, colno, null);
                    step = step || new nodes.Literal(lineno, colno, 1);
                    this.parent(lineno, colno, start, stop, step);
                  }
                });
                Compiler.prototype.assertType = function assertType(node) {
                  if (node instanceof Slice) {
                    return;
                  }
                  orig_Compiler_assertType.apply(this, arguments);
                };
                Compiler.prototype.compileSlice = function compileSlice(node, frame) {
                  this._emit("(");
                  this._compileExpression(node.start, frame);
                  this._emit("),(");
                  this._compileExpression(node.stop, frame);
                  this._emit("),(");
                  this._compileExpression(node.step, frame);
                  this._emit(")");
                };
                Parser.prototype.parseAggregate = function parseAggregate() {
                  var _this = this;
                  var origState = getTokensState(this.tokens);
                  origState.colno--;
                  origState.index--;
                  try {
                    return orig_Parser_parseAggregate.apply(this);
                  } catch (e) {
                    var errState = getTokensState(this.tokens);
                    var rethrow = function rethrow2() {
                      lib._assign(_this.tokens, errState);
                      return e;
                    };
                    lib._assign(this.tokens, origState);
                    this.peeked = false;
                    var tok = this.peekToken();
                    if (tok.type !== lexer.TOKEN_LEFT_BRACKET) {
                      throw rethrow();
                    } else {
                      this.nextToken();
                    }
                    var node = new Slice(tok.lineno, tok.colno);
                    var isSlice = false;
                    for (var i = 0; i <= node.fields.length; i++) {
                      if (this.skip(lexer.TOKEN_RIGHT_BRACKET)) {
                        break;
                      }
                      if (i === node.fields.length) {
                        if (isSlice) {
                          this.fail("parseSlice: too many slice components", tok.lineno, tok.colno);
                        } else {
                          break;
                        }
                      }
                      if (this.skip(lexer.TOKEN_COLON)) {
                        isSlice = true;
                      } else {
                        var field = node.fields[i];
                        node[field] = this.parseExpression();
                        isSlice = this.skip(lexer.TOKEN_COLON) || isSlice;
                      }
                    }
                    if (!isSlice) {
                      throw rethrow();
                    }
                    return new nodes.Array(tok.lineno, tok.colno, [node]);
                  }
                };
              }
              function sliceLookup(obj, start, stop, step) {
                obj = obj || [];
                if (start === null) {
                  start = step < 0 ? obj.length - 1 : 0;
                }
                if (stop === null) {
                  stop = step < 0 ? -1 : obj.length;
                } else if (stop < 0) {
                  stop += obj.length;
                }
                if (start < 0) {
                  start += obj.length;
                }
                var results = [];
                for (var i = start; ; i += step) {
                  if (i < 0 || i > obj.length) {
                    break;
                  }
                  if (step > 0 && i >= stop) {
                    break;
                  }
                  if (step < 0 && i <= stop) {
                    break;
                  }
                  results.push(runtime.memberLookup(obj, i));
                }
                return results;
              }
              function hasOwnProp(obj, key) {
                return Object.prototype.hasOwnProperty.call(obj, key);
              }
              var ARRAY_MEMBERS = {
                pop: function pop(index) {
                  if (index === void 0) {
                    return this.pop();
                  }
                  if (index >= this.length || index < 0) {
                    throw new Error("KeyError");
                  }
                  return this.splice(index, 1);
                },
                append: function append2(element2) {
                  return this.push(element2);
                },
                remove: function remove(element2) {
                  for (var i = 0; i < this.length; i++) {
                    if (this[i] === element2) {
                      return this.splice(i, 1);
                    }
                  }
                  throw new Error("ValueError");
                },
                count: function count(element2) {
                  var count2 = 0;
                  for (var i = 0; i < this.length; i++) {
                    if (this[i] === element2) {
                      count2++;
                    }
                  }
                  return count2;
                },
                index: function index(element2) {
                  var i;
                  if ((i = this.indexOf(element2)) === -1) {
                    throw new Error("ValueError");
                  }
                  return i;
                },
                find: function find(element2) {
                  return this.indexOf(element2);
                },
                insert: function insert2(index, elem) {
                  return this.splice(index, 0, elem);
                }
              };
              var OBJECT_MEMBERS = {
                items: function items() {
                  return lib._entries(this);
                },
                values: function values() {
                  return lib._values(this);
                },
                keys: function keys() {
                  return lib.keys(this);
                },
                get: function get(key, def) {
                  var output = this[key];
                  if (output === void 0) {
                    output = def;
                  }
                  return output;
                },
                has_key: function has_key(key) {
                  return hasOwnProp(this, key);
                },
                pop: function pop(key, def) {
                  var output = this[key];
                  if (output === void 0 && def !== void 0) {
                    output = def;
                  } else if (output === void 0) {
                    throw new Error("KeyError");
                  } else {
                    delete this[key];
                  }
                  return output;
                },
                popitem: function popitem() {
                  var keys = lib.keys(this);
                  if (!keys.length) {
                    throw new Error("KeyError");
                  }
                  var k = keys[0];
                  var val = this[k];
                  delete this[k];
                  return [k, val];
                },
                setdefault: function setdefault(key, def) {
                  if (def === void 0) {
                    def = null;
                  }
                  if (!(key in this)) {
                    this[key] = def;
                  }
                  return this[key];
                },
                update: function update2(kwargs) {
                  lib._assign(this, kwargs);
                  return null;
                }
              };
              OBJECT_MEMBERS.iteritems = OBJECT_MEMBERS.items;
              OBJECT_MEMBERS.itervalues = OBJECT_MEMBERS.values;
              OBJECT_MEMBERS.iterkeys = OBJECT_MEMBERS.keys;
              runtime.memberLookup = function memberLookup(obj, val, autoescape) {
                if (arguments.length === 4) {
                  return sliceLookup.apply(this, arguments);
                }
                obj = obj || {};
                if (lib.isArray(obj) && hasOwnProp(ARRAY_MEMBERS, val)) {
                  return ARRAY_MEMBERS[val].bind(obj);
                }
                if (lib.isObject(obj) && hasOwnProp(OBJECT_MEMBERS, val)) {
                  return OBJECT_MEMBERS[val].bind(obj);
                }
                return orig_memberLookup.apply(this, arguments);
              };
              return uninstall;
            }
            module3.exports = installCompat;
          }
          /******/
        ])
      );
    });
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AiAssistantPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian8 = require("obsidian");

// src/settings/defaults.ts
var DEFAULT_SETTINGS = {
  activeProvider: "ollama",
  providers: {
    ollama: {
      baseUrl: "http://localhost:11434",
      model: "llama2",
      temperature: 0.7
    },
    openai: {
      baseUrl: "https://api.openai.com/v1",
      apiKey: "",
      model: "gpt-3.5-turbo",
      temperature: 0.7
    }
  },
  webSearch: {
    enabled: false,
    urlTemplate: "https://searx.be/search?q=%s&format=json",
    // Example output
    timeoutMs: 8e3,
    maxResults: 5,
    safeSearch: 1
  },
  history: {
    perNoteMaxMessages: 80,
    vaultMaxMessages: 400,
    maxMessageChars: 2e4,
    summarizationThreshold: 0.8
  },
  ui: {
    themeBaseColor: "neutral",
    rememberLastCommand: true,
    modalWidthPx: 980,
    modalHeightPx: 720
  }
};

// node_modules/uuid/dist/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/uuid/dist/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = { randomUUID };

// node_modules/uuid/dist/v4.js
function _v4(options, buf, offset) {
  var _a, _b, _c;
  options = options || {};
  const rnds = (_c = (_b = options.random) != null ? _b : (_a = options.rng) == null ? void 0 : _a.call(options)) != null ? _c : rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
    }
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  return _v4(options, buf, offset);
}
var v4_default = v4;

// src/history/store.ts
var HistoryService = class {
  constructor(plugin, initialData) {
    this.plugin = plugin;
    this.store = {
      version: 1,
      threads: (initialData == null ? void 0 : initialData.threads) || {},
      noteIndex: (initialData == null ? void 0 : initialData.noteIndex) || {},
      vaultThreadId: (initialData == null ? void 0 : initialData.vaultThreadId) || v4_default()
    };
    if (!this.store.threads[this.store.vaultThreadId]) {
      this.store.threads[this.store.vaultThreadId] = this.createThread("vault", "Global Vault Chat");
    }
  }
  getStore() {
    return this.store;
  }
  getNoteThread(notePath) {
    let threadId = this.store.noteIndex[notePath];
    if (!threadId || !this.store.threads[threadId]) {
      threadId = v4_default();
      this.store.noteIndex[notePath] = threadId;
      this.store.threads[threadId] = this.createThread("note", "Note Chat", notePath);
      this.store.threads[threadId].id = threadId;
    }
    return this.store.threads[threadId];
  }
  getVaultThread() {
    return this.store.threads[this.store.vaultThreadId];
  }
  updateThread(thread) {
    this.store.threads[thread.id] = thread;
    void this.save();
  }
  async save() {
    await this.plugin.saveData(this.plugin.settings);
  }
  createThread(scope, title, notePath) {
    return {
      id: v4_default(),
      scope,
      notePath,
      title,
      createdAt: Date.now(),
      updatedAt: Date.now(),
      messages: []
    };
  }
  addMessage(threadId, message) {
    const thread = this.store.threads[threadId];
    if (!thread)
      return;
    const settings = this.plugin.settings;
    const provider = settings.activeProvider;
    const providerSettings = settings.providers[provider];
    const chatMessage = {
      id: v4_default(),
      role: message.role,
      content: message.content,
      createdAt: Date.now(),
      providerSnapshot: {
        kind: provider,
        baseUrl: providerSettings.baseUrl || "",
        model: providerSettings.model || "",
        temperature: providerSettings.temperature || 0.7
      }
    };
    thread.messages.push(chatMessage);
    thread.updatedAt = Date.now();
    void this.save();
  }
  clearThread(threadId) {
    const thread = this.store.threads[threadId];
    if (!thread)
      return;
    thread.messages = [];
    thread.updatedAt = Date.now();
    void this.save();
  }
  clearVaultThread() {
    this.clearThread(this.store.vaultThreadId);
  }
  clearNoteThread(notePath) {
    const threadId = this.store.noteIndex[notePath];
    if (threadId) {
      this.clearThread(threadId);
    }
  }
};

// src/ui/view.ts
var import_obsidian7 = require("obsidian");

// node_modules/svelte/src/runtime/internal/utils.js
function noop() {
}
var identity = (x) => x;
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}

// node_modules/svelte/src/runtime/internal/environment.js
var is_client = typeof window !== "undefined";
var now = is_client ? () => window.performance.now() : () => Date.now();
var raf = is_client ? (cb) => requestAnimationFrame(cb) : noop;

// node_modules/svelte/src/runtime/internal/loop.js
var tasks = /* @__PURE__ */ new Set();
function run_tasks(now2) {
  tasks.forEach((task) => {
    if (!task.c(now2)) {
      tasks.delete(task);
      task.f();
    }
  });
  if (tasks.size !== 0)
    raf(run_tasks);
}
function loop(callback) {
  let task;
  if (tasks.size === 0)
    raf(run_tasks);
  return {
    promise: new Promise((fulfill) => {
      tasks.add(task = { c: callback, f: fulfill });
    }),
    abort() {
      tasks.delete(task);
    }
  };
}

// node_modules/svelte/src/runtime/internal/globals.js
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);

// node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
var ResizeObserverSingleton = class {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    __publicField(this, "_listeners", "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0);
    /**
     * @private
     * @type {ResizeObserver}
     */
    __publicField(this, "_observer");
    /** @type {ResizeObserverOptions} */
    __publicField(this, "options");
    this.options = options;
  }
  /**
   * @param {Element} element
   * @param {import('./private.js').Listener} listener
   * @returns {() => void}
   */
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  /**
   * @private
   */
  _getObserver() {
    var _a;
    return (_a = this._observer) != null ? _a : this._observer = new ResizeObserver((entries) => {
      var _a2;
      for (const entry of entries) {
        ResizeObserverSingleton.entries.set(entry.target, entry);
        (_a2 = this._listeners.get(entry.target)) == null ? void 0 : _a2(entry);
      }
    });
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

// node_modules/svelte/src/runtime/internal/dom.js
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && /** @type {ShadowRoot} */
  root.host) {
    return (
      /** @type {ShadowRoot} */
      root
    );
  }
  return node.ownerDocument;
}
function append_empty_stylesheet(node) {
  const style_element = element("style");
  style_element.textContent = "/* empty */";
  append_stylesheet(get_root_for_style(node), style_element);
  return style_element.sheet;
}
function append_stylesheet(node, style) {
  append(
    /** @type {Document} */
    node.head || node,
    style
  );
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data)
    return;
  text2.data = /** @type {string} */
  data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  return new CustomEvent(type, { detail, bubbles, cancelable });
}
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach(
    /** @param {Element} node */
    (node) => {
      result[node.slot || "default"] = true;
    }
  );
  return result;
}

// node_modules/svelte/src/runtime/internal/style_manager.js
var managed_styles = /* @__PURE__ */ new Map();
var active = 0;
function hash(str) {
  let hash2 = 5381;
  let i = str.length;
  while (i--)
    hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i);
  return hash2 >>> 0;
}
function create_style_information(doc, node) {
  const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
  managed_styles.set(doc, info);
  return info;
}
function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
  const step = 16.666 / duration;
  let keyframes = "{\n";
  for (let p = 0; p <= 1; p += step) {
    const t = a + (b - a) * ease(p);
    keyframes += p * 100 + `%{${fn(t, 1 - t)}}
`;
  }
  const rule = keyframes + `100% {${fn(b, 1 - b)}}
}`;
  const name = `__svelte_${hash(rule)}_${uid}`;
  const doc = get_root_for_style(node);
  const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
  if (!rules[name]) {
    rules[name] = true;
    stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
  }
  const animation = node.style.animation || "";
  node.style.animation = `${animation ? `${animation}, ` : ""}${name} ${duration}ms linear ${delay}ms 1 both`;
  active += 1;
  return name;
}
function delete_rule(node, name) {
  const previous = (node.style.animation || "").split(", ");
  const next = previous.filter(
    name ? (anim) => anim.indexOf(name) < 0 : (anim) => anim.indexOf("__svelte") === -1
    // remove all Svelte animations
  );
  const deleted = previous.length - next.length;
  if (deleted) {
    node.style.animation = next.join(", ");
    active -= deleted;
    if (!active)
      clear_rules();
  }
}
function clear_rules() {
  raf(() => {
    if (active)
      return;
    managed_styles.forEach((info) => {
      const { ownerNode } = info.stylesheet;
      if (ownerNode)
        detach(ownerNode);
    });
    managed_styles.clear();
  });
}

// node_modules/svelte/src/runtime/internal/lifecycle.js
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(
        /** @type {string} */
        type,
        detail,
        { cancelable }
      );
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}

// node_modules/svelte/src/runtime/internal/scheduler.js
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}

// node_modules/svelte/src/runtime/internal/transitions.js
var promise;
function wait() {
  if (!promise) {
    promise = Promise.resolve();
    promise.then(() => {
      promise = null;
    });
  }
  return promise;
}
function dispatch(node, direction, kind) {
  node.dispatchEvent(custom_event(`${direction ? "intro" : "outro"}${kind}`));
}
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
var null_transition = { duration: 0 };
function create_bidirectional_transition(node, fn, params, intro) {
  const options = { direction: "both" };
  let config = fn(node, params, options);
  let t = intro ? 0 : 1;
  let running_program = null;
  let pending_program = null;
  let animation_name = null;
  let original_inert_value;
  function clear_animation() {
    if (animation_name)
      delete_rule(node, animation_name);
  }
  function init2(program, duration) {
    const d = (
      /** @type {Program['d']} */
      program.b - t
    );
    duration *= Math.abs(d);
    return {
      a: t,
      b: program.b,
      d,
      duration,
      start: program.start,
      end: program.start + duration,
      group: program.group
    };
  }
  function go(b) {
    const {
      delay = 0,
      duration = 300,
      easing = identity,
      tick: tick2 = noop,
      css
    } = config || null_transition;
    const program = {
      start: now() + delay,
      b
    };
    if (!b) {
      program.group = outros;
      outros.r += 1;
    }
    if ("inert" in node) {
      if (b) {
        if (original_inert_value !== void 0) {
          node.inert = original_inert_value;
        }
      } else {
        original_inert_value = /** @type {HTMLElement} */
        node.inert;
        node.inert = true;
      }
    }
    if (running_program || pending_program) {
      pending_program = program;
    } else {
      if (css) {
        clear_animation();
        animation_name = create_rule(node, t, b, duration, delay, easing, css);
      }
      if (b)
        tick2(0, 1);
      running_program = init2(program, duration);
      add_render_callback(() => dispatch(node, b, "start"));
      loop((now2) => {
        if (pending_program && now2 > pending_program.start) {
          running_program = init2(pending_program, duration);
          pending_program = null;
          dispatch(node, running_program.b, "start");
          if (css) {
            clear_animation();
            animation_name = create_rule(
              node,
              t,
              running_program.b,
              running_program.duration,
              0,
              easing,
              config.css
            );
          }
        }
        if (running_program) {
          if (now2 >= running_program.end) {
            tick2(t = running_program.b, 1 - t);
            dispatch(node, running_program.b, "end");
            if (!pending_program) {
              if (running_program.b) {
                clear_animation();
              } else {
                if (!--running_program.group.r)
                  run_all(running_program.group.c);
              }
            }
            running_program = null;
          } else if (now2 >= running_program.start) {
            const p = now2 - running_program.start;
            t = running_program.a + running_program.d * easing(p / running_program.duration);
            tick2(t, 1 - t);
          }
        }
        return !!(running_program || pending_program);
      });
    }
  }
  return {
    run(b) {
      if (is_function(config)) {
        wait().then(() => {
          const opts = { direction: b ? "in" : "out" };
          config = config(opts);
          go(b);
        });
      } else {
        go(b);
      }
    },
    end() {
      clear_animation();
      running_program = pending_program = null;
    }
  };
}

// node_modules/svelte/src/runtime/internal/each.js
function ensure_array_like(array_like_or_iterator) {
  return (array_like_or_iterator == null ? void 0 : array_like_or_iterator.length) !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}

// node_modules/svelte/src/shared/boolean_attributes.js
var _boolean_attributes = (
  /** @type {const} */
  [
    "allowfullscreen",
    "allowpaymentrequest",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "hidden",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected"
  ]
);
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

// node_modules/svelte/src/runtime/internal/Component.js
function bind(component, name, callback) {
  const index = component.$$.props[name];
  if (index !== void 0) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance4, create_fragment4, not_equal, props, append_styles2 = null, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance4 ? instance4(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment4 ? create_fragment4($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, Function[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
      if (this.$$l[type]) {
        const idx = this.$$l[type].indexOf(listener);
        if (idx >= 0) {
          this.$$l[type].splice(idx, 1);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot = function(name) {
          return () => {
            let node;
            const obj = {
              c: function create() {
                node = element("slot");
                if (name !== "default") {
                  attr(node, "name", name);
                }
              },
              /**
               * @param {HTMLElement} target
               * @param {HTMLElement} [anchor]
               */
              m: function mount(target, anchor) {
                insert(target, node, anchor);
              },
              d: function destroy(detaching) {
                if (detaching) {
                  detach(node);
                }
              }
            };
            return obj;
          };
        };
        await Promise.resolve();
        if (!this.$$cn || this.$$c) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            $$slots[name] = [create_slot(name)];
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key in this.$$p_d) {
          if (!(key in this.$$d) && this[key] !== void 0) {
            this.$$d[key] = this[key];
            delete this[key];
          }
        }
        this.$$c = new this.$$ctor({
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$scope: {
              ctx: []
            }
          }
        });
        const reflect_attributes = () => {
          this.$$r = true;
          for (const key in this.$$p_d) {
            this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];
            if (this.$$p_d[key].reflect) {
              const attribute_value = get_custom_element_value(
                key,
                this.$$d[key],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(this.$$p_d[key].attribute || key);
              } else {
                this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
              }
            }
          }
          this.$$r = false;
        };
        this.$$c.$$.after_update.push(reflect_attributes);
        reflect_attributes();
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    attributeChangedCallback(attr2, _oldValue, newValue) {
      var _a;
      if (this.$$r)
        return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      (_a = this.$$c) == null ? void 0 : _a.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn && this.$$c) {
          this.$$c.$destroy();
          this.$$c = void 0;
        }
      });
    }
    $$g_p(attribute_name) {
      return Object.keys(this.$$p_d).find(
        (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop, value, props_definition, transform) {
  var _a;
  const type = (_a = props_definition[prop]) == null ? void 0 : _a.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
var SvelteComponent = class {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/src/shared/version.js
var PUBLIC_VERSION = "4";

// node_modules/svelte/src/runtime/internal/disclose-version/index.js
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

// node_modules/svelte/src/runtime/easing/index.js
function cubicOut(t) {
  const f = t - 1;
  return f * f * f + 1;
}

// node_modules/svelte/src/runtime/transition/index.js
function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
  const o = +getComputedStyle(node).opacity;
  return {
    delay,
    duration,
    easing,
    css: (t) => `opacity: ${t * o}`
  };
}
function slide(node, { delay = 0, duration = 400, easing = cubicOut, axis = "y" } = {}) {
  const style = getComputedStyle(node);
  const opacity = +style.opacity;
  const primary_property = axis === "y" ? "height" : "width";
  const primary_property_value = parseFloat(style[primary_property]);
  const secondary_properties = axis === "y" ? ["top", "bottom"] : ["left", "right"];
  const capitalized_secondary_properties = secondary_properties.map(
    (e) => `${e[0].toUpperCase()}${e.slice(1)}`
  );
  const padding_start_value = parseFloat(style[`padding${capitalized_secondary_properties[0]}`]);
  const padding_end_value = parseFloat(style[`padding${capitalized_secondary_properties[1]}`]);
  const margin_start_value = parseFloat(style[`margin${capitalized_secondary_properties[0]}`]);
  const margin_end_value = parseFloat(style[`margin${capitalized_secondary_properties[1]}`]);
  const border_width_start_value = parseFloat(
    style[`border${capitalized_secondary_properties[0]}Width`]
  );
  const border_width_end_value = parseFloat(
    style[`border${capitalized_secondary_properties[1]}Width`]
  );
  return {
    delay,
    duration,
    easing,
    css: (t) => `overflow: hidden;opacity: ${Math.min(t * 20, 1) * opacity};${primary_property}: ${t * primary_property_value}px;padding-${secondary_properties[0]}: ${t * padding_start_value}px;padding-${secondary_properties[1]}: ${t * padding_end_value}px;margin-${secondary_properties[0]}: ${t * margin_start_value}px;margin-${secondary_properties[1]}: ${t * margin_end_value}px;border-${secondary_properties[0]}-width: ${t * border_width_start_value}px;border-${secondary_properties[1]}-width: ${t * border_width_end_value}px;`
  };
}

// src/commands/registry.ts
var COMMANDS = [
  { id: "explain_selection", title: "Explain selection", scope: "selection", delivery: "chat_only", allowStreaming: true, allowWebSearch: true },
  { id: "expand_selection", title: "Expand selection", scope: "selection", delivery: "insert_below_selection", allowStreaming: true, allowWebSearch: true },
  { id: "rewrite_selection_formal", title: "Rewrite selection (Formal)", scope: "selection", delivery: "replace_selection", allowStreaming: true, allowWebSearch: false },
  { id: "rewrite_selection_casual", title: "Rewrite selection (Casual)", scope: "selection", delivery: "replace_selection", allowStreaming: true, allowWebSearch: false },
  { id: "rewrite_selection_active_voice", title: "Rewrite selection (Active voice)", scope: "selection", delivery: "replace_selection", allowStreaming: true, allowWebSearch: false },
  { id: "rewrite_selection_bullets", title: "Rewrite selection (Bullet points)", scope: "selection", delivery: "replace_selection", allowStreaming: true, allowWebSearch: false },
  { id: "caption_selection", title: "Caption selection", scope: "selection", delivery: "insert_below_selection", allowStreaming: true, allowWebSearch: true },
  { id: "summarize_selection", title: "Summarize selection", scope: "selection", delivery: "chat_only", allowStreaming: true, allowWebSearch: true },
  { id: "note_chat", title: "Chat (this note)", scope: "note", delivery: "chat_only", allowStreaming: true, allowWebSearch: true },
  { id: "vault_chat", title: "Search vault for notes", scope: "vault", delivery: "chat_only", allowStreaming: true, allowWebSearch: false },
  { id: "research_create_note", title: "Research & Create Note", scope: "vault", delivery: "chat_only", allowStreaming: true, allowWebSearch: true }
];

// src/editor/context.ts
var import_obsidian = require("obsidian");

// src/utils/minheap.ts
var MinHeap = class {
  /**
   * @param compare Comparator function. Should return negative if a < b, positive if a > b, 0 if equal.
   *                For a min-heap of numbers: (a, b) => a - b
   */
  constructor(compare) {
    this.heap = [];
    this.compare = compare;
  }
  get size() {
    return this.heap.length;
  }
  peek() {
    return this.heap[0];
  }
  push(value) {
    this.heap.push(value);
    this.bubbleUp(this.heap.length - 1);
  }
  pop() {
    if (this.heap.length === 0)
      return void 0;
    if (this.heap.length === 1)
      return this.heap.pop();
    const result = this.heap[0];
    this.heap[0] = this.heap.pop();
    this.bubbleDown(0);
    return result;
  }
  toArray() {
    return [...this.heap];
  }
  toSortedArray() {
    const result = [];
    const tempHeap = new MinHeap(this.compare);
    tempHeap.heap = [...this.heap];
    while (tempHeap.size > 0) {
      result.push(tempHeap.pop());
    }
    return result;
  }
  bubbleUp(index) {
    while (index > 0) {
      const parentIndex = Math.floor((index - 1) / 2);
      if (this.compare(this.heap[index], this.heap[parentIndex]) >= 0)
        break;
      this.swap(index, parentIndex);
      index = parentIndex;
    }
  }
  bubbleDown(index) {
    const length = this.heap.length;
    while (true) {
      const leftChild = 2 * index + 1;
      const rightChild = 2 * index + 2;
      let smallest = index;
      if (leftChild < length && this.compare(this.heap[leftChild], this.heap[smallest]) < 0) {
        smallest = leftChild;
      }
      if (rightChild < length && this.compare(this.heap[rightChild], this.heap[smallest]) < 0) {
        smallest = rightChild;
      }
      if (smallest === index)
        break;
      this.swap(index, smallest);
      index = smallest;
    }
  }
  swap(i, j) {
    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];
  }
};
function findTopK(items, k, getValue) {
  if (items.length <= k) {
    return [...items];
  }
  const minHeap = new MinHeap((a, b) => getValue(a) - getValue(b));
  for (const item of items) {
    if (minHeap.size < k) {
      minHeap.push(item);
    } else if (getValue(item) > getValue(minHeap.peek())) {
      minHeap.pop();
      minHeap.push(item);
    }
  }
  return minHeap.toArray();
}

// src/editor/context.ts
var lastActiveNotePath = null;
function trackActiveNote(app) {
  const activeView = app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
  if (activeView == null ? void 0 : activeView.file) {
    lastActiveNotePath = activeView.file.path;
  }
}
function getEditorContext(app) {
  let activeView = app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
  if (!activeView) {
    const leaves = app.workspace.getLeavesOfType("markdown");
    if (leaves.length > 0) {
      if (lastActiveNotePath) {
        const trackedLeaf = leaves.find((l) => {
          var _a;
          const v = l.view;
          return ((_a = v.file) == null ? void 0 : _a.path) === lastActiveNotePath;
        });
        if (trackedLeaf) {
          activeView = trackedLeaf.view;
        }
      }
      if (!activeView) {
        const validLeaf = leaves.find((l) => {
          const v = l.view;
          const isMarkdown = v instanceof import_obsidian.MarkdownView || v.getViewType && v.getViewType() === "markdown";
          return isMarkdown && !!v.file;
        });
        if (validLeaf) {
          activeView = validLeaf.view;
        }
      }
    }
  }
  if (!activeView) {
    console.warn("AI Assistant: Failed to find active MarkdownView.");
    return null;
  }
  const editor = activeView.editor;
  const file = activeView.file;
  if (!file) {
    console.warn("AI Assistant: MarkdownView found but no file associated.");
    return null;
  }
  const selection = editor.getSelection();
  const cursorFrom = editor.getCursor("from");
  const cursorTo = editor.getCursor("to");
  return {
    note: {
      path: file.path,
      title: file.basename
    },
    selection: selection ? {
      text: selection,
      from: { line: cursorFrom.line, ch: cursorFrom.ch },
      to: { line: cursorTo.line, ch: cursorTo.ch }
    } : void 0,
    fullText: editor.getValue()
  };
}
var MAX_VAULT_NOTES = 500;
var CACHE_INVALIDATE_DEBOUNCE = 500;
function buildNoteSummary(app, file) {
  const cache = app.metadataCache.getFileCache(file);
  const frontmatter = (cache == null ? void 0 : cache.frontmatter) || null;
  const tagSet = /* @__PURE__ */ new Set();
  if (frontmatter == null ? void 0 : frontmatter.tags) {
    if (Array.isArray(frontmatter.tags)) {
      frontmatter.tags.forEach((t) => {
        tagSet.add(t.startsWith("#") ? t : `#${t}`);
      });
    } else if (typeof frontmatter.tags === "string") {
      tagSet.add(frontmatter.tags.startsWith("#") ? frontmatter.tags : `#${frontmatter.tags}`);
    }
  }
  if (cache == null ? void 0 : cache.tags) {
    cache.tags.forEach((tagCache) => {
      tagSet.add(tagCache.tag);
    });
  }
  const aliases = [];
  if (frontmatter == null ? void 0 : frontmatter.aliases) {
    if (Array.isArray(frontmatter.aliases)) {
      frontmatter.aliases.forEach((alias) => {
        if (typeof alias === "string") {
          aliases.push(alias);
        }
      });
    } else if (typeof frontmatter.aliases === "string") {
      aliases.push(frontmatter.aliases);
    }
  }
  const headings = [];
  if (cache == null ? void 0 : cache.headings) {
    cache.headings.forEach((heading) => {
      if (heading.level <= 2) {
        headings.push(heading.heading);
      }
    });
  }
  const description = (frontmatter == null ? void 0 : frontmatter.description) || (frontmatter == null ? void 0 : frontmatter.summary) || (frontmatter == null ? void 0 : frontmatter.excerpt) || null;
  return {
    path: file.path,
    title: (frontmatter == null ? void 0 : frontmatter.title) || file.basename,
    aliases,
    tags: Array.from(tagSet),
    headings,
    description: typeof description === "string" ? description : null,
    created: file.stat.ctime,
    frontmatter: frontmatter ? { ...frontmatter } : null
  };
}
function buildVaultSummary(app) {
  const files = app.vault.getMarkdownFiles();
  const totalCount = files.length;
  const truncated = totalCount > MAX_VAULT_NOTES;
  const topFiles = findTopK(
    files,
    MAX_VAULT_NOTES,
    (file) => file.stat.mtime
  );
  topFiles.sort((a, b) => b.stat.mtime - a.stat.mtime);
  const notes = topFiles.map((file) => buildNoteSummary(app, file));
  return {
    noteCount: totalCount,
    includedCount: notes.length,
    truncated,
    notes
  };
}
var VaultSummaryCache = class {
  constructor(plugin) {
    this.cache = null;
    this.debounceTimer = null;
    this.app = plugin.app;
    plugin.registerEvent(
      plugin.app.vault.on("create", (file) => {
        if (file instanceof import_obsidian.TFile && file.extension === "md") {
          this.invalidate();
        }
      })
    );
    plugin.registerEvent(
      plugin.app.vault.on("delete", (file) => {
        if (file instanceof import_obsidian.TFile && file.extension === "md") {
          this.invalidate();
        }
      })
    );
    plugin.registerEvent(
      plugin.app.vault.on("rename", (file) => {
        if (file instanceof import_obsidian.TFile && file.extension === "md") {
          this.invalidate();
        }
      })
    );
    plugin.registerEvent(
      plugin.app.metadataCache.on("changed", (file) => {
        if (file.extension === "md") {
          this.invalidate();
        }
      })
    );
  }
  /**
   * Invalidate the cache with debouncing to handle rapid file changes.
   */
  invalidate() {
    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer);
    }
    this.debounceTimer = setTimeout(() => {
      this.cache = null;
      this.debounceTimer = null;
    }, CACHE_INVALIDATE_DEBOUNCE);
  }
  /**
   * Get the vault summary, using cache if available.
   * O(1) for cache hit, O(N log K) for cache miss.
   */
  get() {
    if (this.cache) {
      return this.cache;
    }
    this.cache = buildVaultSummary(this.app);
    return this.cache;
  }
  /**
   * Force rebuild the cache (useful for testing or manual refresh).
   */
  rebuild() {
    this.cache = buildVaultSummary(this.app);
    return this.cache;
  }
};

// src/prompts/templates.ts
var import_nunjucks = __toESM(require_nunjucks());
var env = new import_nunjucks.default.Environment(null, { autoescape: false });
var BASE_TEMPLATE = `You are an assistant inside Obsidian.
Follow the user's command precisely.
{% block web_search_instructions %}
{% if web_search_enabled %}
If web_search_results are provided, use them as reference material. When citing sources, use standard Markdown links like [Source Title](URL) - do NOT use reference markers like [REF] tags.
{% endif %}
{% endblock %}
{% block command_instructions %}{% endblock %}
Never claim you accessed anything not included in the note content, selection, chat history, vault_summary, or web_search_results.
Output must be valid Markdown unless the command requires another format.`;
var VAULT_CHAT_TEMPLATE = `You are an assistant inside Obsidian.
Follow the user's command precisely.

You have access to a vault_summary containing metadata about the user's notes including: path, title, aliases, tags, headings, description, and created date.

Use this information to help users find relevant notes, answer questions about their vault, and assist with vault organization.

When listing notes from the vault, ALWAYS use a single unified table with this exact format:
| Note | Created | Focus |
|------|---------|-------|
| [[path/to/note.md]] | YYYY-MM-DD | Key headings or topics from the note |

Rules:
- The Note column MUST use [[wikilink]] syntax so links are clickable
- The Created column shows the file creation date formatted as YYYY-MM-DD
- The Focus column summarizes the main headings or topics from the note
- Never split results into multiple tables - combine all matching notes into one table regardless of topic
- Search across title, aliases, tags, headings, and description to find relevant notes

Never claim you accessed anything not included in the vault_summary.
Output must be valid Markdown.`;
var RESEARCH_CREATE_NOTE_TEMPLATE = `You are an assistant inside Obsidian.
Follow the user's command precisely.

If web_search_results are provided, use them as reference material. When citing sources, use standard Markdown links like [Source Title](URL) - do NOT use reference markers like [REF] tags.

Your task is to research the user's topic using web search results and create a well-structured note.

Create a comprehensive research note with:
1. **Title**: A clear, descriptive title for the note
2. **Overview**: A brief summary of the topic
3. **Key Findings**: Main points organized with headings and subheadings
4. **Sources**: List of references with links

Format the output as a complete Markdown note that can be saved directly to the vault.

Structure guidelines:
- Use H1 (#) for the main title
- Use H2 (##) for major sections
- Use H3 (###) for subsections
- Include bullet points for lists
- Add code blocks where relevant
- Cite sources inline using [Source Title](URL) format
- End with a Sources section listing all references

Focus purely on web research - do not include information from the user's existing vault notes.

Never claim you accessed anything not included in the web_search_results.
Output must be valid Markdown.`;
var NOTE_CHAT_TEMPLATE = `You are an assistant inside Obsidian.
Follow the user's command precisely.

{% if web_search_enabled %}
If web_search_results are provided, use them as reference material. When citing sources, use standard Markdown links like [Source Title](URL) - do NOT use reference markers like [REF] tags.
{% endif %}

You have access to the full content of the user's current note via note_context.full_text.

Use this context to:
- Answer questions about the note's content
- Explain concepts mentioned in the note
- Suggest improvements or additions
- Help with writing, editing, or organizing the note
- Discuss topics related to the note

When referencing specific parts of the note, quote them directly.
When suggesting changes, clearly indicate what should be modified.

Never claim you accessed anything not included in the note content, selection, chat history, or web_search_results.
Output must be valid Markdown.`;
var SELECTION_TEMPLATE = `You are an assistant inside Obsidian.
Follow the user's command precisely.

{% if web_search_enabled %}
If web_search_results are provided, use them as reference material. When citing sources, use standard Markdown links like [Source Title](URL) - do NOT use reference markers like [REF] tags.
{% endif %}

You are working with a text selection from the user's note.

{% if command_id == "explain_selection" %}
Explain the selected text clearly and concisely. Break down complex concepts, define technical terms, and provide context where helpful.

{% elif command_id == "expand_selection" %}
Expand on the selected text by adding more detail, examples, or related information. Maintain the same tone and style as the original text.

{% elif command_id == "rewrite_selection_formal" %}
Rewrite the selected text in a formal, professional tone. Use precise language, avoid contractions, and maintain a serious tone appropriate for business or academic contexts.

{% elif command_id == "rewrite_selection_casual" %}
Rewrite the selected text in a casual, conversational tone. Use natural language, contractions where appropriate, and a friendly approachable style.

{% elif command_id == "rewrite_selection_active_voice" %}
Rewrite the selected text using active voice throughout. Convert passive constructions to active ones while preserving the original meaning.

{% elif command_id == "rewrite_selection_bullets" %}
Rewrite the selected text as bullet points. Extract key information and present it in a clear, scannable list format.

{% elif command_id == "caption_selection" %}
Generate a concise caption or title for the selected text. The caption should summarize the main point or theme.

{% elif command_id == "summarize_selection" %}
Summarize the selected text concisely. Capture the key points and main ideas in a shorter form while preserving essential information.

{% endif %}

Never claim you accessed anything not included in the note content, selection, chat history, or web_search_results.
Output must be valid Markdown.`;
var COMMAND_TEMPLATES = {
  // Vault commands
  vault_chat: VAULT_CHAT_TEMPLATE,
  research_create_note: RESEARCH_CREATE_NOTE_TEMPLATE,
  // Note command
  note_chat: NOTE_CHAT_TEMPLATE,
  // Selection commands (all use the same template with different context)
  explain_selection: SELECTION_TEMPLATE,
  expand_selection: SELECTION_TEMPLATE,
  rewrite_selection_formal: SELECTION_TEMPLATE,
  rewrite_selection_casual: SELECTION_TEMPLATE,
  rewrite_selection_active_voice: SELECTION_TEMPLATE,
  rewrite_selection_bullets: SELECTION_TEMPLATE,
  caption_selection: SELECTION_TEMPLATE,
  summarize_selection: SELECTION_TEMPLATE
};
function renderSystemMessage(context) {
  const template = COMMAND_TEMPLATES[context.command_id];
  if (!template) {
    return env.renderString(BASE_TEMPLATE, context);
  }
  return env.renderString(template, context);
}

// src/commands/prompting.ts
function generateSearchQueryMessages(context, userPrompt, scope) {
  var _a, _b, _c;
  const includeNoteContext = scope !== "vault";
  return [
    {
      role: "system",
      content: "You are a Search Query Generator. Your task is to extract a single, concise web search query from the user's request and the provided context. \n\nOutput ONLY the raw query string. No quotes, no markdown, no explanations. \n\nIf the text asks for a summary, query for the main entity or topic. \nIf the text is a question, refine it for a search engine (e.g., 'who won battle of hastings' instead of 'who won it?')."
    },
    {
      role: "user",
      content: `User Prompt: ${userPrompt || "None"}

Selected Text (Context):
${includeNoteContext && ((_a = context == null ? void 0 : context.selection) == null ? void 0 : _a.text) ? context.selection.text.slice(0, 500) : "None"}

Full Note Title:
${includeNoteContext && ((_b = context == null ? void 0 : context.note) == null ? void 0 : _b.title) ? (_c = context.note) == null ? void 0 : _c.title : "None"}`
    }
  ];
}
function buildPromptEnvelope(command, context, userPrompt, webSearchResults, vaultSummaryCache) {
  const includeNoteContext = command.scope !== "vault";
  const vaultSummary = command.id === "vault_chat" && vaultSummaryCache ? vaultSummaryCache.get() : null;
  return {
    command_id: command.id,
    note: includeNoteContext && (context == null ? void 0 : context.note) ? context.note : null,
    selection: includeNoteContext && (context == null ? void 0 : context.selection) ? context.selection : null,
    note_context: {
      full_text: command.scope === "note" && context ? context.fullText : null
      // Only send full text if scope requires it
    },
    user_prompt: userPrompt || null,
    constraints: {
      output_markdown: true
    },
    web_search_results: webSearchResults ? { enabled: true, ...webSearchResults } : { enabled: false },
    vault_summary: vaultSummary
  };
}
function createSystemMessage(command) {
  return renderSystemMessage({
    command_id: command.id,
    web_search_enabled: command.allowWebSearch
  });
}
function createUserMessage(envelope) {
  return `<obsidian_command>
${JSON.stringify(envelope, null, 2)}
</obsidian_command>`;
}

// src/providers/transport/httpClient.ts
var import_obsidian2 = require("obsidian");
var http = __toESM(require("http"));
var https = __toESM(require("https"));
var import_url = require("url");
var httpClient = {
  async get(url, headers = {}) {
    const res = await (0, import_obsidian2.requestUrl)({
      url,
      method: "GET",
      headers: {
        "Accept": "application/json",
        ...headers
      }
    });
    if (res.status >= 300) {
      throw new Error(`Request failed: ${res.status} ${res.text}`);
    }
    return res.json;
  },
  async post(url, body, headers = {}) {
    const res = await (0, import_obsidian2.requestUrl)({
      url,
      method: "POST",
      body: JSON.stringify(body),
      headers: {
        "Content-Type": "application/json",
        ...headers
      }
    });
    if (res.status >= 300) {
      throw new Error(`Request failed: ${res.status} ${res.text}`);
    }
    return res.json;
  },
  async stream(url, body, headers, onChunk, signal) {
    return new Promise((resolve, reject) => {
      const parsedUrl = new import_url.URL(url);
      const lib = parsedUrl.protocol === "https:" ? https : http;
      const opts = {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          ...headers
        }
      };
      const req = lib.request(parsedUrl, opts, (res) => {
        if (res.statusCode && res.statusCode >= 300) {
          let errBody = "";
          res.on("data", (c) => errBody += c);
          res.on("end", () => reject(new Error(`Stream failed: ${res.statusCode} ${errBody}`)));
          return;
        }
        res.setEncoding("utf8");
        res.on("data", (chunk) => {
          if (signal == null ? void 0 : signal.aborted) {
            res.destroy();
            return;
          }
          onChunk(chunk);
        });
        res.on("end", () => resolve());
        res.on("error", (err) => reject(err));
      });
      req.setTimeout(2e4, () => {
        req.destroy(new Error("Connection timed out"));
      });
      req.on("error", (err) => reject(err));
      req.write(JSON.stringify(body));
      req.end();
      if (signal) {
        signal.addEventListener("abort", () => {
          req.destroy();
          reject(new Error("Aborted"));
        });
      }
    });
  }
};

// src/providers/transport/ndjsonParser.ts
function createNdjsonParser(onEvent) {
  let buffer = "";
  return (chunk) => {
    buffer += chunk;
    const lines = buffer.split("\n");
    buffer = lines.pop() || "";
    for (const line of lines) {
      if (!line.trim())
        continue;
      try {
        const data = JSON.parse(line);
        if (data.done) {
          onEvent({ type: "done" });
          return;
        }
        if (data.message && data.message.content) {
          onEvent({ type: "token", value: data.message.content });
        } else if (data.response) {
          onEvent({ type: "token", value: data.response });
        }
      } catch (err) {
        console.error("NDJSON parse error", err, line);
      }
    }
  };
}

// src/providers/ollama.ts
var OllamaClient = class {
  constructor(baseUrl) {
    this.kind = "ollama";
    this.baseUrl = baseUrl.replace(/\/+$/, "");
  }
  async listModels() {
    const url = `${this.baseUrl}/api/tags`;
    const res = await httpClient.get(url);
    const models = res.models || [];
    return models.map((m) => ({
      id: m.name,
      label: m.name,
      details: m
    }));
  }
  async chat(req, onEvent, abortSignal) {
    var _a;
    const url = `${this.baseUrl}/api/chat`;
    const body = {
      model: req.model,
      messages: req.messages,
      stream: req.stream,
      options: {
        temperature: req.temperature
      }
    };
    if (req.stream) {
      const parser = createNdjsonParser(onEvent);
      await httpClient.stream(url, body, {}, parser, abortSignal);
      return { content: "" };
    } else {
      const res = await httpClient.post(url, body);
      const content = ((_a = res.message) == null ? void 0 : _a.content) || "";
      return { content, raw: res };
    }
  }
};

// src/providers/transport/sseParser.ts
function createSseParser(onEvent) {
  let buffer = "";
  return (chunk) => {
    var _a, _b, _c;
    buffer += chunk;
    const lines = buffer.split("\n");
    buffer = lines.pop() || "";
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed.startsWith("data:"))
        continue;
      const dataStr = trimmed.slice(5).trim();
      if (dataStr === "[DONE]") {
        onEvent({ type: "done" });
        continue;
      }
      try {
        const data = JSON.parse(dataStr);
        const delta = (_c = (_b = (_a = data.choices) == null ? void 0 : _a[0]) == null ? void 0 : _b.delta) == null ? void 0 : _c.content;
        if (delta) {
          onEvent({ type: "token", value: delta });
        }
      } catch (e) {
      }
    }
  };
}

// src/providers/openai_compatible.ts
var OpenAICompatibleClient = class {
  constructor(baseUrl, apiKey) {
    this.kind = "openai_compatible";
    let url = baseUrl.replace(/\/+$/, "");
    if (url.endsWith("/v1")) {
      url = url.substring(0, url.length - 3);
    }
    this.baseUrl = url;
    this.apiKey = apiKey || "";
  }
  getHeaders() {
    const headers = {
      "Authorization": `Bearer ${this.apiKey}`
    };
    return headers;
  }
  async listModels() {
    const url = `${this.baseUrl}/v1/models`;
    try {
      const res = await httpClient.get(url, this.getHeaders());
      const data = res.data || [];
      return data.map((m) => ({
        id: m.id,
        label: m.id,
        details: m
      }));
    } catch (err) {
      console.warn("Failed to fetch models from openai compatible endpoint", err);
      return [];
    }
  }
  async chat(req, onEvent, abortSignal) {
    var _a, _b, _c;
    const url = `${this.baseUrl}/v1/chat/completions`;
    const body = {
      model: req.model,
      temperature: req.temperature,
      stream: req.stream,
      messages: req.messages
      // Note: Spec 7.3 says web snippets are injected into messages.
      // The req.messages passed here are already prepared by the caller (Prompting layer).
    };
    const headers = this.getHeaders();
    if (req.stream) {
      const parser = createSseParser(onEvent);
      await httpClient.stream(url, body, headers, parser, abortSignal);
      return { content: "" };
    } else {
      const res = await httpClient.post(url, body, headers);
      const content = ((_c = (_b = (_a = res.choices) == null ? void 0 : _a[0]) == null ? void 0 : _b.message) == null ? void 0 : _c.content) || "";
      return { content, raw: res };
    }
  }
};

// src/providers/index.ts
function createProviderClient(provider, settings) {
  if (provider === "ollama") {
    const ollamaSettings = settings;
    return new OllamaClient(ollamaSettings.baseUrl);
  } else {
    const openaiSettings = settings;
    return new OpenAICompatibleClient(openaiSettings.baseUrl, openaiSettings.apiKey);
  }
}

// src/websearch/searxng.ts
var import_obsidian3 = require("obsidian");
async function runSearxngSearch(query, settings) {
  const url = settings.urlTemplate.replace("%s", encodeURIComponent(query));
  try {
    const res = await (0, import_obsidian3.requestUrl)({
      url,
      method: "GET",
      // Spec 7.1: format=json implied in urlTemplate or params
      // user responsible for urlTemplate including format=json if they deviate from default
      headers: {
        "Accept": "application/json"
      }
    });
    if (res.status >= 300) {
      throw new Error(`Search failed: ${res.status}`);
    }
    const data = res.json;
    if (!data.results || !Array.isArray(data.results)) {
      throw new Error("Invalid search response: missing results array");
    }
    const rawResults = data.results.slice(0, settings.maxResults);
    const results = rawResults.map((item) => ({
      title: item.title || "No title",
      url: item.url || item.link || "",
      // 'link' is common in some APIs, 'url' in others. SearXNG uses 'url'.
      content: stripHtml(item.content || item.snippet || ""),
      // Spec 7.2: strip tags
      engine: item.engine,
      score: item.score
    }));
    return {
      query,
      results
    };
  } catch (err) {
    console.error("Web search error", err);
    throw err;
  }
}
function stripHtml(html) {
  return html.replace(/<[^>]*>?/gm, "");
}

// src/ui/commandPicker.ts
var import_obsidian4 = require("obsidian");
var CommandPickerModal = class extends import_obsidian4.FuzzySuggestModal {
  constructor(plugin, onChoose) {
    super(plugin.app);
    this.plugin = plugin;
    this.onChoose = onChoose;
    this.setPlaceholder("Search for a command...");
  }
  getItems() {
    return [...COMMANDS];
  }
  getItemText(command) {
    return `${command.title} ${command.scope}`;
  }
  onChooseItem(command, evt) {
    this.onChoose(command.id);
  }
};

// src/ui/svelte/ChatView.svelte
var import_obsidian5 = require("obsidian");
function add_css(target) {
  append_styles(target, "svelte-1gx429z", "textarea.svelte-1gx429z{field-sizing:content}");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[29] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[32] = list[i];
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[35] = list[i];
  child_ctx[37] = i;
  return child_ctx;
}
function create_if_block_9(ctx) {
  let div3;
  let div2;
  let div1;
  let div0;
  let markdown_action;
  let t;
  let div2_class_value;
  let div3_class_value;
  let div3_transition;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*message*/
    ctx[35].role === "assistant" && create_if_block_10(ctx)
  );
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      t = space();
      if (if_block)
        if_block.c();
      attr(div0, "class", "markdown-preview select-text helper-render");
      attr(div1, "class", "prose prose-sm prose-invert max-w-none break-words");
      attr(div2, "class", div2_class_value = "group relative max-w-[85%] rounded-2xl px-4 py-3 text-sm " + /*message*/
      (ctx[35].role === "user" ? "bg-primary text-primary-foreground rounded-br-sm" : "bg-muted/50 rounded-bl-sm"));
      attr(div3, "class", div3_class_value = "flex w-full " + /*message*/
      (ctx[35].role === "user" ? "justify-end" : "justify-start"));
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div1);
      append(div1, div0);
      append(div2, t);
      if (if_block)
        if_block.m(div2, null);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(markdown_action = /*markdown*/
        ctx[19].call(
          null,
          div0,
          /*message*/
          ctx[35].role === "assistant" ? (
            /*cleanAssistantMessage*/
            ctx[18](
              /*message*/
              ctx[35].content
            )
          ) : (
            /*message*/
            ctx[35].content
          )
        ));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (markdown_action && is_function(markdown_action.update) && dirty[0] & /*messages*/
      2)
        markdown_action.update.call(
          null,
          /*message*/
          ctx[35].role === "assistant" ? (
            /*cleanAssistantMessage*/
            ctx[18](
              /*message*/
              ctx[35].content
            )
          ) : (
            /*message*/
            ctx[35].content
          )
        );
      if (
        /*message*/
        ctx[35].role === "assistant"
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_10(ctx);
          if_block.c();
          if_block.m(div2, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty[0] & /*messages*/
      2 && div2_class_value !== (div2_class_value = "group relative max-w-[85%] rounded-2xl px-4 py-3 text-sm " + /*message*/
      (ctx[35].role === "user" ? "bg-primary text-primary-foreground rounded-br-sm" : "bg-muted/50 rounded-bl-sm"))) {
        attr(div2, "class", div2_class_value);
      }
      if (!current || dirty[0] & /*messages*/
      2 && div3_class_value !== (div3_class_value = "flex w-full " + /*message*/
      (ctx[35].role === "user" ? "justify-end" : "justify-start"))) {
        attr(div3, "class", div3_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div3_transition)
            div3_transition = create_bidirectional_transition(div3, fade, { duration: 150 }, true);
          div3_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      if (local) {
        if (!div3_transition)
          div3_transition = create_bidirectional_transition(div3, fade, { duration: 150 }, false);
        div3_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      if (if_block)
        if_block.d();
      if (detaching && div3_transition)
        div3_transition.end();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_10(ctx) {
  var _a;
  let div;
  let button;
  let button_class_value;
  let button_title_value;
  let t0;
  let t1;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*copiedMessageIndex*/
      ctx2[8] === /*index*/
      ctx2[37]
    )
      return create_if_block_15;
    return create_else_block_5;
  }
  let current_block_type = select_block_type(ctx, [-1, -1]);
  let if_block0 = current_block_type(ctx);
  function click_handler() {
    return (
      /*click_handler*/
      ctx[22](
        /*message*/
        ctx[35],
        /*index*/
        ctx[37]
      )
    );
  }
  let if_block1 = (
    /*message*/
    ((_a = ctx[35].context) == null ? void 0 : _a.selection) && create_if_block_13(ctx)
  );
  let if_block2 = (
    /*activeCommandId*/
    ctx[3] === "research_create_note" && create_if_block_11(ctx)
  );
  return {
    c() {
      div = element("div");
      button = element("button");
      if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      attr(button, "class", button_class_value = "p-1.5 rounded-md hover:bg-background/20 transition-colors " + /*copiedMessageIndex*/
      (ctx[8] === /*index*/
      ctx[37] ? "text-primary" : "text-muted-foreground hover:text-foreground"));
      attr(button, "title", button_title_value = /*copiedMessageIndex*/
      ctx[8] === /*index*/
      ctx[37] ? "Copied!" : "Copy to clipboard");
      attr(div, "class", "mt-2 pt-2 border-t border-border/50 flex items-center justify-end gap-1 opacity-0 group-hover:opacity-100 transition-opacity");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      if_block0.m(button, null);
      append(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append(div, t1);
      if (if_block2)
        if_block2.m(div, null);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      var _a2;
      ctx = new_ctx;
      if (current_block_type !== (current_block_type = select_block_type(ctx, dirty))) {
        if_block0.d(1);
        if_block0 = current_block_type(ctx);
        if (if_block0) {
          if_block0.c();
          if_block0.m(button, null);
        }
      }
      if (dirty[0] & /*copiedMessageIndex*/
      256 && button_class_value !== (button_class_value = "p-1.5 rounded-md hover:bg-background/20 transition-colors " + /*copiedMessageIndex*/
      (ctx[8] === /*index*/
      ctx[37] ? "text-primary" : "text-muted-foreground hover:text-foreground"))) {
        attr(button, "class", button_class_value);
      }
      if (dirty[0] & /*copiedMessageIndex*/
      256 && button_title_value !== (button_title_value = /*copiedMessageIndex*/
      ctx[8] === /*index*/
      ctx[37] ? "Copied!" : "Copy to clipboard")) {
        attr(button, "title", button_title_value);
      }
      if (
        /*message*/
        (_a2 = ctx[35].context) == null ? void 0 : _a2.selection
      ) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block_13(ctx);
          if_block1.c();
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*activeCommandId*/
        ctx[3] === "research_create_note"
      ) {
        if (if_block2) {
          if_block2.p(ctx, dirty);
        } else {
          if_block2 = create_if_block_11(ctx);
          if_block2.c();
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      mounted = false;
      dispose();
    }
  };
}
function create_else_block_5(ctx) {
  let svg;
  let rect;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      rect = svg_element("rect");
      path = svg_element("path");
      attr(rect, "width", "14");
      attr(rect, "height", "14");
      attr(rect, "x", "8");
      attr(rect, "y", "8");
      attr(rect, "rx", "2");
      attr(rect, "ry", "2");
      attr(path, "d", "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "14");
      attr(svg, "height", "14");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, rect);
      append(svg, path);
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_if_block_15(ctx) {
  let svg;
  let polyline;
  return {
    c() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      attr(polyline, "points", "20 6 9 17 4 12");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "14");
      attr(svg, "height", "14");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, polyline);
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_if_block_13(ctx) {
  let button;
  let button_class_value;
  let button_title_value;
  let mounted;
  let dispose;
  function select_block_type_1(ctx2, dirty) {
    if (
      /*replacedMessageIndex*/
      ctx2[9] === /*index*/
      ctx2[37]
    )
      return create_if_block_14;
    return create_else_block_4;
  }
  let current_block_type = select_block_type_1(ctx, [-1, -1]);
  let if_block = current_block_type(ctx);
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[23](
        /*message*/
        ctx[35],
        /*index*/
        ctx[37]
      )
    );
  }
  return {
    c() {
      button = element("button");
      if_block.c();
      attr(button, "class", button_class_value = "p-1.5 rounded-md hover:bg-background/20 transition-colors " + /*replacedMessageIndex*/
      (ctx[9] === /*index*/
      ctx[37] ? "text-primary" : "text-muted-foreground hover:text-foreground"));
      attr(button, "title", button_title_value = /*replacedMessageIndex*/
      ctx[9] === /*index*/
      ctx[37] ? "Replaced!" : "Replace selection with this text");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if_block.m(button, null);
      if (!mounted) {
        dispose = listen(button, "click", click_handler_1);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (current_block_type !== (current_block_type = select_block_type_1(ctx, dirty))) {
        if_block.d(1);
        if_block = current_block_type(ctx);
        if (if_block) {
          if_block.c();
          if_block.m(button, null);
        }
      }
      if (dirty[0] & /*replacedMessageIndex*/
      512 && button_class_value !== (button_class_value = "p-1.5 rounded-md hover:bg-background/20 transition-colors " + /*replacedMessageIndex*/
      (ctx[9] === /*index*/
      ctx[37] ? "text-primary" : "text-muted-foreground hover:text-foreground"))) {
        attr(button, "class", button_class_value);
      }
      if (dirty[0] & /*replacedMessageIndex*/
      512 && button_title_value !== (button_title_value = /*replacedMessageIndex*/
      ctx[9] === /*index*/
      ctx[37] ? "Replaced!" : "Replace selection with this text")) {
        attr(button, "title", button_title_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_else_block_4(ctx) {
  let svg;
  let path;
  let polygon;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      polygon = svg_element("polygon");
      attr(path, "d", "M20 14.66V20a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h5.34");
      attr(polygon, "points", "18 2 22 6 12 16 8 16 8 12 18 2");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "14");
      attr(svg, "height", "14");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
      append(svg, polygon);
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_if_block_14(ctx) {
  let svg;
  let polyline;
  return {
    c() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      attr(polyline, "points", "20 6 9 17 4 12");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "14");
      attr(svg, "height", "14");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, polyline);
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_if_block_11(ctx) {
  let button;
  let button_class_value;
  let button_title_value;
  let mounted;
  let dispose;
  function select_block_type_2(ctx2, dirty) {
    if (
      /*createdNoteIndex*/
      ctx2[10] === /*index*/
      ctx2[37]
    )
      return create_if_block_12;
    return create_else_block_3;
  }
  let current_block_type = select_block_type_2(ctx, [-1, -1]);
  let if_block = current_block_type(ctx);
  function click_handler_2() {
    return (
      /*click_handler_2*/
      ctx[24](
        /*message*/
        ctx[35],
        /*index*/
        ctx[37]
      )
    );
  }
  return {
    c() {
      button = element("button");
      if_block.c();
      attr(button, "class", button_class_value = "p-1.5 rounded-md hover:bg-background/20 transition-colors " + /*createdNoteIndex*/
      (ctx[10] === /*index*/
      ctx[37] ? "text-primary" : "text-muted-foreground hover:text-foreground"));
      attr(button, "title", button_title_value = /*createdNoteIndex*/
      ctx[10] === /*index*/
      ctx[37] ? "Note created!" : "Create note from this response");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if_block.m(button, null);
      if (!mounted) {
        dispose = listen(button, "click", click_handler_2);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (current_block_type !== (current_block_type = select_block_type_2(ctx, dirty))) {
        if_block.d(1);
        if_block = current_block_type(ctx);
        if (if_block) {
          if_block.c();
          if_block.m(button, null);
        }
      }
      if (dirty[0] & /*createdNoteIndex*/
      1024 && button_class_value !== (button_class_value = "p-1.5 rounded-md hover:bg-background/20 transition-colors " + /*createdNoteIndex*/
      (ctx[10] === /*index*/
      ctx[37] ? "text-primary" : "text-muted-foreground hover:text-foreground"))) {
        attr(button, "class", button_class_value);
      }
      if (dirty[0] & /*createdNoteIndex*/
      1024 && button_title_value !== (button_title_value = /*createdNoteIndex*/
      ctx[10] === /*index*/
      ctx[37] ? "Note created!" : "Create note from this response")) {
        attr(button, "title", button_title_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_else_block_3(ctx) {
  let svg;
  let path;
  let polyline;
  let line0;
  let line1;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      polyline = svg_element("polyline");
      line0 = svg_element("line");
      line1 = svg_element("line");
      attr(path, "d", "M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z");
      attr(polyline, "points", "14 2 14 8 20 8");
      attr(line0, "x1", "12");
      attr(line0, "y1", "18");
      attr(line0, "x2", "12");
      attr(line0, "y2", "12");
      attr(line1, "x1", "9");
      attr(line1, "y1", "15");
      attr(line1, "x2", "15");
      attr(line1, "y2", "15");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "14");
      attr(svg, "height", "14");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
      append(svg, polyline);
      append(svg, line0);
      append(svg, line1);
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_if_block_12(ctx) {
  let svg;
  let polyline;
  return {
    c() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      attr(polyline, "points", "20 6 9 17 4 12");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "14");
      attr(svg, "height", "14");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, polyline);
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_each_block_2(ctx) {
  let show_if = !/*message*/
  ctx[35].content.trim().startsWith("<obsidian_command>");
  let if_block_anchor;
  let if_block = show_if && create_if_block_9(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*messages*/
      2)
        show_if = !/*message*/
        ctx2[35].content.trim().startsWith("<obsidian_command>");
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*messages*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_9(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_if_block_3(ctx) {
  let div2;
  let div1;
  let div0;
  let t0;
  let t1;
  let div2_transition;
  let current;
  function select_block_type_3(ctx2, dirty) {
    if (
      /*status*/
      ctx2[2] === "searching"
    )
      return create_if_block_8;
    return create_else_block_2;
  }
  let current_block_type = select_block_type_3(ctx, [-1, -1]);
  let if_block0 = current_block_type(ctx);
  let if_block1 = (
    /*searchQueries*/
    ctx[6] && /*searchQueries*/
    ctx[6].length > 0 && create_if_block_7(ctx)
  );
  let if_block2 = (
    /*webSearchResults*/
    ctx[7] && /*webSearchResults*/
    ctx[7].results.length > 0 && create_if_block_4(ctx)
  );
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      attr(div0, "class", "flex items-center gap-2 mb-2");
      attr(div1, "class", "max-w-[90%] rounded-2xl rounded-tl-sm px-4 py-3 bg-muted/30 text-xs border border-border/40");
      attr(div2, "class", "flex w-full justify-start");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      if_block0.m(div0, null);
      append(div1, t0);
      if (if_block1)
        if_block1.m(div1, null);
      append(div1, t1);
      if (if_block2)
        if_block2.m(div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_3(ctx2, dirty)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div0, null);
        }
      }
      if (
        /*searchQueries*/
        ctx2[6] && /*searchQueries*/
        ctx2[6].length > 0
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_7(ctx2);
          if_block1.c();
          if_block1.m(div1, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*webSearchResults*/
        ctx2[7] && /*webSearchResults*/
        ctx2[7].results.length > 0
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_4(ctx2);
          if_block2.c();
          if_block2.m(div1, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    i(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div2_transition)
            div2_transition = create_bidirectional_transition(div2, fade, {}, true);
          div2_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      if (local) {
        if (!div2_transition)
          div2_transition = create_bidirectional_transition(div2, fade, {}, false);
        div2_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (detaching && div2_transition)
        div2_transition.end();
    }
  };
}
function create_else_block_2(ctx) {
  let svg;
  let path;
  let polyline;
  let t0;
  let span;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      polyline = svg_element("polyline");
      t0 = space();
      span = element("span");
      span.textContent = "Sources";
      attr(path, "d", "M22 11.08V12a10 10 0 1 1-5.93-9.14");
      attr(polyline, "points", "22 4 12 14.01 9 11.01");
      attr(svg, "class", "h-3.5 w-3.5 text-primary");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
      attr(span, "class", "text-muted-foreground font-medium");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
      append(svg, polyline);
      insert(target, t0, anchor);
      insert(target, span, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(svg);
        detach(t0);
        detach(span);
      }
    }
  };
}
function create_if_block_8(ctx) {
  let svg;
  let circle;
  let path;
  let t0;
  let span;
  let t1_value = (
    /*searchStatus*/
    (ctx[5] || "Searching...") + ""
  );
  let t1;
  return {
    c() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      path = svg_element("path");
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      attr(circle, "class", "opacity-25");
      attr(circle, "cx", "12");
      attr(circle, "cy", "12");
      attr(circle, "r", "10");
      attr(circle, "stroke", "currentColor");
      attr(circle, "stroke-width", "4");
      attr(path, "class", "opacity-75");
      attr(path, "fill", "currentColor");
      attr(path, "d", "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z");
      attr(svg, "class", "animate-spin h-3.5 w-3.5 text-primary");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(span, "class", "text-muted-foreground font-medium");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, circle);
      append(svg, path);
      insert(target, t0, anchor);
      insert(target, span, anchor);
      append(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*searchStatus*/
      32 && t1_value !== (t1_value = /*searchStatus*/
      (ctx2[5] || "Searching...") + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
        detach(t0);
        detach(span);
      }
    }
  };
}
function create_if_block_7(ctx) {
  let div;
  let each_value_1 = ensure_array_like(
    /*searchQueries*/
    ctx[6]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "flex flex-wrap gap-1.5 mb-3");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*searchQueries*/
      64) {
        each_value_1 = ensure_array_like(
          /*searchQueries*/
          ctx2[6]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_1(ctx) {
  let div;
  let svg;
  let circle;
  let path;
  let t0;
  let span;
  let t1_value = (
    /*query*/
    ctx[32] + ""
  );
  let t1;
  let t2;
  return {
    c() {
      div = element("div");
      svg = svg_element("svg");
      circle = svg_element("circle");
      path = svg_element("path");
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      t2 = space();
      attr(circle, "cx", "11");
      attr(circle, "cy", "11");
      attr(circle, "r", "8");
      attr(path, "d", "m21 21-4.3-4.3");
      attr(svg, "class", "w-3 h-3 opacity-50");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "2");
      attr(span, "class", "truncate max-w-[150px]");
      attr(div, "class", "inline-flex items-center gap-1 px-2 py-0.5 rounded-full bg-background border border-border/50 text-[10px] text-muted-foreground");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, svg);
      append(svg, circle);
      append(svg, path);
      append(div, t0);
      append(div, span);
      append(span, t1);
      append(div, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*searchQueries*/
      64 && t1_value !== (t1_value = /*query*/
      ctx2[32] + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block_4(ctx) {
  let div1;
  let div0;
  let t;
  let each_value = ensure_array_like(
    /*webSearchResults*/
    ctx[7].results.slice(0, 5)
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  let if_block = (
    /*webSearchResults*/
    ctx[7].results.length > 5 && create_if_block_5(ctx)
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      if (if_block)
        if_block.c();
      attr(div0, "class", "flex flex-wrap gap-2");
      attr(div1, "class", "space-y-2 pt-1");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      append(div0, t);
      if (if_block)
        if_block.m(div0, null);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*webSearchResults*/
      128) {
        each_value = ensure_array_like(
          /*webSearchResults*/
          ctx2[7].results.slice(0, 5)
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div0, t);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (
        /*webSearchResults*/
        ctx2[7].results.length > 5
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_5(ctx2);
          if_block.c();
          if_block.m(div0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_each(each_blocks, detaching);
      if (if_block)
        if_block.d();
    }
  };
}
function create_else_block_1(ctx) {
  let svg;
  let circle;
  let line;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      line = svg_element("line");
      path = svg_element("path");
      attr(circle, "cx", "12");
      attr(circle, "cy", "12");
      attr(circle, "r", "10");
      attr(line, "x1", "2");
      attr(line, "y1", "12");
      attr(line, "x2", "22");
      attr(line, "y2", "12");
      attr(path, "d", "M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z");
      attr(svg, "class", "w-3.5 h-3.5");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "2");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, circle);
      append(svg, line);
      append(svg, path);
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_if_block_6(ctx) {
  let svg;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "d", "M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z");
      attr(svg, "class", "w-3.5 h-3.5");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "currentColor");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_each_block(ctx) {
  let a;
  let div;
  let show_if;
  let t0;
  let span;
  let t1_value = (
    /*result*/
    ctx[29].title + ""
  );
  let t1;
  let a_href_value;
  function select_block_type_4(ctx2, dirty) {
    if (dirty[0] & /*webSearchResults*/
    128)
      show_if = null;
    if (show_if == null)
      show_if = !!/*result*/
      ctx2[29].url.includes("github.com");
    if (show_if)
      return create_if_block_6;
    return create_else_block_1;
  }
  let current_block_type = select_block_type_4(ctx, [-1, -1]);
  let if_block = current_block_type(ctx);
  return {
    c() {
      a = element("a");
      div = element("div");
      if_block.c();
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      attr(div, "class", "shrink-0 text-muted-foreground/70 group-hover:text-primary transition-colors");
      attr(span, "class", "text-xs font-medium text-foreground truncate group-hover:text-primary transition-colors max-w-[150px]");
      attr(a, "href", a_href_value = /*result*/
      ctx[29].url);
      attr(a, "target", "_blank");
      attr(a, "rel", "noopener noreferrer");
      attr(a, "class", "inline-flex items-center gap-1.5 px-3 py-1.5 rounded-full bg-background hover:bg-muted/50 border border-border/50 hover:border-primary/30 transition-all no-underline group max-w-full shadow-sm");
    },
    m(target, anchor) {
      insert(target, a, anchor);
      append(a, div);
      if_block.m(div, null);
      append(a, t0);
      append(a, span);
      append(span, t1);
    },
    p(ctx2, dirty) {
      if (current_block_type !== (current_block_type = select_block_type_4(ctx2, dirty))) {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
      if (dirty[0] & /*webSearchResults*/
      128 && t1_value !== (t1_value = /*result*/
      ctx2[29].title + ""))
        set_data(t1, t1_value);
      if (dirty[0] & /*webSearchResults*/
      128 && a_href_value !== (a_href_value = /*result*/
      ctx2[29].url)) {
        attr(a, "href", a_href_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(a);
      }
      if_block.d();
    }
  };
}
function create_if_block_5(ctx) {
  let span;
  let t0;
  let t1_value = (
    /*webSearchResults*/
    ctx[7].results.length - 5 + ""
  );
  let t1;
  let t2;
  return {
    c() {
      span = element("span");
      t0 = text("+");
      t1 = text(t1_value);
      t2 = text(" more");
      attr(span, "class", "text-[10px] text-muted-foreground self-center px-1");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*webSearchResults*/
      128 && t1_value !== (t1_value = /*webSearchResults*/
      ctx2[7].results.length - 5 + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_1(ctx) {
  let div1;
  let div0;
  let div1_transition;
  let current;
  function select_block_type_5(ctx2, dirty) {
    if (
      /*displayResponse*/
      ctx2[11]
    )
      return create_if_block_2;
    return create_else_block;
  }
  let current_block_type = select_block_type_5(ctx, [-1, -1]);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if_block.c();
      attr(div0, "class", "max-w-[85%] rounded-2xl rounded-bl-sm px-4 py-3 bg-muted/50 text-sm");
      attr(div1, "class", "flex w-full justify-start");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if_block.m(div0, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_5(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div0, null);
        }
      }
    },
    i(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div1_transition)
            div1_transition = create_bidirectional_transition(div1, fade, {}, true);
          div1_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      if (local) {
        if (!div1_transition)
          div1_transition = create_bidirectional_transition(div1, fade, {}, false);
        div1_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if_block.d();
      if (detaching && div1_transition)
        div1_transition.end();
    }
  };
}
function create_else_block(ctx) {
  let div;
  let svg;
  let circle;
  let path;
  let t0;
  let span;
  let t1_value = (
    /*status*/
    ctx[2] === "sending" ? "Preparing..." : "Generating..."
  );
  let t1;
  return {
    c() {
      div = element("div");
      svg = svg_element("svg");
      circle = svg_element("circle");
      path = svg_element("path");
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      attr(circle, "class", "opacity-25");
      attr(circle, "cx", "12");
      attr(circle, "cy", "12");
      attr(circle, "r", "10");
      attr(circle, "stroke", "currentColor");
      attr(circle, "stroke-width", "4");
      attr(path, "class", "opacity-75");
      attr(path, "fill", "currentColor");
      attr(path, "d", "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z");
      attr(svg, "class", "animate-spin h-4 w-4 text-primary");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 24 24");
      attr(span, "class", "text-muted-foreground text-xs");
      attr(div, "class", "flex items-center gap-2 h-6");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, svg);
      append(svg, circle);
      append(svg, path);
      append(div, t0);
      append(div, span);
      append(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*status*/
      4 && t1_value !== (t1_value = /*status*/
      ctx2[2] === "sending" ? "Preparing..." : "Generating..."))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block_2(ctx) {
  let div1;
  let div0;
  let markdown_action;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      attr(div0, "class", "markdown-preview select-text helper-render");
      attr(div1, "class", "prose prose-sm prose-invert max-w-none break-words");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (!mounted) {
        dispose = action_destroyer(markdown_action = /*markdown*/
        ctx[19].call(
          null,
          div0,
          /*displayResponse*/
          ctx[11]
        ));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (markdown_action && is_function(markdown_action.update) && dirty[0] & /*displayResponse*/
      2048)
        markdown_action.update.call(
          null,
          /*displayResponse*/
          ctx2[11]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<svg class="w-4 h-4 text-primary" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>`;
      attr(div, "class", "absolute inset-0 flex items-center justify-center");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_fragment(ctx) {
  let div5;
  let div0;
  let t0;
  let t1;
  let t2;
  let div4;
  let div2;
  let textarea;
  let textarea_disabled_value;
  let t3;
  let button0;
  let div1;
  let svg0;
  let circle;
  let path0;
  let path1;
  let svg0_class_value;
  let t4;
  let button0_class_value;
  let button0_title_value;
  let t5;
  let button1;
  let svg1;
  let path2;
  let path3;
  let button1_disabled_value;
  let t6;
  let div3;
  let mounted;
  let dispose;
  let each_value_2 = ensure_array_like(
    /*messages*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  let if_block0 = (
    /*status*/
    (ctx[2] === "searching" || /*webSearchResults*/
    ctx[7] && /*webSearchResults*/
    ctx[7].results.length > 0) && create_if_block_3(ctx)
  );
  let if_block1 = (
    /*status*/
    (ctx[2] === "streaming" || /*status*/
    ctx[2] === "sending") && create_if_block_1(ctx)
  );
  let if_block2 = (
    /*webSearchEnabled*/
    ctx[4] && create_if_block(ctx)
  );
  return {
    c() {
      div5 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      div4 = element("div");
      div2 = element("div");
      textarea = element("textarea");
      t3 = space();
      button0 = element("button");
      div1 = element("div");
      svg0 = svg_element("svg");
      circle = svg_element("circle");
      path0 = svg_element("path");
      path1 = svg_element("path");
      t4 = space();
      if (if_block2)
        if_block2.c();
      t5 = space();
      button1 = element("button");
      svg1 = svg_element("svg");
      path2 = svg_element("path");
      path3 = svg_element("path");
      t6 = space();
      div3 = element("div");
      div3.textContent = "Press Enter to send, Shift+Enter for new line";
      attr(div0, "class", "flex-1 overflow-y-auto p-4 space-y-4");
      attr(textarea, "placeholder", "Message AI...");
      attr(textarea, "rows", "1");
      attr(textarea, "class", "flex-1 min-h-[44px] max-h-32 resize-none bg-transparent px-3 py-2.5 text-sm placeholder:text-muted-foreground/70 focus:outline-none scrollbar-hide svelte-1gx429z");
      textarea.disabled = textarea_disabled_value = /*status*/
      ctx[2] === "streaming";
      attr(circle, "cx", "12");
      attr(circle, "cy", "12");
      attr(circle, "r", "10");
      attr(path0, "d", "M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20");
      attr(path1, "d", "M2 12h20");
      attr(svg0, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg0, "width", "18");
      attr(svg0, "height", "18");
      attr(svg0, "viewBox", "0 0 24 24");
      attr(svg0, "fill", "none");
      attr(svg0, "stroke", "currentColor");
      attr(svg0, "stroke-width", "2");
      attr(svg0, "stroke-linecap", "round");
      attr(svg0, "stroke-linejoin", "round");
      attr(svg0, "class", svg0_class_value = /*webSearchEnabled*/
      ctx[4] ? "opacity-20" : "");
      attr(div1, "class", "relative");
      attr(button0, "class", button0_class_value = "relative mb-0.5 inline-flex h-9 w-9 items-center justify-center rounded-lg transition-all hover:bg-muted " + /*webSearchEnabled*/
      (ctx[4] ? "text-primary bg-primary/10" : "text-muted-foreground/50"));
      attr(button0, "title", button0_title_value = /*webSearchEnabled*/
      ctx[4] ? "Disable Web Search" : "Enable Web Search");
      attr(path2, "d", "m22 2-7 20-4-9-9-4Z");
      attr(path3, "d", "M22 2 11 13");
      attr(svg1, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg1, "width", "16");
      attr(svg1, "height", "16");
      attr(svg1, "viewBox", "0 0 24 24");
      attr(svg1, "fill", "none");
      attr(svg1, "stroke", "currentColor");
      attr(svg1, "stroke-width", "2");
      attr(svg1, "stroke-linecap", "round");
      attr(svg1, "stroke-linejoin", "round");
      button1.disabled = button1_disabled_value = !/*userPrompt*/
      ctx[0].trim() || /*status*/
      ctx[2] === "streaming";
      attr(button1, "class", "mb-0.5 inline-flex h-9 w-9 items-center justify-center rounded-lg bg-primary text-primary-foreground transition-all hover:bg-primary/90 disabled:opacity-0 disabled:scale-95");
      attr(div2, "class", "relative flex items-end gap-2 p-1.5 rounded-xl border border-input focus-within:ring-2 focus-within:ring-ring/20 bg-muted/30 transition-all duration-200");
      attr(div3, "class", "px-1 py-1 text-xs text-muted-foreground/50 text-center");
      attr(div4, "class", "p-4 bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60");
      attr(div5, "class", "h-full flex flex-col");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      append(div0, t0);
      if (if_block0)
        if_block0.m(div0, null);
      append(div0, t1);
      if (if_block1)
        if_block1.m(div0, null);
      append(div5, t2);
      append(div5, div4);
      append(div4, div2);
      append(div2, textarea);
      set_input_value(
        textarea,
        /*userPrompt*/
        ctx[0]
      );
      append(div2, t3);
      append(div2, button0);
      append(button0, div1);
      append(div1, svg0);
      append(svg0, circle);
      append(svg0, path0);
      append(svg0, path1);
      append(div1, t4);
      if (if_block2)
        if_block2.m(div1, null);
      append(div2, t5);
      append(div2, button1);
      append(button1, svg1);
      append(svg1, path2);
      append(svg1, path3);
      append(div4, t6);
      append(div4, div3);
      if (!mounted) {
        dispose = [
          listen(
            textarea,
            "input",
            /*textarea_input_handler*/
            ctx[25]
          ),
          listen(
            textarea,
            "keydown",
            /*handleKeyDown*/
            ctx[12]
          ),
          listen(
            button0,
            "click",
            /*toggleWebSearch*/
            ctx[14]
          ),
          listen(
            button1,
            "click",
            /*handleSend*/
            ctx[13]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*messages, createdNoteIndex, handleCreateNote, activeCommandId, replacedMessageIndex, handleReplace, copiedMessageIndex, handleCopy, cleanAssistantMessage*/
      493322) {
        each_value_2 = ensure_array_like(
          /*messages*/
          ctx2[1]
        );
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div0, t0);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_2.length;
      }
      if (
        /*status*/
        ctx2[2] === "searching" || /*webSearchResults*/
        ctx2[7] && /*webSearchResults*/
        ctx2[7].results.length > 0
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*status, webSearchResults*/
          132) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*status*/
        ctx2[2] === "streaming" || /*status*/
        ctx2[2] === "sending"
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*status*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (dirty[0] & /*status*/
      4 && textarea_disabled_value !== (textarea_disabled_value = /*status*/
      ctx2[2] === "streaming")) {
        textarea.disabled = textarea_disabled_value;
      }
      if (dirty[0] & /*userPrompt*/
      1) {
        set_input_value(
          textarea,
          /*userPrompt*/
          ctx2[0]
        );
      }
      if (dirty[0] & /*webSearchEnabled*/
      16 && svg0_class_value !== (svg0_class_value = /*webSearchEnabled*/
      ctx2[4] ? "opacity-20" : "")) {
        attr(svg0, "class", svg0_class_value);
      }
      if (
        /*webSearchEnabled*/
        ctx2[4]
      ) {
        if (if_block2) {
        } else {
          if_block2 = create_if_block(ctx2);
          if_block2.c();
          if_block2.m(div1, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (dirty[0] & /*webSearchEnabled*/
      16 && button0_class_value !== (button0_class_value = "relative mb-0.5 inline-flex h-9 w-9 items-center justify-center rounded-lg transition-all hover:bg-muted " + /*webSearchEnabled*/
      (ctx2[4] ? "text-primary bg-primary/10" : "text-muted-foreground/50"))) {
        attr(button0, "class", button0_class_value);
      }
      if (dirty[0] & /*webSearchEnabled*/
      16 && button0_title_value !== (button0_title_value = /*webSearchEnabled*/
      ctx2[4] ? "Disable Web Search" : "Enable Web Search")) {
        attr(button0, "title", button0_title_value);
      }
      if (dirty[0] & /*userPrompt, status*/
      5 && button1_disabled_value !== (button1_disabled_value = !/*userPrompt*/
      ctx2[0].trim() || /*status*/
      ctx2[2] === "streaming")) {
        button1.disabled = button1_disabled_value;
      }
    },
    i(local) {
      transition_in(if_block0);
      transition_in(if_block1);
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
    },
    d(detaching) {
      if (detaching) {
        detach(div5);
      }
      destroy_each(each_blocks, detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function stripThinkingTags(text2) {
  let cleaned = text2;
  cleaned = cleaned.replace(/<think>[\s\S]*?<\/think>/gi, "");
  cleaned = cleaned.replace(/<think>[\s\S]*?<think>/gi, "");
  cleaned = cleaned.replace(/<\/?think>/gi, "");
  cleaned = cleaned.replace(/<think[\s\S]*$/gi, "");
  return cleaned.trim();
}
function instance($$self, $$props, $$invalidate) {
  let displayResponse;
  let { plugin } = $$props;
  let { messages = [] } = $$props;
  let { currentResponse = "" } = $$props;
  let { status = "idle" } = $$props;
  let { userPrompt = "" } = $$props;
  let { activeCommandId = null } = $$props;
  const dispatch2 = createEventDispatcher();
  let { webSearchEnabled = false } = $$props;
  let { searchStatus = "" } = $$props;
  let { searchQueries = [] } = $$props;
  let { webSearchResults = void 0 } = $$props;
  function handleKeyDown(event) {
    if (event.key === "Enter" && !event.shiftKey) {
      event.preventDefault();
      if (userPrompt.trim() && (status === "idle" || status === "error")) {
        dispatch2("send");
      }
    }
  }
  function handleSend() {
    if (userPrompt.trim() && (status === "idle" || status === "error")) {
      dispatch2("send");
    }
  }
  function toggleWebSearch() {
    dispatch2("toggleWebSearch");
  }
  let copiedMessageIndex = null;
  let replacedMessageIndex = null;
  let createdNoteIndex = null;
  function handleCopy(text2, index) {
    navigator.clipboard.writeText(text2);
    $$invalidate(8, copiedMessageIndex = index);
    setTimeout(
      () => {
        $$invalidate(8, copiedMessageIndex = null);
      },
      1500
    );
  }
  function handleReplace(context, text2, index) {
    dispatch2("replace", { context, text: text2 });
    $$invalidate(9, replacedMessageIndex = index);
    setTimeout(
      () => {
        $$invalidate(9, replacedMessageIndex = null);
      },
      1500
    );
  }
  function handleCreateNote(text2, index) {
    dispatch2("createNote", { content: text2 });
    $$invalidate(10, createdNoteIndex = index);
    setTimeout(
      () => {
        $$invalidate(10, createdNoteIndex = null);
      },
      1500
    );
  }
  function cleanSourceTitleLinks(text2) {
    if (!(webSearchResults === null || webSearchResults === void 0 ? void 0 : webSearchResults.results))
      return text2;
    return text2.replace(/\[Source Title\]\(([^)]+)\)/gi, (match, url) => {
      const result = webSearchResults.results.find((r) => r.url === url || url.includes(r.url) || r.url.includes(url));
      if (result) {
        return `[${result.title}](${result.url})`;
      }
      try {
        const domain = new URL(url).hostname.replace("www.", "");
        return `[${domain}](${url})`;
      } catch (_a) {
        return match;
      }
    });
  }
  function cleanAssistantMessage(text2) {
    let cleaned = stripThinkingTags(text2);
    cleaned = cleanSourceTitleLinks(cleaned);
    return cleaned;
  }
  function markdown(node, text2) {
    if (!text2)
      return;
    node.empty();
    const component = new import_obsidian5.Component();
    import_obsidian5.MarkdownRenderer.render(plugin.app, text2, node, "", component);
    makeLinksClickable(node);
    return {
      update(newText) {
        node.empty();
        import_obsidian5.MarkdownRenderer.render(plugin.app, newText, node, "", component);
        makeLinksClickable(node);
      },
      destroy() {
        component.unload();
      }
    };
  }
  function makeLinksClickable(container) {
    const internalLinks = container.querySelectorAll("a.internal-link");
    internalLinks.forEach((link) => {
      const anchor = link;
      const href = anchor.getAttribute("href") || anchor.dataset.href || anchor.textContent || "";
      anchor.addEventListener("click", (evt) => {
        evt.preventDefault();
        plugin.app.workspace.openLinkText(href, "", false);
      });
    });
  }
  const click_handler = (message, index) => handleCopy(message.content, index);
  const click_handler_1 = (message, index) => handleReplace(message.context, message.content, index);
  const click_handler_2 = (message, index) => handleCreateNote(message.content, index);
  function textarea_input_handler() {
    userPrompt = this.value;
    $$invalidate(0, userPrompt);
  }
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(20, plugin = $$props2.plugin);
    if ("messages" in $$props2)
      $$invalidate(1, messages = $$props2.messages);
    if ("currentResponse" in $$props2)
      $$invalidate(21, currentResponse = $$props2.currentResponse);
    if ("status" in $$props2)
      $$invalidate(2, status = $$props2.status);
    if ("userPrompt" in $$props2)
      $$invalidate(0, userPrompt = $$props2.userPrompt);
    if ("activeCommandId" in $$props2)
      $$invalidate(3, activeCommandId = $$props2.activeCommandId);
    if ("webSearchEnabled" in $$props2)
      $$invalidate(4, webSearchEnabled = $$props2.webSearchEnabled);
    if ("searchStatus" in $$props2)
      $$invalidate(5, searchStatus = $$props2.searchStatus);
    if ("searchQueries" in $$props2)
      $$invalidate(6, searchQueries = $$props2.searchQueries);
    if ("webSearchResults" in $$props2)
      $$invalidate(7, webSearchResults = $$props2.webSearchResults);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*currentResponse*/
    2097152) {
      $:
        $$invalidate(11, displayResponse = cleanAssistantMessage(currentResponse));
    }
  };
  return [
    userPrompt,
    messages,
    status,
    activeCommandId,
    webSearchEnabled,
    searchStatus,
    searchQueries,
    webSearchResults,
    copiedMessageIndex,
    replacedMessageIndex,
    createdNoteIndex,
    displayResponse,
    handleKeyDown,
    handleSend,
    toggleWebSearch,
    handleCopy,
    handleReplace,
    handleCreateNote,
    cleanAssistantMessage,
    markdown,
    plugin,
    currentResponse,
    click_handler,
    click_handler_1,
    click_handler_2,
    textarea_input_handler
  ];
}
var ChatView = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        plugin: 20,
        messages: 1,
        currentResponse: 21,
        status: 2,
        userPrompt: 0,
        activeCommandId: 3,
        webSearchEnabled: 4,
        searchStatus: 5,
        searchQueries: 6,
        webSearchResults: 7
      },
      add_css,
      [-1, -1]
    );
  }
};
var ChatView_default = ChatView;

// src/ui/modelPicker.ts
var import_obsidian6 = require("obsidian");
var ModelPickerModal = class extends import_obsidian6.FuzzySuggestModal {
  constructor(app, models, onChoose) {
    super(app);
    this.models = models;
    this.onChoose = onChoose;
    this.setPlaceholder("Select a model...");
  }
  getItems() {
    return this.models;
  }
  getItemText(model) {
    return model.id;
  }
  onChooseItem(model, evt) {
    this.onChoose(model.id);
  }
};

// src/ui/svelte/SettingsDrawer.svelte
function create_if_block2(ctx) {
  let div12;
  let div0;
  let h2;
  let t1;
  let button0;
  let t2;
  let div11;
  let div3;
  let div2;
  let label0;
  let t4;
  let div1;
  let button1;
  let t5;
  let button1_class_value;
  let t6;
  let button2;
  let t7;
  let button2_class_value;
  let t8;
  let t9;
  let t10;
  let div9;
  let div8;
  let div4;
  let t14;
  let div7;
  let div5;
  let t15;
  let div6;
  let div6_class_value;
  let t16;
  let t17;
  let div10;
  let mounted;
  let dispose;
  let if_block0 = (
    /*settings*/
    ctx[1].activeProvider === "ollama" && create_if_block_52(ctx)
  );
  let if_block1 = (
    /*settings*/
    ctx[1].activeProvider === "openai" && create_if_block_22(ctx)
  );
  let if_block2 = (
    /*settings*/
    ctx[1].webSearch.enabled && create_if_block_16(ctx)
  );
  return {
    c() {
      div12 = element("div");
      div0 = element("div");
      h2 = element("h2");
      h2.textContent = "Settings";
      t1 = space();
      button0 = element("button");
      button0.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6 6 18"></path><path d="m6 6 12 12"></path></svg>`;
      t2 = space();
      div11 = element("div");
      div3 = element("div");
      div2 = element("div");
      label0 = element("label");
      label0.textContent = "Provider";
      t4 = space();
      div1 = element("div");
      button1 = element("button");
      t5 = text("Ollama");
      t6 = space();
      button2 = element("button");
      t7 = text("OpenAI");
      t8 = space();
      if (if_block0)
        if_block0.c();
      t9 = space();
      if (if_block1)
        if_block1.c();
      t10 = space();
      div9 = element("div");
      div8 = element("div");
      div4 = element("div");
      div4.innerHTML = `<label class="text-sm font-medium">Web Search</label> <p class="text-xs text-muted-foreground">Enhance responses with web data</p>`;
      t14 = space();
      div7 = element("div");
      div5 = element("div");
      t15 = space();
      div6 = element("div");
      t16 = space();
      if (if_block2)
        if_block2.c();
      t17 = space();
      div10 = element("div");
      div10.innerHTML = `<p class="text-[10px] text-muted-foreground/40 uppercase tracking-widest">AI Assistant v1.0</p>`;
      attr(h2, "class", "text-sm font-bold uppercase tracking-wider text-muted-foreground");
      attr(button0, "class", "inline-flex items-center justify-center rounded-md p-2 text-muted-foreground hover:bg-muted hover:text-foreground transition-colors");
      attr(button0, "aria-label", "Close");
      attr(div0, "class", "flex items-center justify-between p-4 border-b border-border bg-background/95 backdrop-blur z-10 shrink-0");
      attr(label0, "class", "text-sm font-medium");
      attr(button1, "class", button1_class_value = "flex-1 rounded-md px-2 py-1 text-xs font-medium transition-all " + /*settings*/
      (ctx[1].activeProvider === "ollama" ? "bg-background shadow-sm text-foreground" : "text-muted-foreground hover:text-foreground"));
      attr(button2, "class", button2_class_value = "flex-1 rounded-md px-2 py-1 text-xs font-medium transition-all " + /*settings*/
      (ctx[1].activeProvider === "openai" ? "bg-background shadow-sm text-foreground" : "text-muted-foreground hover:text-foreground"));
      attr(div1, "class", "relative inline-flex h-8 w-[140px] items-center rounded-lg bg-muted p-1");
      attr(div2, "class", "flex items-center justify-between");
      attr(div3, "class", "space-y-4");
      attr(div4, "class", "space-y-0.5");
      attr(div5, "class", "w-11 h-6 rounded-full transition-colors duration-200 ease-in-out");
      set_style(
        div5,
        "background-color",
        /*settings*/
        ctx[1].webSearch.enabled ? "var(--text-muted)" : "var(--background-modifier-border)"
      );
      attr(div6, "class", div6_class_value = "absolute top-[2px] left-[2px] bg-white rounded-full h-5 w-5 shadow-sm transition-transform duration-200 ease-in-out " + /*settings*/
      (ctx[1].webSearch.enabled ? "translate-x-[20px]" : "translate-x-0"));
      attr(div7, "class", "relative inline-flex items-center cursor-pointer");
      attr(div8, "class", "flex items-center justify-between");
      attr(div9, "class", "space-y-4 pt-4 border-t border-border");
      attr(div10, "class", "pt-8 pb-4 text-center");
      attr(div11, "class", "flex-1 overflow-y-auto p-4 space-y-8");
      attr(div12, "class", "absolute inset-0 z-50 flex flex-col animate-in slide-in-from-right duration-200");
      set_style(div12, "background-color", "var(--background-primary)");
      attr(div12, "role", "dialog");
      attr(div12, "aria-modal", "true");
    },
    m(target, anchor) {
      insert(target, div12, anchor);
      append(div12, div0);
      append(div0, h2);
      append(div0, t1);
      append(div0, button0);
      append(div12, t2);
      append(div12, div11);
      append(div11, div3);
      append(div3, div2);
      append(div2, label0);
      append(div2, t4);
      append(div2, div1);
      append(div1, button1);
      append(button1, t5);
      append(div1, t6);
      append(div1, button2);
      append(button2, t7);
      append(div3, t8);
      if (if_block0)
        if_block0.m(div3, null);
      append(div3, t9);
      if (if_block1)
        if_block1.m(div3, null);
      append(div11, t10);
      append(div11, div9);
      append(div9, div8);
      append(div8, div4);
      append(div8, t14);
      append(div8, div7);
      append(div7, div5);
      append(div7, t15);
      append(div7, div6);
      append(div9, t16);
      if (if_block2)
        if_block2.m(div9, null);
      append(div11, t17);
      append(div11, div10);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*handleClose*/
            ctx[4]
          ),
          listen(
            button1,
            "click",
            /*click_handler*/
            ctx[9]
          ),
          listen(
            button2,
            "click",
            /*click_handler_1*/
            ctx[10]
          ),
          listen(
            div7,
            "click",
            /*click_handler_4*/
            ctx[20]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*settings*/
      2 && button1_class_value !== (button1_class_value = "flex-1 rounded-md px-2 py-1 text-xs font-medium transition-all " + /*settings*/
      (ctx2[1].activeProvider === "ollama" ? "bg-background shadow-sm text-foreground" : "text-muted-foreground hover:text-foreground"))) {
        attr(button1, "class", button1_class_value);
      }
      if (dirty & /*settings*/
      2 && button2_class_value !== (button2_class_value = "flex-1 rounded-md px-2 py-1 text-xs font-medium transition-all " + /*settings*/
      (ctx2[1].activeProvider === "openai" ? "bg-background shadow-sm text-foreground" : "text-muted-foreground hover:text-foreground"))) {
        attr(button2, "class", button2_class_value);
      }
      if (
        /*settings*/
        ctx2[1].activeProvider === "ollama"
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_52(ctx2);
          if_block0.c();
          if_block0.m(div3, t9);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*settings*/
        ctx2[1].activeProvider === "openai"
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_22(ctx2);
          if_block1.c();
          if_block1.m(div3, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty & /*settings*/
      2) {
        set_style(
          div5,
          "background-color",
          /*settings*/
          ctx2[1].webSearch.enabled ? "var(--text-muted)" : "var(--background-modifier-border)"
        );
      }
      if (dirty & /*settings*/
      2 && div6_class_value !== (div6_class_value = "absolute top-[2px] left-[2px] bg-white rounded-full h-5 w-5 shadow-sm transition-transform duration-200 ease-in-out " + /*settings*/
      (ctx2[1].webSearch.enabled ? "translate-x-[20px]" : "translate-x-0"))) {
        attr(div6, "class", div6_class_value);
      }
      if (
        /*settings*/
        ctx2[1].webSearch.enabled
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_16(ctx2);
          if_block2.c();
          if_block2.m(div9, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div12);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_52(ctx) {
  var _a, _b;
  let div6;
  let div0;
  let label0;
  let t1;
  let input0;
  let input0_value_value;
  let t2;
  let div3;
  let div1;
  let t4;
  let t5;
  let div2;
  let input1;
  let input1_value_value;
  let t6;
  let button;
  let t7;
  let div5;
  let div4;
  let label2;
  let t9;
  let span;
  let t10_value = (
    /*settings*/
    (((_b = (_a = ctx[1].providers.ollama) == null ? void 0 : _a.temperature) == null ? void 0 : _b.toFixed(1)) || "0.7") + ""
  );
  let t10;
  let t11;
  let input2;
  let input2_value_value;
  let mounted;
  let dispose;
  let if_block0 = (
    /*fetchError*/
    ctx[3] && /*settings*/
    ctx[1].activeProvider === "ollama" && create_if_block_72(ctx)
  );
  function select_block_type(ctx2, dirty) {
    if (
      /*isFetching*/
      ctx2[2] && /*settings*/
      ctx2[1].activeProvider === "ollama"
    )
      return create_if_block_62;
    return create_else_block_12;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block1 = current_block_type(ctx);
  return {
    c() {
      var _a2, _b2, _c;
      div6 = element("div");
      div0 = element("div");
      label0 = element("label");
      label0.textContent = "Base URL";
      t1 = space();
      input0 = element("input");
      t2 = space();
      div3 = element("div");
      div1 = element("div");
      div1.innerHTML = `<label class="text-xs font-medium text-muted-foreground">Model Name</label>`;
      t4 = space();
      if (if_block0)
        if_block0.c();
      t5 = space();
      div2 = element("div");
      input1 = element("input");
      t6 = space();
      button = element("button");
      if_block1.c();
      t7 = space();
      div5 = element("div");
      div4 = element("div");
      label2 = element("label");
      label2.textContent = "Temperature";
      t9 = space();
      span = element("span");
      t10 = text(t10_value);
      t11 = space();
      input2 = element("input");
      attr(label0, "class", "text-xs font-medium text-muted-foreground");
      attr(input0, "type", "text");
      input0.value = input0_value_value = /*settings*/
      ((_a2 = ctx[1].providers.ollama) == null ? void 0 : _a2.baseUrl) || "";
      attr(input0, "class", "flex w-full rounded-md border border-input bg-background/50 px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:border-transparent transition-all");
      attr(input0, "placeholder", "http://localhost:11434");
      attr(div0, "class", "space-y-1.5");
      attr(div1, "class", "flex items-center justify-between");
      attr(input1, "type", "text");
      input1.value = input1_value_value = /*settings*/
      ((_b2 = ctx[1].providers.ollama) == null ? void 0 : _b2.model) || "";
      attr(input1, "class", "flex-1 rounded-md border border-input bg-background/50 px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:border-transparent transition-all");
      attr(input1, "placeholder", "llama2");
      attr(button, "class", "p-2 h-9 w-9 inline-flex items-center justify-center rounded-md border border-input hover:bg-muted text-muted-foreground hover:text-foreground transition-colors disabled:opacity-50");
      attr(button, "title", "Fetch and select model...");
      button.disabled = /*isFetching*/
      ctx[2];
      attr(div2, "class", "flex gap-2");
      attr(div3, "class", "space-y-1.5");
      attr(label2, "class", "text-xs font-medium text-muted-foreground");
      attr(span, "class", "text-xs text-muted-foreground font-mono bg-muted/50 px-1.5 py-0.5 rounded");
      attr(div4, "class", "flex items-center justify-between");
      attr(input2, "type", "range");
      attr(input2, "min", "0");
      attr(input2, "max", "2");
      attr(input2, "step", "0.1");
      input2.value = input2_value_value = /*settings*/
      ((_c = ctx[1].providers.ollama) == null ? void 0 : _c.temperature) || 0.7;
      attr(input2, "class", "styled-slider");
      attr(div5, "class", "space-y-3 pt-2");
      attr(div6, "class", "space-y-4 pt-2 animate-in fade-in slide-in-from-top-2 duration-200");
    },
    m(target, anchor) {
      insert(target, div6, anchor);
      append(div6, div0);
      append(div0, label0);
      append(div0, t1);
      append(div0, input0);
      append(div6, t2);
      append(div6, div3);
      append(div3, div1);
      append(div3, t4);
      if (if_block0)
        if_block0.m(div3, null);
      append(div3, t5);
      append(div3, div2);
      append(div2, input1);
      append(div2, t6);
      append(div2, button);
      if_block1.m(button, null);
      append(div6, t7);
      append(div6, div5);
      append(div5, div4);
      append(div4, label2);
      append(div4, t9);
      append(div4, span);
      append(span, t10);
      append(div5, t11);
      append(div5, input2);
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input_handler*/
            ctx[11]
          ),
          listen(
            input1,
            "input",
            /*input_handler_1*/
            ctx[12]
          ),
          listen(
            button,
            "click",
            /*click_handler_2*/
            ctx[13]
          ),
          listen(
            input2,
            "input",
            /*input_handler_2*/
            ctx[14]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      var _a2, _b2, _c, _d, _e;
      if (dirty & /*settings*/
      2 && input0_value_value !== (input0_value_value = /*settings*/
      ((_a2 = ctx2[1].providers.ollama) == null ? void 0 : _a2.baseUrl) || "") && input0.value !== input0_value_value) {
        input0.value = input0_value_value;
      }
      if (
        /*fetchError*/
        ctx2[3] && /*settings*/
        ctx2[1].activeProvider === "ollama"
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_72(ctx2);
          if_block0.c();
          if_block0.m(div3, t5);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty & /*settings*/
      2 && input1_value_value !== (input1_value_value = /*settings*/
      ((_b2 = ctx2[1].providers.ollama) == null ? void 0 : _b2.model) || "") && input1.value !== input1_value_value) {
        input1.value = input1_value_value;
      }
      if (current_block_type !== (current_block_type = select_block_type(ctx2, dirty))) {
        if_block1.d(1);
        if_block1 = current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(button, null);
        }
      }
      if (dirty & /*isFetching*/
      4) {
        button.disabled = /*isFetching*/
        ctx2[2];
      }
      if (dirty & /*settings*/
      2 && t10_value !== (t10_value = /*settings*/
      (((_d = (_c = ctx2[1].providers.ollama) == null ? void 0 : _c.temperature) == null ? void 0 : _d.toFixed(1)) || "0.7") + ""))
        set_data(t10, t10_value);
      if (dirty & /*settings*/
      2 && input2_value_value !== (input2_value_value = /*settings*/
      ((_e = ctx2[1].providers.ollama) == null ? void 0 : _e.temperature) || 0.7)) {
        input2.value = input2_value_value;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div6);
      }
      if (if_block0)
        if_block0.d();
      if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_72(ctx) {
  let div;
  let t0;
  let t1;
  return {
    c() {
      div = element("div");
      t0 = text("Connection failed: ");
      t1 = text(
        /*fetchError*/
        ctx[3]
      );
      attr(div, "class", "p-2 rounded bg-destructive/10 text-destructive text-[10px] mb-2 animate-in fade-in slide-in-from-top-1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*fetchError*/
      8)
        set_data(
          t1,
          /*fetchError*/
          ctx2[3]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_else_block_12(ctx) {
  let svg;
  let line0;
  let line1;
  let line2;
  let line3;
  let line4;
  let line5;
  return {
    c() {
      svg = svg_element("svg");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      line3 = svg_element("line");
      line4 = svg_element("line");
      line5 = svg_element("line");
      attr(line0, "x1", "8");
      attr(line0, "y1", "6");
      attr(line0, "x2", "21");
      attr(line0, "y2", "6");
      attr(line1, "x1", "8");
      attr(line1, "y1", "12");
      attr(line1, "x2", "21");
      attr(line1, "y2", "12");
      attr(line2, "x1", "8");
      attr(line2, "y1", "18");
      attr(line2, "x2", "21");
      attr(line2, "y2", "18");
      attr(line3, "x1", "3");
      attr(line3, "y1", "6");
      attr(line3, "x2", "3.01");
      attr(line3, "y2", "6");
      attr(line4, "x1", "3");
      attr(line4, "y1", "12");
      attr(line4, "x2", "3.01");
      attr(line4, "y2", "12");
      attr(line5, "x1", "3");
      attr(line5, "y1", "18");
      attr(line5, "x2", "3.01");
      attr(line5, "y2", "18");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "16");
      attr(svg, "height", "16");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, line0);
      append(svg, line1);
      append(svg, line2);
      append(svg, line3);
      append(svg, line4);
      append(svg, line5);
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_if_block_62(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "h-4 w-4 animate-spin rounded-full border-2 border-current border-t-transparent");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block_22(ctx) {
  var _a, _b;
  let div7;
  let div0;
  let label0;
  let t1;
  let input0;
  let input0_value_value;
  let t2;
  let div1;
  let label1;
  let t4;
  let input1;
  let input1_value_value;
  let t5;
  let div4;
  let div2;
  let t7;
  let t8;
  let div3;
  let input2;
  let input2_value_value;
  let t9;
  let button;
  let t10;
  let div6;
  let div5;
  let label3;
  let t12;
  let span;
  let t13_value = (
    /*settings*/
    (((_b = (_a = ctx[1].providers.openai) == null ? void 0 : _a.temperature) == null ? void 0 : _b.toFixed(1)) || "0.7") + ""
  );
  let t13;
  let t14;
  let input3;
  let input3_value_value;
  let mounted;
  let dispose;
  let if_block0 = (
    /*fetchError*/
    ctx[3] && /*settings*/
    ctx[1].activeProvider === "openai" && create_if_block_42(ctx)
  );
  function select_block_type_1(ctx2, dirty) {
    if (
      /*isFetching*/
      ctx2[2] && /*settings*/
      ctx2[1].activeProvider === "openai"
    )
      return create_if_block_32;
    return create_else_block2;
  }
  let current_block_type = select_block_type_1(ctx, -1);
  let if_block1 = current_block_type(ctx);
  return {
    c() {
      var _a2, _b2, _c, _d;
      div7 = element("div");
      div0 = element("div");
      label0 = element("label");
      label0.textContent = "API Key";
      t1 = space();
      input0 = element("input");
      t2 = space();
      div1 = element("div");
      label1 = element("label");
      label1.textContent = "Base URL";
      t4 = space();
      input1 = element("input");
      t5 = space();
      div4 = element("div");
      div2 = element("div");
      div2.innerHTML = `<label class="text-xs font-medium text-muted-foreground">Model Name</label>`;
      t7 = space();
      if (if_block0)
        if_block0.c();
      t8 = space();
      div3 = element("div");
      input2 = element("input");
      t9 = space();
      button = element("button");
      if_block1.c();
      t10 = space();
      div6 = element("div");
      div5 = element("div");
      label3 = element("label");
      label3.textContent = "Temperature";
      t12 = space();
      span = element("span");
      t13 = text(t13_value);
      t14 = space();
      input3 = element("input");
      attr(label0, "class", "text-xs font-medium text-muted-foreground");
      attr(input0, "type", "password");
      input0.value = input0_value_value = /*settings*/
      ((_a2 = ctx[1].providers.openai) == null ? void 0 : _a2.apiKey) || "";
      attr(input0, "class", "flex w-full rounded-md border border-input bg-background/50 px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:border-transparent transition-all");
      attr(input0, "placeholder", "sk-...");
      attr(div0, "class", "space-y-1.5");
      attr(label1, "class", "text-xs font-medium text-muted-foreground");
      attr(input1, "type", "text");
      input1.value = input1_value_value = /*settings*/
      ((_b2 = ctx[1].providers.openai) == null ? void 0 : _b2.baseUrl) || "";
      attr(input1, "class", "flex w-full rounded-md border border-input bg-background/50 px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:border-transparent transition-all");
      attr(input1, "placeholder", "https://api.openai.com/v1");
      attr(div1, "class", "space-y-1.5");
      attr(div2, "class", "flex items-center justify-between");
      attr(input2, "type", "text");
      input2.value = input2_value_value = /*settings*/
      ((_c = ctx[1].providers.openai) == null ? void 0 : _c.model) || "";
      attr(input2, "class", "flex-1 rounded-md border border-input bg-background/50 px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:border-transparent transition-all");
      attr(input2, "placeholder", "gpt-4");
      attr(button, "class", "p-2 h-9 w-9 inline-flex items-center justify-center rounded-md border border-input hover:bg-muted text-muted-foreground hover:text-foreground transition-colors disabled:opacity-50");
      attr(button, "title", "Fetch and select model...");
      button.disabled = /*isFetching*/
      ctx[2];
      attr(div3, "class", "flex gap-2");
      attr(div4, "class", "space-y-1.5");
      attr(label3, "class", "text-xs font-medium text-muted-foreground");
      attr(span, "class", "text-xs text-muted-foreground font-mono bg-muted/50 px-1.5 py-0.5 rounded");
      attr(div5, "class", "flex items-center justify-between");
      attr(input3, "type", "range");
      attr(input3, "min", "0");
      attr(input3, "max", "2");
      attr(input3, "step", "0.1");
      input3.value = input3_value_value = /*settings*/
      ((_d = ctx[1].providers.openai) == null ? void 0 : _d.temperature) || 0.7;
      attr(input3, "class", "styled-slider");
      attr(div6, "class", "space-y-3 pt-2");
      attr(div7, "class", "space-y-4 pt-2 animate-in fade-in slide-in-from-top-2 duration-200");
    },
    m(target, anchor) {
      insert(target, div7, anchor);
      append(div7, div0);
      append(div0, label0);
      append(div0, t1);
      append(div0, input0);
      append(div7, t2);
      append(div7, div1);
      append(div1, label1);
      append(div1, t4);
      append(div1, input1);
      append(div7, t5);
      append(div7, div4);
      append(div4, div2);
      append(div4, t7);
      if (if_block0)
        if_block0.m(div4, null);
      append(div4, t8);
      append(div4, div3);
      append(div3, input2);
      append(div3, t9);
      append(div3, button);
      if_block1.m(button, null);
      append(div7, t10);
      append(div7, div6);
      append(div6, div5);
      append(div5, label3);
      append(div5, t12);
      append(div5, span);
      append(span, t13);
      append(div6, t14);
      append(div6, input3);
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input_handler_3*/
            ctx[15]
          ),
          listen(
            input1,
            "input",
            /*input_handler_4*/
            ctx[16]
          ),
          listen(
            input2,
            "input",
            /*input_handler_5*/
            ctx[17]
          ),
          listen(
            button,
            "click",
            /*click_handler_3*/
            ctx[18]
          ),
          listen(
            input3,
            "input",
            /*input_handler_6*/
            ctx[19]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      var _a2, _b2, _c, _d, _e, _f;
      if (dirty & /*settings*/
      2 && input0_value_value !== (input0_value_value = /*settings*/
      ((_a2 = ctx2[1].providers.openai) == null ? void 0 : _a2.apiKey) || "") && input0.value !== input0_value_value) {
        input0.value = input0_value_value;
      }
      if (dirty & /*settings*/
      2 && input1_value_value !== (input1_value_value = /*settings*/
      ((_b2 = ctx2[1].providers.openai) == null ? void 0 : _b2.baseUrl) || "") && input1.value !== input1_value_value) {
        input1.value = input1_value_value;
      }
      if (
        /*fetchError*/
        ctx2[3] && /*settings*/
        ctx2[1].activeProvider === "openai"
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_42(ctx2);
          if_block0.c();
          if_block0.m(div4, t8);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty & /*settings*/
      2 && input2_value_value !== (input2_value_value = /*settings*/
      ((_c = ctx2[1].providers.openai) == null ? void 0 : _c.model) || "") && input2.value !== input2_value_value) {
        input2.value = input2_value_value;
      }
      if (current_block_type !== (current_block_type = select_block_type_1(ctx2, dirty))) {
        if_block1.d(1);
        if_block1 = current_block_type(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(button, null);
        }
      }
      if (dirty & /*isFetching*/
      4) {
        button.disabled = /*isFetching*/
        ctx2[2];
      }
      if (dirty & /*settings*/
      2 && t13_value !== (t13_value = /*settings*/
      (((_e = (_d = ctx2[1].providers.openai) == null ? void 0 : _d.temperature) == null ? void 0 : _e.toFixed(1)) || "0.7") + ""))
        set_data(t13, t13_value);
      if (dirty & /*settings*/
      2 && input3_value_value !== (input3_value_value = /*settings*/
      ((_f = ctx2[1].providers.openai) == null ? void 0 : _f.temperature) || 0.7)) {
        input3.value = input3_value_value;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div7);
      }
      if (if_block0)
        if_block0.d();
      if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_42(ctx) {
  let div;
  let t0;
  let t1;
  return {
    c() {
      div = element("div");
      t0 = text("Connection failed: ");
      t1 = text(
        /*fetchError*/
        ctx[3]
      );
      attr(div, "class", "p-2 rounded bg-destructive/10 text-destructive text-[10px] mb-2 animate-in fade-in slide-in-from-top-1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t0);
      append(div, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*fetchError*/
      8)
        set_data(
          t1,
          /*fetchError*/
          ctx2[3]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_else_block2(ctx) {
  let svg;
  let line0;
  let line1;
  let line2;
  let line3;
  let line4;
  let line5;
  return {
    c() {
      svg = svg_element("svg");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      line3 = svg_element("line");
      line4 = svg_element("line");
      line5 = svg_element("line");
      attr(line0, "x1", "8");
      attr(line0, "y1", "6");
      attr(line0, "x2", "21");
      attr(line0, "y2", "6");
      attr(line1, "x1", "8");
      attr(line1, "y1", "12");
      attr(line1, "x2", "21");
      attr(line1, "y2", "12");
      attr(line2, "x1", "8");
      attr(line2, "y1", "18");
      attr(line2, "x2", "21");
      attr(line2, "y2", "18");
      attr(line3, "x1", "3");
      attr(line3, "y1", "6");
      attr(line3, "x2", "3.01");
      attr(line3, "y2", "6");
      attr(line4, "x1", "3");
      attr(line4, "y1", "12");
      attr(line4, "x2", "3.01");
      attr(line4, "y2", "12");
      attr(line5, "x1", "3");
      attr(line5, "y1", "18");
      attr(line5, "x2", "3.01");
      attr(line5, "y2", "18");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "16");
      attr(svg, "height", "16");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, line0);
      append(svg, line1);
      append(svg, line2);
      append(svg, line3);
      append(svg, line4);
      append(svg, line5);
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_if_block_32(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "h-4 w-4 animate-spin rounded-full border-2 border-current border-t-transparent");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block_16(ctx) {
  let div;
  let label;
  let t1;
  let input;
  let t2;
  let p;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      label = element("label");
      label.textContent = "SearXNG URL";
      t1 = space();
      input = element("input");
      t2 = space();
      p = element("p");
      p.innerHTML = `Use <code class="bg-muted px-1 py-0.5 rounded text-foreground">%s</code> as a placeholder for the query.`;
      attr(label, "class", "text-xs font-medium text-muted-foreground");
      attr(input, "type", "text");
      attr(input, "class", "flex w-full rounded-md border border-input bg-background/50 px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:border-transparent transition-all");
      attr(input, "placeholder", "http://host:port/search?q=%s&language=a");
      attr(p, "class", "text-[10px] text-muted-foreground");
      attr(div, "class", "space-y-1.5 animate-in fade-in slide-in-from-top-1 duration-200");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, label);
      append(div, t1);
      append(div, input);
      set_input_value(
        input,
        /*settings*/
        ctx[1].webSearch.urlTemplate
      );
      append(div, t2);
      append(div, p);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[21]
          ),
          listen(
            input,
            "input",
            /*input_handler_7*/
            ctx[22]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*settings*/
      2 && input.value !== /*settings*/
      ctx2[1].webSearch.urlTemplate) {
        set_input_value(
          input,
          /*settings*/
          ctx2[1].webSearch.urlTemplate
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment2(ctx) {
  let if_block_anchor;
  let if_block = (
    /*open*/
    ctx[0] && create_if_block2(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*open*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { open = false } = $$props;
  let { plugin } = $$props;
  let settings = plugin.settings;
  let availableModels = [];
  let isFetching = false;
  let fetchError = null;
  function handleClose() {
    $$invalidate(0, open = false);
  }
  async function openModelSelector(provider) {
    if (isFetching)
      return;
    await fetchModels(provider);
    if (availableModels.length > 0) {
      new ModelPickerModal(
        plugin.app,
        availableModels,
        (modelId) => {
          updateProviderSetting(provider, "model", modelId);
        }
      ).open();
    }
  }
  async function updateSetting(key, value) {
    if (key === "activeProvider" && value !== settings.activeProvider) {
      availableModels = [];
      $$invalidate(3, fetchError = null);
    }
    $$invalidate(1, settings[key] = value, settings);
    await plugin.saveSettings();
  }
  async function updateProviderSetting(provider, key, value) {
    if (!settings.providers[provider]) {
      $$invalidate(1, settings.providers[provider] = {}, settings);
    }
    $$invalidate(1, settings.providers[provider][key] = value, settings);
    await plugin.saveSettings();
  }
  async function fetchModels(provider) {
    $$invalidate(2, isFetching = true);
    $$invalidate(3, fetchError = null);
    availableModels = [];
    try {
      const providerSettings = settings.providers[provider];
      if (!providerSettings) {
        throw new Error("Provider settings not initialized");
      }
      if (provider === "ollama" && !providerSettings.baseUrl) {
        providerSettings.baseUrl = "http://localhost:11434";
      }
      const client = createProviderClient(provider, providerSettings);
      availableModels = await client.listModels();
      if (availableModels.length === 0) {
        $$invalidate(3, fetchError = "No models found or connection failed");
      }
    } catch (e) {
      $$invalidate(3, fetchError = e.message || "Failed to fetch models");
    } finally {
      $$invalidate(2, isFetching = false);
    }
  }
  const click_handler = () => updateSetting("activeProvider", "ollama");
  const click_handler_1 = () => updateSetting("activeProvider", "openai");
  const input_handler = (e) => updateProviderSetting("ollama", "baseUrl", e.currentTarget.value);
  const input_handler_1 = (e) => updateProviderSetting("ollama", "model", e.currentTarget.value);
  const click_handler_2 = () => openModelSelector("ollama");
  const input_handler_2 = (e) => updateProviderSetting("ollama", "temperature", parseFloat(e.currentTarget.value));
  const input_handler_3 = (e) => updateProviderSetting("openai", "apiKey", e.currentTarget.value);
  const input_handler_4 = (e) => updateProviderSetting("openai", "baseUrl", e.currentTarget.value);
  const input_handler_5 = (e) => updateProviderSetting("openai", "model", e.currentTarget.value);
  const click_handler_3 = () => openModelSelector("openai");
  const input_handler_6 = (e) => updateProviderSetting("openai", "temperature", parseFloat(e.currentTarget.value));
  const click_handler_4 = () => {
    $$invalidate(1, settings.webSearch.enabled = !settings.webSearch.enabled, settings);
    $$invalidate(1, settings);
    updateSetting("webSearch", settings.webSearch);
  };
  function input_input_handler() {
    settings.webSearch.urlTemplate = this.value;
    $$invalidate(1, settings);
  }
  const input_handler_7 = () => updateSetting("webSearch", settings.webSearch);
  $$self.$$set = ($$props2) => {
    if ("open" in $$props2)
      $$invalidate(0, open = $$props2.open);
    if ("plugin" in $$props2)
      $$invalidate(8, plugin = $$props2.plugin);
  };
  return [
    open,
    settings,
    isFetching,
    fetchError,
    handleClose,
    openModelSelector,
    updateSetting,
    updateProviderSetting,
    plugin,
    click_handler,
    click_handler_1,
    input_handler,
    input_handler_1,
    click_handler_2,
    input_handler_2,
    input_handler_3,
    input_handler_4,
    input_handler_5,
    click_handler_3,
    input_handler_6,
    click_handler_4,
    input_input_handler,
    input_handler_7
  ];
}
var SettingsDrawer = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, { open: 0, plugin: 8 });
  }
};
var SettingsDrawer_default = SettingsDrawer;

// src/ui/svelte/App.svelte
function create_if_block_33(ctx) {
  let button;
  let button_class_value;
  let button_title_value;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*conversationSaved*/
      ctx2[11]
    )
      return create_if_block_43;
    return create_else_block3;
  }
  let current_block_type = select_block_type(ctx, [-1, -1]);
  let if_block = current_block_type(ctx);
  return {
    c() {
      button = element("button");
      if_block.c();
      attr(button, "class", button_class_value = "inline-flex items-center justify-center rounded-md hover:bg-accent hover:text-accent-foreground h-9 w-9 transition-colors " + /*conversationSaved*/
      (ctx[11] ? "text-primary" : ""));
      attr(button, "title", button_title_value = /*conversationSaved*/
      ctx[11] ? "Note created!" : "Save conversation as note");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if_block.m(button, null);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*handleSaveConversation*/
          ctx[22]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (current_block_type !== (current_block_type = select_block_type(ctx2, dirty))) {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(button, null);
        }
      }
      if (dirty[0] & /*conversationSaved*/
      2048 && button_class_value !== (button_class_value = "inline-flex items-center justify-center rounded-md hover:bg-accent hover:text-accent-foreground h-9 w-9 transition-colors " + /*conversationSaved*/
      (ctx2[11] ? "text-primary" : ""))) {
        attr(button, "class", button_class_value);
      }
      if (dirty[0] & /*conversationSaved*/
      2048 && button_title_value !== (button_title_value = /*conversationSaved*/
      ctx2[11] ? "Note created!" : "Save conversation as note")) {
        attr(button, "title", button_title_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_else_block3(ctx) {
  let svg;
  let path;
  let polyline;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      polyline = svg_element("polyline");
      attr(path, "d", "M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z");
      attr(polyline, "points", "14 2 14 8 20 8");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "16");
      attr(svg, "height", "16");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
      append(svg, polyline);
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_if_block_43(ctx) {
  let svg;
  let polyline;
  return {
    c() {
      svg = svg_element("svg");
      polyline = svg_element("polyline");
      attr(polyline, "points", "20 6 9 17 4 12");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "width", "16");
      attr(svg, "height", "16");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "fill", "none");
      attr(svg, "stroke", "currentColor");
      attr(svg, "stroke-width", "2");
      attr(svg, "stroke-linecap", "round");
      attr(svg, "stroke-linejoin", "round");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, polyline);
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_if_block_23(ctx) {
  let button0;
  let t;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      button0 = element("button");
      button0.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14"></path><path d="M5 12h14"></path></svg>`;
      t = space();
      button1 = element("button");
      button1.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"></path><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>`;
      attr(button0, "class", "inline-flex items-center justify-center rounded-md hover:bg-accent hover:text-accent-foreground h-9 w-9 transition-colors");
      attr(button0, "title", "New Chat");
      attr(button1, "class", "inline-flex items-center justify-center rounded-md hover:bg-destructive/80 hover:text-destructive-foreground h-9 w-9 transition-colors text-muted-foreground");
      attr(button1, "title", "Clear History");
    },
    m(target, anchor) {
      insert(target, button0, anchor);
      insert(target, t, anchor);
      insert(target, button1, anchor);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*handleReset*/
            ctx[17]
          ),
          listen(
            button1,
            "click",
            /*handleClearHistory*/
            ctx[18]
          )
        ];
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(button0);
        detach(t);
        detach(button1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_17(ctx) {
  let div1;
  let div0;
  let t0;
  let t1;
  let button;
  let div1_transition;
  let current;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t0 = text(
        /*error*/
        ctx[7]
      );
      t1 = space();
      button = element("button");
      button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`;
      attr(div0, "class", "flex-1 break-words font-medium");
      attr(button, "class", "rounded-md p-1 h-fit transition-colors hover:opacity-80");
      attr(button, "title", "Dismiss");
      attr(div1, "class", "absolute top-4 left-4 right-4 z-50 p-3 rounded-md shadow-md flex justify-between gap-2 backdrop-blur-sm");
      set_style(div1, "background-color", "var(--background-modifier-error)");
      set_style(div1, "color", "var(--text-on-accent)");
      set_style(div1, "border", "1px solid var(--text-error)");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, t0);
      append(div1, t1);
      append(div1, button);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_1*/
          ctx[26]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty[0] & /*error*/
      128)
        set_data(
          t0,
          /*error*/
          ctx2[7]
        );
    },
    i(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div1_transition)
            div1_transition = create_bidirectional_transition(div1, slide, {}, true);
          div1_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      if (local) {
        if (!div1_transition)
          div1_transition = create_bidirectional_transition(div1, slide, {}, false);
        div1_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (detaching && div1_transition)
        div1_transition.end();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block3(ctx) {
  let div;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      button = element("button");
      button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect></svg>
                    Stop Generating`;
      attr(button, "class", "shadow-lg inline-flex items-center justify-center gap-2 rounded-full text-xs font-semibold bg-destructive/90 hover:bg-destructive text-destructive-foreground h-8 px-4 py-1 transition-all backdrop-blur");
      attr(div, "class", "absolute bottom-24 left-1/2 -translate-x-1/2 z-10");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, button);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*handleStopGeneration*/
          ctx[16]
        );
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment3(ctx) {
  let div4;
  let div2;
  let div1;
  let button0;
  let span0;
  let t1;
  let span1;
  let t2_value = (
    /*activeCommand*/
    (ctx[13] ? (
      /*activeCommand*/
      ctx[13].title
    ) : "Pick a command...") + ""
  );
  let t2;
  let t3;
  let span2;
  let t5;
  let div0;
  let t6;
  let t7;
  let button1;
  let t8;
  let div3;
  let t9;
  let chatview;
  let updating_userPrompt;
  let t10;
  let t11;
  let settingsdrawer;
  let updating_open;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*messages*/
    ctx[4].length > 0 && /*activeCommandId*/
    ctx[1] === "research_create_note" && create_if_block_33(ctx)
  );
  let if_block1 = (
    /*messages*/
    ctx[4].length > 0 && create_if_block_23(ctx)
  );
  let if_block2 = (
    /*error*/
    ctx[7] && create_if_block_17(ctx)
  );
  function chatview_userPrompt_binding(value) {
    ctx[27](value);
  }
  let chatview_props = {
    plugin: (
      /*plugin*/
      ctx[0]
    ),
    messages: (
      /*messages*/
      ctx[4]
    ),
    currentResponse: (
      /*currentResponse*/
      ctx[5]
    ),
    status: (
      /*status*/
      ctx[2]
    ),
    webSearchEnabled: (
      /*webSearchEnabled*/
      ctx[12]
    ),
    searchStatus: (
      /*searchStatus*/
      ctx[8]
    ),
    searchQueries: (
      /*searchQueries*/
      ctx[9]
    ),
    webSearchResults: (
      /*webSearchResults*/
      ctx[10]
    ),
    activeCommandId: (
      /*activeCommandId*/
      ctx[1]
    )
  };
  if (
    /*userPrompt*/
    ctx[6] !== void 0
  ) {
    chatview_props.userPrompt = /*userPrompt*/
    ctx[6];
  }
  chatview = new ChatView_default({ props: chatview_props });
  binding_callbacks.push(() => bind(chatview, "userPrompt", chatview_userPrompt_binding));
  chatview.$on(
    "send",
    /*handleSendMessage*/
    ctx[15]
  );
  chatview.$on(
    "replace",
    /*handleReplace*/
    ctx[19]
  );
  chatview.$on(
    "toggleWebSearch",
    /*handleToggleWebSearch*/
    ctx[14]
  );
  chatview.$on(
    "createNote",
    /*handleCreateNote*/
    ctx[20]
  );
  let if_block3 = (
    /*status*/
    ctx[2] === "streaming" && create_if_block3(ctx)
  );
  function settingsdrawer_open_binding(value) {
    ctx[28](value);
  }
  let settingsdrawer_props = { plugin: (
    /*plugin*/
    ctx[0]
  ) };
  if (
    /*settingsOpen*/
    ctx[3] !== void 0
  ) {
    settingsdrawer_props.open = /*settingsOpen*/
    ctx[3];
  }
  settingsdrawer = new SettingsDrawer_default({ props: settingsdrawer_props });
  binding_callbacks.push(() => bind(settingsdrawer, "open", settingsdrawer_open_binding));
  return {
    c() {
      div4 = element("div");
      div2 = element("div");
      div1 = element("div");
      button0 = element("button");
      span0 = element("span");
      span0.textContent = "\u2728";
      t1 = space();
      span1 = element("span");
      t2 = text(t2_value);
      t3 = space();
      span2 = element("span");
      span2.textContent = "\u25BC";
      t5 = space();
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t6 = space();
      if (if_block1)
        if_block1.c();
      t7 = space();
      button1 = element("button");
      button1.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.38a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-1.72v-.51a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"></path><circle cx="12" cy="12" r="3"></circle></svg>`;
      t8 = space();
      div3 = element("div");
      if (if_block2)
        if_block2.c();
      t9 = space();
      create_component(chatview.$$.fragment);
      t10 = space();
      if (if_block3)
        if_block3.c();
      t11 = space();
      create_component(settingsdrawer.$$.fragment);
      attr(span0, "class", "text-primary");
      attr(span1, "class", "truncate block flex-1");
      attr(span2, "class", "text-xs opacity-50");
      attr(button0, "class", "flex-1 inline-flex items-center justify-start gap-2 rounded-lg bg-muted/50 hover:bg-muted text-sm font-medium h-9 px-3 text-muted-foreground transition-colors text-left");
      attr(button1, "class", "inline-flex items-center justify-center rounded-md hover:bg-accent hover:text-accent-foreground h-9 w-9 transition-colors");
      attr(button1, "title", "Settings");
      attr(div0, "class", "flex items-center gap-1");
      attr(div1, "class", "flex items-center gap-2 p-2");
      attr(div2, "class", "flex flex-col border-b border-border bg-background/95 backdrop-blur z-20");
      attr(div3, "class", "flex-1 overflow-hidden relative");
      attr(div4, "class", "h-full flex flex-col bg-background text-foreground relative overflow-hidden");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div2);
      append(div2, div1);
      append(div1, button0);
      append(button0, span0);
      append(button0, t1);
      append(button0, span1);
      append(span1, t2);
      append(button0, t3);
      append(button0, span2);
      append(div1, t5);
      append(div1, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append(div0, t6);
      if (if_block1)
        if_block1.m(div0, null);
      append(div0, t7);
      append(div0, button1);
      append(div4, t8);
      append(div4, div3);
      if (if_block2)
        if_block2.m(div3, null);
      append(div3, t9);
      mount_component(chatview, div3, null);
      append(div3, t10);
      if (if_block3)
        if_block3.m(div3, null);
      append(div4, t11);
      mount_component(settingsdrawer, div4, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*openCommandPicker*/
            ctx[21]
          ),
          listen(
            button1,
            "click",
            /*click_handler*/
            ctx[25]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*activeCommand*/
      8192) && t2_value !== (t2_value = /*activeCommand*/
      (ctx2[13] ? (
        /*activeCommand*/
        ctx2[13].title
      ) : "Pick a command...") + ""))
        set_data(t2, t2_value);
      if (
        /*messages*/
        ctx2[4].length > 0 && /*activeCommandId*/
        ctx2[1] === "research_create_note"
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_33(ctx2);
          if_block0.c();
          if_block0.m(div0, t6);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*messages*/
        ctx2[4].length > 0
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_23(ctx2);
          if_block1.c();
          if_block1.m(div0, t7);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*error*/
        ctx2[7]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*error*/
          128) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_17(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div3, t9);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      const chatview_changes = {};
      if (dirty[0] & /*plugin*/
      1)
        chatview_changes.plugin = /*plugin*/
        ctx2[0];
      if (dirty[0] & /*messages*/
      16)
        chatview_changes.messages = /*messages*/
        ctx2[4];
      if (dirty[0] & /*currentResponse*/
      32)
        chatview_changes.currentResponse = /*currentResponse*/
        ctx2[5];
      if (dirty[0] & /*status*/
      4)
        chatview_changes.status = /*status*/
        ctx2[2];
      if (dirty[0] & /*webSearchEnabled*/
      4096)
        chatview_changes.webSearchEnabled = /*webSearchEnabled*/
        ctx2[12];
      if (dirty[0] & /*searchStatus*/
      256)
        chatview_changes.searchStatus = /*searchStatus*/
        ctx2[8];
      if (dirty[0] & /*searchQueries*/
      512)
        chatview_changes.searchQueries = /*searchQueries*/
        ctx2[9];
      if (dirty[0] & /*webSearchResults*/
      1024)
        chatview_changes.webSearchResults = /*webSearchResults*/
        ctx2[10];
      if (dirty[0] & /*activeCommandId*/
      2)
        chatview_changes.activeCommandId = /*activeCommandId*/
        ctx2[1];
      if (!updating_userPrompt && dirty[0] & /*userPrompt*/
      64) {
        updating_userPrompt = true;
        chatview_changes.userPrompt = /*userPrompt*/
        ctx2[6];
        add_flush_callback(() => updating_userPrompt = false);
      }
      chatview.$set(chatview_changes);
      if (
        /*status*/
        ctx2[2] === "streaming"
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block3(ctx2);
          if_block3.c();
          if_block3.m(div3, null);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      const settingsdrawer_changes = {};
      if (dirty[0] & /*plugin*/
      1)
        settingsdrawer_changes.plugin = /*plugin*/
        ctx2[0];
      if (!updating_open && dirty[0] & /*settingsOpen*/
      8) {
        updating_open = true;
        settingsdrawer_changes.open = /*settingsOpen*/
        ctx2[3];
        add_flush_callback(() => updating_open = false);
      }
      settingsdrawer.$set(settingsdrawer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block2);
      transition_in(chatview.$$.fragment, local);
      transition_in(settingsdrawer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block2);
      transition_out(chatview.$$.fragment, local);
      transition_out(settingsdrawer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      destroy_component(chatview);
      if (if_block3)
        if_block3.d();
      destroy_component(settingsdrawer);
      mounted = false;
      run_all(dispose);
    }
  };
}
function stripThinkingTags2(text2) {
  let cleaned = text2;
  cleaned = cleaned.replace(/<think>[\s\S]*?<\/think>/gi, "");
  cleaned = cleaned.replace(/<think>[\s\S]*?<think>/gi, "");
  cleaned = cleaned.replace(/<\/?think>/gi, "");
  return cleaned.trim();
}
function isObsidianCommandMessage(content) {
  return content.trim().startsWith("<obsidian_command>");
}
function cleanReferenceMarkers(text2, searchResults) {
  let cleaned = text2;
  cleaned = cleaned.replace(/\[REF\]web_search_results\.(\d+)\[\/REF\]/gi, (match, index) => {
    const idx = parseInt(index, 10);
    if ((searchResults === null || searchResults === void 0 ? void 0 : searchResults.results) && searchResults.results[idx]) {
      const result = searchResults.results[idx];
      return `[${result.title}](${result.url})`;
    }
    return "";
  });
  if (searchResults === null || searchResults === void 0 ? void 0 : searchResults.results) {
    cleaned = cleaned.replace(/\[Source Title\]\(([^)]+)\)/gi, (match, url) => {
      const result = searchResults.results.find((r) => r.url === url || url.includes(r.url) || r.url.includes(url));
      if (result) {
        return `[${result.title}](${result.url})`;
      }
      try {
        const domain = new URL(url).hostname.replace("www.", "");
        return `[${domain}](${url})`;
      } catch (_a) {
        return match;
      }
    });
  }
  return cleaned;
}
function instance3($$self, $$props, $$invalidate) {
  let activeCommand;
  let { plugin } = $$props;
  let { initialCommandId = void 0 } = $$props;
  const onClose = () => {
  };
  let handleClose = onClose;
  let activeCommandId = initialCommandId || "note_chat";
  let status = initialCommandId ? "sending" : "idle";
  let messages = [];
  let currentResponse = "";
  let userPrompt = "";
  let error = null;
  let settingsOpen = false;
  let searchStatus = "";
  let searchQueries = [];
  let webSearchResults;
  let abortController = null;
  let conversationSaved = false;
  let webSearchEnabled = plugin.settings.webSearch.enabled;
  function handleToggleWebSearch() {
    $$invalidate(12, webSearchEnabled = !webSearchEnabled);
    $$invalidate(0, plugin.settings.webSearch.enabled = webSearchEnabled, plugin);
    plugin.saveSettings();
  }
  function loadHistory() {
    if (!activeCommandId)
      return;
    const command = COMMANDS.find((c) => c.id === activeCommandId);
    if (!command)
      return;
    if (command.scope === "note" || command.scope === "vault") {
      const context = getEditorContext(plugin.app);
      if (context) {
        let thread;
        if (command.scope === "note") {
          thread = plugin.historyService.getNoteThread(context.note.path);
        } else {
          thread = plugin.historyService.getVaultThread();
        }
        $$invalidate(4, messages = thread.messages.filter((m) => m.role === "user" || m.role === "assistant").map((m) => ({ role: m.role, content: m.content })));
      }
    } else {
      $$invalidate(4, messages = []);
    }
  }
  async function runCommand() {
    var _a;
    if (status !== "sending")
      return;
    if (!activeCommandId) {
      $$invalidate(7, error = "Please select a command from the menu above to get started.");
      $$invalidate(2, status = "error");
      return;
    }
    const command = COMMANDS.find((c) => c.id === activeCommandId);
    if (!command) {
      $$invalidate(7, error = "Command not found");
      $$invalidate(2, status = "error");
      return;
    }
    const activeProvider = plugin.settings.activeProvider;
    const providerConfig = plugin.settings.providers[activeProvider];
    if (!providerConfig) {
      $$invalidate(7, error = `No configuration found for ${activeProvider}. Please configure it in settings.`);
      $$invalidate(2, status = "error");
      return;
    }
    if (activeProvider === "ollama") {
      if (!providerConfig.baseUrl) {
        $$invalidate(7, error = "Ollama URL not configured. Please set the Ollama server URL in settings (e.g., http://localhost:11434).");
        $$invalidate(2, status = "error");
        return;
      }
    } else {
      if (!providerConfig.apiKey) {
        $$invalidate(7, error = `API key not configured for ${activeProvider}. Please add your API key in settings.`);
        $$invalidate(2, status = "error");
        return;
      }
      if (!providerConfig.baseUrl) {
        $$invalidate(7, error = `Base URL not configured for ${activeProvider}. Please set the API endpoint in settings.`);
        $$invalidate(2, status = "error");
        return;
      }
    }
    if (!providerConfig.model) {
      $$invalidate(7, error = `No model selected for ${activeProvider}. Please select a model in settings.`);
      $$invalidate(2, status = "error");
      return;
    }
    let streamError = null;
    try {
      $$invalidate(2, status = "streaming");
      $$invalidate(5, currentResponse = "");
      abortController = new AbortController();
      let context = getEditorContext(plugin.app);
      if (!context && command.scope === "selection") {
        $$invalidate(7, error = `"${command.title}" requires selected text. Please select some text in a note first.`);
        $$invalidate(2, status = "error");
        return;
      }
      if (context && command.scope === "selection" && (!context.selection || !context.selection.text.trim())) {
        $$invalidate(7, error = `"${command.title}" requires selected text. Please select some text in a note first.`);
        $$invalidate(2, status = "error");
        return;
      }
      if (!context && command.scope === "note") {
        $$invalidate(7, error = `"${command.title}" requires an open note. Please open a note first.`);
        $$invalidate(2, status = "error");
        return;
      }
      if (webSearchEnabled && command.allowWebSearch) {
        $$invalidate(2, status = "searching");
        $$invalidate(8, searchStatus = "Generating web search query...");
        $$invalidate(9, searchQueries = []);
        $$invalidate(10, webSearchResults = void 0);
        try {
          const providerSettings2 = plugin.settings.providers[plugin.settings.activeProvider];
          const client2 = createProviderClient(plugin.settings.activeProvider, providerSettings2);
          const queryMessages = generateSearchQueryMessages(context, userPrompt, command.scope);
          let refinedQuery = "";
          const refineResponse = await client2.chat(
            {
              messages: queryMessages,
              model: providerSettings2.model,
              temperature: 0.1,
              // Strict factual
              stream: false
            },
            (event) => {
              if (event.type === "token")
                refinedQuery += event.value;
            },
            abortController.signal
          );
          if (!refinedQuery && refineResponse.content) {
            refinedQuery = refineResponse.content;
          }
          refinedQuery = refinedQuery.trim().replace(/^["']|["']$/g, "");
          console.log("Refined Search Query:", refinedQuery);
          if (refinedQuery) {
            $$invalidate(9, searchQueries = [refinedQuery]);
            $$invalidate(8, searchStatus = `Searching web...`);
            try {
              const results = await runSearxngSearch(refinedQuery, plugin.settings.webSearch);
              $$invalidate(10, webSearchResults = results);
              $$invalidate(8, searchStatus = `Found ${results.results.length} results.`);
            } catch (sErr) {
              console.error("SearXNG Search Failed:", sErr);
              $$invalidate(7, error = `Web Search Failed: ${sErr.message || "Unknown error"}`);
              $$invalidate(8, searchStatus = "Web search failed. Continuing...");
            }
          } else {
            $$invalidate(8, searchStatus = "\u26A0\uFE0F Could not generate a search query.");
          }
        } catch (e) {
          console.warn("Search workflow failed, proceeding without search:", e);
          $$invalidate(8, searchStatus = "");
          if (e.name !== "AbortError") {
          }
        }
      }
      $$invalidate(2, status = "streaming");
      const envelope = await buildPromptEnvelope(command, context, userPrompt, webSearchResults, plugin.vaultSummaryCache);
      const systemMsgContent = createSystemMessage(command);
      const userMsgContent = createUserMessage(envelope);
      let threadId;
      if (command.scope === "note" || command.scope === "vault") {
        let thread;
        if (command.scope === "note") {
          thread = plugin.historyService.getNoteThread(context.note.path);
        } else {
          thread = plugin.historyService.getVaultThread();
        }
        threadId = thread.id;
      }
      const messagesForAPI = [
        {
          role: "system",
          content: systemMsgContent
        },
        ...messages.map((m) => ({ role: m.role, content: m.content })),
        { role: "user", content: userMsgContent }
      ];
      const providerSettings = plugin.settings.providers[plugin.settings.activeProvider];
      const client = createProviderClient(plugin.settings.activeProvider, providerSettings);
      await client.chat(
        {
          messages: messagesForAPI,
          model: providerSettings.model,
          temperature: providerSettings.temperature || 0.7,
          stream: true
        },
        (event) => {
          if (event.type === "token") {
            $$invalidate(5, currentResponse += event.value);
          } else if (event.type === "error") {
            streamError = new Error(event.message);
            abortController === null || abortController === void 0 ? void 0 : abortController.abort();
          }
        },
        abortController.signal
      );
      if (streamError) {
        throw streamError;
      }
      const newMessageContext = context;
      $$invalidate(4, messages = [
        ...messages,
        { role: "user", content: userMsgContent },
        {
          role: "assistant",
          content: currentResponse,
          context: newMessageContext
        }
      ]);
      $$invalidate(2, status = "idle");
      $$invalidate(6, userPrompt = "");
      if (threadId) {
        plugin.historyService.addMessage(threadId, { role: "user", content: userMsgContent });
        plugin.historyService.addMessage(threadId, {
          role: "assistant",
          content: currentResponse
        });
      }
    } catch (err) {
      console.error("RunCommand Error:", err);
      if (err.name === "AbortError" || err.message === "Aborted") {
        if (streamError) {
          err = streamError;
        } else {
          $$invalidate(2, status = "idle");
          return;
        }
      }
      $$invalidate(5, currentResponse = "");
      let msg = err.message || "";
      if (err.code)
        msg += ` ${err.code}`;
      if (!msg && typeof err === "string")
        msg = err;
      let friendlyMessage = "An unexpected error occurred.";
      const streamMatch = msg.match(/Stream failed: (\d+) ([\s\S]*)/);
      if (streamMatch) {
        const code = parseInt(streamMatch[1]);
        const body = streamMatch[2];
        let remoteMsg = "";
        try {
          const jsonStart = body.indexOf("{");
          if (jsonStart !== -1) {
            const json = JSON.parse(body.substring(jsonStart));
            remoteMsg = ((_a = json.error) === null || _a === void 0 ? void 0 : _a.message) || json.message || "";
          }
        } catch (_b) {
        }
        switch (code) {
          case 401:
            friendlyMessage = "Authentication failed. Please check your API key in settings.";
            break;
          case 403:
            friendlyMessage = "Access denied. Please check your API key and permissions.";
            break;
          case 404:
            friendlyMessage = "The selected model is unavailable or the provider endpoint is incorrect.";
            break;
          case 429:
            friendlyMessage = "Rate limit exceeded. Please wait a moment or check your usage quota.";
            break;
          case 500:
          case 502:
          case 503:
          case 504:
            friendlyMessage = "The AI provider is currently unavailable. Please try again later.";
            break;
          default:
            if (remoteMsg) {
              if (remoteMsg.toLowerCase().includes("quota")) {
                friendlyMessage = "You have exceeded your API quota.";
              } else if (remoteMsg.length < 80) {
                friendlyMessage = remoteMsg;
              } else {
                friendlyMessage = `Provider error (${code}). Check console for details.`;
              }
            } else {
              friendlyMessage = `Connection failed (${code}).`;
            }
        }
      } else {
        const lowerMsg = msg.toLowerCase();
        if (lowerMsg.includes("enotfound") || lowerMsg.includes("econnrefused") || lowerMsg.includes("err_name_not_resolved") || lowerMsg.includes("failed to fetch") || lowerMsg.includes("timed out") || lowerMsg.includes("fetch failed")) {
          if (plugin.settings.activeProvider === "ollama") {
            friendlyMessage = "Unable to connect to Ollama. Ensure it is running (usually localhost:11434).";
          } else {
            friendlyMessage = "Network error. Please check your internet connection and API settings.";
          }
        } else if (lowerMsg.includes("invalid url")) {
          friendlyMessage = "The provider URL is invalid. Please check your settings.";
        } else {
          friendlyMessage = msg.length < 100 ? msg : "An error occurred while communicating with the AI provider.";
        }
      }
      $$invalidate(7, error = friendlyMessage);
      $$invalidate(2, status = "error");
    }
  }
  function handleCommandSelect(commandId) {
    const command = COMMANDS.find((c) => c.id === commandId);
    if (!command)
      return;
    $$invalidate(1, activeCommandId = commandId);
    $$invalidate(4, messages = []);
    $$invalidate(5, currentResponse = "");
    $$invalidate(7, error = null);
    $$invalidate(9, searchQueries = []);
    $$invalidate(10, webSearchResults = void 0);
    $$invalidate(8, searchStatus = "");
    loadHistory();
    if (command.scope === "selection" || command.delivery !== "chat_only") {
      $$invalidate(2, status = "sending");
    }
  }
  function handleSendMessage() {
    if (!activeCommandId) {
      $$invalidate(7, error = "Please select a command from the menu above to get started.");
      return;
    }
    if (status === "error") {
      $$invalidate(7, error = null);
    }
    $$invalidate(2, status = "sending");
  }
  function handleStopGeneration() {
    if (abortController) {
      abortController.abort();
    }
  }
  function handleReset() {
    $$invalidate(4, messages = []);
    $$invalidate(5, currentResponse = "");
    $$invalidate(6, userPrompt = "");
    $$invalidate(7, error = null);
    $$invalidate(2, status = "idle");
    $$invalidate(1, activeCommandId = null);
    $$invalidate(9, searchQueries = []);
    $$invalidate(10, webSearchResults = void 0);
  }
  function handleClearHistory() {
    var _a;
    const command = activeCommand;
    if (command) {
      if (command.scope === "vault") {
        plugin.historyService.clearVaultThread();
      } else if (command.scope === "note") {
        const context = getEditorContext(plugin.app);
        if ((_a = context === null || context === void 0 ? void 0 : context.note) === null || _a === void 0 ? void 0 : _a.path) {
          plugin.historyService.clearNoteThread(context.note.path);
        }
      }
    } else {
      plugin.historyService.clearVaultThread();
    }
    handleReset();
  }
  function handleReplace(event) {
    const { context, text: text2 } = event.detail;
    const leaf = plugin.app.workspace.getLeavesOfType("markdown").find((leaf2) => {
      var _a;
      return ((_a = leaf2.view.file) === null || _a === void 0 ? void 0 : _a.path) === context.note.path;
    });
    if (leaf) {
      const view = leaf.view;
      if (context.selection) {
        const editor = view.editor;
        editor.replaceRange(text2, context.selection.from, context.selection.to);
      } else {
        const editor = view.editor;
        editor.replaceSelection(text2);
      }
    } else {
      $$invalidate(7, error = "Original note not open.");
    }
  }
  async function createResearchNote(rawContent, showSavedFeedback = false) {
    let cleanContent = stripThinkingTags2(rawContent);
    cleanContent = cleanContent.replace(/^##?\s*(Answer|Response|Reply):?\s*\n+/i, "").replace(/^(Certainly!?|Sure!?|Of course!?|Here('s| is| are))[^\n]*\n+/i, "").replace(/^(Below is|Here's|The following)[^\n]*:\n+/i, "").trim();
    let researchTitle = "";
    let h1Match = cleanContent.match(/^#\s+([^\n]+)/);
    if (h1Match) {
      researchTitle = h1Match[1].trim();
      cleanContent = cleanContent.replace(/^#\s+[^\n]+\n*/, "").trim();
    } else {
      h1Match = cleanContent.match(/^#\s+([^\n]+)/m);
      if (h1Match) {
        researchTitle = h1Match[1].trim();
        cleanContent = cleanContent.replace(/^#\s+[^\n]+\n*/m, "").trim();
      }
    }
    if (!researchTitle) {
      const firstCommandMsg = messages.find((m) => m.role === "user" && isObsidianCommandMessage(m.content));
      if (firstCommandMsg) {
        try {
          const jsonMatch = firstCommandMsg.content.match(/<obsidian_command>\s*([\s\S]*?)\s*<\/obsidian_command>/);
          if (jsonMatch) {
            const envelope = JSON.parse(jsonMatch[1]);
            if (envelope.user_prompt) {
              researchTitle = envelope.user_prompt.split("\n")[0].slice(0, 80);
            }
          }
        } catch (_a) {
        }
      }
    }
    let fileName = researchTitle.replace(/[\\/:*?"<>|]/g, "").replace(/\s+/g, " ").trim().slice(0, 100);
    if (!fileName) {
      fileName = `Research ${new Date().toISOString().slice(0, 10)}`;
    }
    fileName += ".md";
    cleanContent = cleanReferenceMarkers(cleanContent, webSearchResults);
    const date = new Date().toLocaleDateString("en-US", {
      year: "numeric",
      month: "long",
      day: "numeric"
    });
    const finalContent = `*Created on ${date}*

---

${cleanContent}`;
    try {
      const existingFile = plugin.app.vault.getAbstractFileByPath(fileName);
      if (existingFile) {
        $$invalidate(7, error = `A note named "${fileName}" already exists. Please choose a different name.`);
        return;
      }
      const newFile = await plugin.app.vault.create(fileName, finalContent);
      if (showSavedFeedback) {
        $$invalidate(11, conversationSaved = true);
        setTimeout(
          () => {
            $$invalidate(11, conversationSaved = false);
          },
          1500
        );
      }
      const leaf = plugin.app.workspace.getLeaf(false);
      await leaf.openFile(newFile);
    } catch (err) {
      console.error("Failed to create note:", err);
      $$invalidate(7, error = `Failed to create note: ${err.message || "Unknown error"}`);
    }
  }
  async function handleCreateNote(event) {
    const { content } = event.detail;
    await createResearchNote(content, false);
  }
  function openCommandPicker() {
    new CommandPickerModal(
      plugin,
      (commandId) => {
        handleCommandSelect(commandId);
      }
    ).open();
  }
  async function handleSaveConversation() {
    if (messages.length === 0)
      return;
    const lastAssistantMsg = [...messages].reverse().find((m) => m.role === "assistant" && !isObsidianCommandMessage(m.content));
    if (!lastAssistantMsg) {
      $$invalidate(7, error = "No assistant response found to save.");
      return;
    }
    await createResearchNote(lastAssistantMsg.content, true);
  }
  const click_handler = () => $$invalidate(3, settingsOpen = true);
  const click_handler_1 = () => $$invalidate(7, error = null);
  function chatview_userPrompt_binding(value) {
    userPrompt = value;
    $$invalidate(6, userPrompt);
  }
  function settingsdrawer_open_binding(value) {
    settingsOpen = value;
    $$invalidate(3, settingsOpen);
  }
  $$self.$$set = ($$props2) => {
    if ("plugin" in $$props2)
      $$invalidate(0, plugin = $$props2.plugin);
    if ("initialCommandId" in $$props2)
      $$invalidate(23, initialCommandId = $$props2.initialCommandId);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*initialCommandId*/
    8388608) {
      $:
        if (initialCommandId) {
          handleCommandSelect(initialCommandId);
          $$invalidate(23, initialCommandId = void 0);
        }
    }
    if ($$self.$$.dirty[0] & /*settingsOpen, plugin*/
    9) {
      $:
        if (!settingsOpen) {
          $$invalidate(12, webSearchEnabled = plugin.settings.webSearch.enabled);
        }
    }
    if ($$self.$$.dirty[0] & /*activeCommandId*/
    2) {
      $:
        $$invalidate(13, activeCommand = COMMANDS.find((c) => c.id === activeCommandId));
    }
    if ($$self.$$.dirty[0] & /*status*/
    4) {
      $:
        if (status === "sending") {
          runCommand();
        }
    }
  };
  return [
    plugin,
    activeCommandId,
    status,
    settingsOpen,
    messages,
    currentResponse,
    userPrompt,
    error,
    searchStatus,
    searchQueries,
    webSearchResults,
    conversationSaved,
    webSearchEnabled,
    activeCommand,
    handleToggleWebSearch,
    handleSendMessage,
    handleStopGeneration,
    handleReset,
    handleClearHistory,
    handleReplace,
    handleCreateNote,
    openCommandPicker,
    handleSaveConversation,
    initialCommandId,
    onClose,
    click_handler,
    click_handler_1,
    chatview_userPrompt_binding,
    settingsdrawer_open_binding
  ];
}
var App2 = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance3,
      create_fragment3,
      safe_not_equal,
      {
        plugin: 0,
        initialCommandId: 23,
        onClose: 24
      },
      null,
      [-1, -1]
    );
  }
  get onClose() {
    return this.$$.ctx[24];
  }
};
var App_default = App2;

// src/ui/view.ts
var VIEW_TYPE_AI_ASSISTANT = "ai-assistant-view";
var AiAssistantView = class extends import_obsidian7.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_AI_ASSISTANT;
  }
  getDisplayText() {
    return "AI assistant";
  }
  getIcon() {
    return "bot";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("h-full");
    container.addClass("ai-assistant-view-root");
    this.component = new App_default({
      target: container,
      props: {
        plugin: this.plugin,
        onClose: () => {
        }
      }
    });
  }
  setCommand(commandId) {
    if (this.component) {
      this.component.$set({ initialCommandId: commandId });
    }
  }
  async onClose() {
    if (this.component) {
      this.component.$destroy();
    }
  }
};

// src/main.ts
var AiAssistantPlugin = class extends import_obsidian8.Plugin {
  constructor(app, manifest) {
    super(app, manifest);
    this.settings = JSON.parse(JSON.stringify(DEFAULT_SETTINGS));
  }
  async onload() {
    console.debug("Loading AI Assistant Plugin...");
    await this.loadSettings();
    this.registerView(
      VIEW_TYPE_AI_ASSISTANT,
      (leaf) => new AiAssistantView(leaf, this)
    );
    const data = await this.loadData();
    const loadedSettings = (data == null ? void 0 : data.settings) || {};
    this.settings = {
      ...DEFAULT_SETTINGS,
      ...loadedSettings,
      providers: {
        ...DEFAULT_SETTINGS.providers,
        ...loadedSettings.providers || {}
      },
      webSearch: {
        ...DEFAULT_SETTINGS.webSearch,
        ...loadedSettings.webSearch || {}
      },
      history: {
        ...DEFAULT_SETTINGS.history,
        ...loadedSettings.history || {}
      },
      ui: {
        ...DEFAULT_SETTINGS.ui,
        ...loadedSettings.ui || {}
      }
    };
    this.historyService = new HistoryService(this, data == null ? void 0 : data.historyStore);
    this.vaultSummaryCache = new VaultSummaryCache(this);
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        trackActiveNote(this.app);
      })
    );
    this.addRibbonIcon("bot", "AI assistant", () => {
      void this.activateView();
    });
    this.addCommand({
      id: "open-ai-assistant",
      name: "Open AI assistant",
      callback: () => {
        void this.activateView();
      }
    });
    COMMANDS.forEach((cmd) => {
      this.addCommand({
        id: cmd.id,
        name: cmd.title,
        editorCallback: () => {
          void this.activateView(cmd.id);
        }
      });
    });
  }
  async activateView(commandId) {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_AI_ASSISTANT);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({ type: VIEW_TYPE_AI_ASSISTANT, active: true });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
      if (commandId) {
        const view = leaf.view;
        view.setCommand(commandId);
      }
    }
  }
  onunload() {
    void this.saveSettings();
  }
  async loadSettings() {
  }
  async saveSettings() {
    await this.saveData({
      settings: this.settings,
      historyStore: this.historyService.getStore()
    });
  }
};
/*! Bundled license information:

nunjucks/browser/nunjucks.js:
  (*! Browser bundle of nunjucks 3.2.4  *)
*/
